Nice move 👍
Now you’re switching from **grid DFS** → to a **graph DFS using adjacency list**.

Let me rewrite your algorithm in that style, step by step.

---

## 🔹 Graph DFS (Adjacency List)

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> adj[100]; // adjacency list for graph (max 100 nodes)

void dfs(int u, vector<bool>& isVisited)
{
    // mark node u as visited
    isVisited[u] = true;
    cout << u << " "; // print traversal order (optional)

    // explore neighbors of u
    for (auto v : adj[u])
    {
        if (!isVisited[v])
        {
            dfs(v, isVisited);
        }
    }
}

int main()
{
    int n, m;
    cin >> n >> m; // n = number of nodes, m = number of edges

    // input edges
    for (int i = 0; i < m; i++)
    {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u); // undirected graph
    }

    vector<bool> isVisited(n + 1, false);

    cout << "DFS Traversal: ";
    dfs(1, isVisited); // start DFS from node 1

    return 0;
}
```

---

## 🔹 Explanation

1. `vector<int> adj[100];`
   → adjacency list, where `adj[u]` stores all neighbors of node `u`.

2. `dfs(int u, vector<bool>& isVisited)`

   * Marks current node `u` as visited.
   * Iterates through all neighbors `v`.
   * If `v` is not visited → recursive DFS call.

3. In `main()`

   * Input `n` (nodes), `m` (edges).
   * Build the graph by filling adjacency list.
   * Start DFS from node `1` (can be any node).

---

## 🔹 Sample Input

```
6 5
1 2
1 3
2 4
2 5
3 6
```

Graph looks like:

```
     1
   /   \
  2     3
 / \     \
4   5     6
```

---

## 🔹 DFS Traversal Output

```
DFS Traversal: 1 2 4 5 3 6
```

---

⚡ This is the **standard adjacency list DFS** version.
👉 Do you want me to **combine this style with your grid DFS**, so you can switch between **matrix-based DFS** and **adjacency-list DFS** in one code?
