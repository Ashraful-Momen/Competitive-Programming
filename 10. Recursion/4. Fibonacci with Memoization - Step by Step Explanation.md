# Fibonacci with Memoization - Step by Step Explanation

## Code Overview
This implementation uses **Dynamic Programming with Memoization** to efficiently calculate Fibonacci numbers by avoiding redundant calculations.

## Line-by-Line Code Explanation

### Main Function: `fib(int n)`
```cpp
int fib(int n) {
    vector<int> dp(n+1, -1);     // Line 1: Create memoization array
    int res = calcFib(n, dp);    // Line 2: Call recursive helper
    return res;                  // Line 3: Return result
}
```

**Line 1:** `vector<int> dp(n+1, -1);`
- Creates a vector of size `n+1` 
- All elements initialized to `-1` (indicates "not calculated yet")
- `dp[i]` will store the Fibonacci value for number `i`

**Line 2:** `int res = calcFib(n, dp);`
- Calls the recursive helper function
- Passes the target number `n` and reference to memoization array

**Line 3:** `return res;`
- Returns the calculated Fibonacci value

### Recursive Helper: `calcFib(int n, vector<int> &dp)`
```cpp
int calcFib(int n, vector<int> &dp) {
    if ( n <= 1 ) return n;              // Line 1: Base cases
    if (dp[n] != -1) return dp[n];       // Line 2: Check memo
    dp[n] = calcFib(n-1, dp) + calcFib(n-2, dp);  // Line 3: Recursive calls
    return dp[n];                        // Line 4: Return memoized result
}
```

**Line 1:** `if ( n <= 1 ) return n;`
- **Base cases:** fib(0) = 0, fib(1) = 1
- Stops recursion when we reach the bottom

**Line 2:** `if (dp[n] != -1) return dp[n];`
- **Memoization check:** If we already calculated fib(n), return stored value
- This prevents redundant calculations and makes it efficient

**Line 3:** `dp[n] = calcFib(n-1, dp) + calcFib(n-2, dp);`
- **Recursive relation:** fib(n) = fib(n-1) + fib(n-2)
- Makes two recursive calls and stores the sum in dp[n]

**Line 4:** `return dp[n];`
- Returns the calculated and memoized result

## Call Flow Visualization for fib(5)

```
fib(5) called:
│
├── dp = [-1, -1, -1, -1, -1, -1] (size 6)
└── calcFib(5, dp) called

calcFib(5):
│
├── n=5 > 1, continue
├── dp[5] == -1, not memoized
└── dp[5] = calcFib(4) + calcFib(3)
    │
    ├── calcFib(4) called
    │   │
    │   ├── n=4 > 1, continue
    │   ├── dp[4] == -1, not memoized  
    │   └── dp[4] = calcFib(3) + calcFib(2)
    │       │
    │       ├── calcFib(3) called
    │       │   │
    │       │   ├── n=3 > 1, continue
    │       │   ├── dp[3] == -1, not memoized
    │       │   └── dp[3] = calcFib(2) + calcFib(1)
    │       │       │
    │       │       ├── calcFib(2) called
    │       │       │   │
    │       │       │   ├── n=2 > 1, continue
    │       │       │   ├── dp[2] == -1, not memoized
    │       │       │   └── dp[2] = calcFib(1) + calcFib(0)
    │       │       │       │
    │       │       │       ├── calcFib(1): n≤1 → return 1
    │       │       │       └── calcFib(0): n≤1 → return 0
    │       │       │       
    │       │       │   dp[2] = 1 + 0 = 1 ✓
    │       │       │
    │       │       └── calcFib(1): n≤1 → return 1
    │       │       
    │       │   dp[3] = 1 + 1 = 2 ✓
    │       │
    │       └── calcFib(2): dp[2] != -1 → return dp[2] = 1 (MEMOIZED!)
    │       
    │   dp[4] = 2 + 1 = 3 ✓
    │
    └── calcFib(3): dp[3] != -1 → return dp[3] = 2 (MEMOIZED!)
    
dp[5] = 3 + 2 = 5 ✓

Final dp array: [-1, 1, 1, 2, 3, 5]
Result: 5
```

## Memory State Changes

```
Initial: dp = [-1, -1, -1, -1, -1, -1]
                0   1   2   3   4   5

After calcFib(0): dp = [-1, -1, -1, -1, -1, -1] (base case, no storage)
After calcFib(1): dp = [-1, -1, -1, -1, -1, -1] (base case, no storage)
After calcFib(2): dp = [-1, -1,  1, -1, -1, -1]
After calcFib(3): dp = [-1, -1,  1,  2, -1, -1]
After calcFib(4): dp = [-1, -1,  1,  2,  3, -1]
After calcFib(5): dp = [-1, -1,  1,  2,  3,  5]
```

## Key Benefits of Memoization

1. **Eliminates Redundant Calculations**
   - Without memo: calcFib(3) would be called multiple times
   - With memo: calcFib(3) calculated once, then reused

2. **Time Complexity Improvement**
   - Without memo: O(2^n) - exponential
   - With memo: O(n) - linear

3. **Space Complexity**: O(n) for the dp array

## Execution Count Comparison

**Without Memoization (fib(5)):**
- calcFib(5): 1 time
- calcFib(4): 1 time  
- calcFib(3): 2 times
- calcFib(2): 3 times
- calcFib(1): 5 times
- calcFib(0): 3 times
**Total: 15 function calls**

**With Memoization (fib(5)):**
- calcFib(5): 1 time
- calcFib(4): 1 time
- calcFib(3): 1 time
- calcFib(2): 1 time
- calcFib(1): 2 times (base cases)
- calcFib(0): 1 time (base case)
**Total: 7 function calls**

The memoization approach cuts the function calls by more than half even for small inputs, and the savings become exponentially better for larger inputs!
