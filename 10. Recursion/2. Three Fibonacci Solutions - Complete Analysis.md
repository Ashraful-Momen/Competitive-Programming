# Three Fibonacci Solutions - Complete Analysis

## Solution 1: Bottom-Up Dynamic Programming (Tabulation)

### Code Breakdown
```cpp
class Solution {
public:
    int fib(int n) {
        //base case: 
        if(n <= 1) return n;                    // Line 1
        //start from here : 
        int f[n+1];                            // Line 2
        f[0] = 0;                              // Line 3
        f[1] = 1;                              // Line 4
        for ( int i = 2; i <= n; i++ ) {       // Line 5
            f[i] = f[i-1] + f[i-2];            // Line 6
        }
        return f[n];                           // Line 7
    }
};
```

### Line-by-Line Explanation

**Line 1:** `if(n <= 1) return n;`
- **Base cases:** fib(0) = 0, fib(1) = 1
- Handles edge cases directly without computation

**Line 2:** `int f[n+1];`
- Creates array of size `n+1` to store all Fibonacci values from 0 to n
- **Memory:** O(n) space complexity

**Lines 3-4:** Initialize base cases
- `f[0] = 0` → First Fibonacci number
- `f[1] = 1` → Second Fibonacci number

**Line 5:** `for ( int i = 2; i <= n; i++ )`
- **Bottom-up approach:** Build solution from smallest to largest
- Starts from index 2, goes up to n

**Line 6:** `f[i] = f[i-1] + f[i-2];`
- **Fibonacci recurrence:** Each number is sum of previous two
- Uses already computed values (no recursion needed)

**Line 7:** `return f[n];`
- Returns the final computed Fibonacci value

### Execution Flow for fib(5)

```
Step 0: n = 5, n > 1, continue
Step 1: Create array f[6]
Step 2: f[0] = 0, f[1] = 1

Array state: [0, 1, ?, ?, ?, ?]
                0  1  2  3  4  5

Loop iterations:
i=2: f[2] = f[1] + f[0] = 1 + 0 = 1
     Array: [0, 1, 1, ?, ?, ?]

i=3: f[3] = f[2] + f[1] = 1 + 1 = 2  
     Array: [0, 1, 1, 2, ?, ?]

i=4: f[4] = f[3] + f[2] = 2 + 1 = 3
     Array: [0, 1, 1, 2, 3, ?]

i=5: f[5] = f[4] + f[3] = 3 + 2 = 5
     Array: [0, 1, 1, 2, 3, 5]

Return f[5] = 5 ✓
```

**Time Complexity:** O(n) - Single loop
**Space Complexity:** O(n) - Array storage

---

## Solution 2: Bottom-Up with Space Optimization

### Code Breakdown
```cpp
class Solution {
public:
    int fib(int n) {
        if(n <= 1) return n;                   // Line 1
        int oneStepPrevF = 0;                  // Line 2
        int prevF = 1;                         // Line 3
        int curF;                              // Line 4
        for ( int i = 2; i <= n; i++ ) {       // Line 5
            curF = prevF + oneStepPrevF;       // Line 6
            oneStepPrevF = prevF;              // Line 7
            prevF = curF;                      // Line 8
        }
        return curF;                           // Line 9
    }
};
```

### Line-by-Line Explanation

**Line 1:** `if(n <= 1) return n;`
- Same base case handling as Solution 1

**Lines 2-4:** Variable initialization
- `oneStepPrevF = 0` → Tracks fib(i-2)
- `prevF = 1` → Tracks fib(i-1) 
- `curF` → Will store fib(i)

**Key Insight:** We only need the last 2 values to compute the next one!

**Line 6:** `curF = prevF + oneStepPrevF;`
- Calculate current Fibonacci number
- Same logic as `f[i] = f[i-1] + f[i-2]` but using variables

**Lines 7-8:** Slide the window
- `oneStepPrevF = prevF` → Previous becomes two-steps-previous
- `prevF = curF` → Current becomes previous

### Execution Flow for fib(5)

```
Initial: oneStepPrevF=0, prevF=1, curF=?

i=2: curF = 1 + 0 = 1
     oneStepPrevF = 1 (was prevF)
     prevF = 1 (was curF)
     State: [oneStepPrevF=1, prevF=1, curF=1]

i=3: curF = 1 + 1 = 2
     oneStepPrevF = 1 (was prevF) 
     prevF = 2 (was curF)
     State: [oneStepPrevF=1, prevF=2, curF=2]

i=4: curF = 2 + 1 = 3
     oneStepPrevF = 2 (was prevF)
     prevF = 3 (was curF) 
     State: [oneStepPrevF=2, prevF=3, curF=3]

i=5: curF = 3 + 2 = 5
     oneStepPrevF = 3 (was prevF)
     prevF = 5 (was curF)
     State: [oneStepPrevF=3, prevF=5, curF=5]

Return curF = 5 ✓
```

### Variable Sliding Window Visualization
```
Variables represent sliding window over the sequence:

Iteration 2: [oneStepPrevF][prevF] -> curF
             [     0     ][  1  ] -> 1
             
Iteration 3: [oneStepPrevF][prevF] -> curF  
             [     1     ][  1  ] -> 2
             
Iteration 4: [oneStepPrevF][prevF] -> curF
             [     1     ][  2  ] -> 3
             
Iteration 5: [oneStepPrevF][prevF] -> curF
             [     2     ][  3  ] -> 5
```

**Time Complexity:** O(n) - Single loop
**Space Complexity:** O(1) - Only 3 variables!

---

## Solution 3: Pure Recursion (Top-Down)

### Code Breakdown
```cpp
class Solution {
public:
    int calcFib(int n) {
        if ( n <= 1 ) return n;                    // Line 1
        int res = calcFib(n-1) + calcFib(n-2);     // Line 2
        return res;                                // Line 3
    }
    int fib(int n) {
        int res = calcFib(n);                      // Line 4
        return res;                                // Line 5
    }
};
```

### Line-by-Line Explanation

**Line 1:** `if ( n <= 1 ) return n;`
- Base cases to stop recursion
- fib(0) = 0, fib(1) = 1

**Line 2:** `int res = calcFib(n-1) + calcFib(n-2);`
- **Recursive calls:** Break down problem into smaller subproblems
- **No memoization:** Each call recalculates from scratch

**Lines 3-5:** Return statements
- Simple wrapper and result returning

### Recursive Call Tree for fib(5)

```
                    calcFib(5)
                   /          \
              calcFib(4)      calcFib(3)
             /        \       /        \
        calcFib(3)  calcFib(2) calcFib(2) calcFib(1)
       /       \    /       \   /      \      |
  calcFib(2) calcFib(1) calcFib(1) calcFib(0) calcFib(1) calcFib(0)  1
  /      \      |         |         |      |         |      |
calcFib(1) calcFib(0)    1         1       0    1       1      0
    |         |
    1         0

Final computation:
calcFib(5) = calcFib(4) + calcFib(3)
           = 3 + 2 = 5 ✓
```

### Step-by-Step Execution

```
Call Stack Depth and Returns:

1. calcFib(5) calls calcFib(4) and calcFib(3)
   
2. calcFib(4) calls calcFib(3) and calcFib(2)
   
3. calcFib(3) calls calcFib(2) and calcFib(1)
   
4. calcFib(2) calls calcFib(1) and calcFib(0)
   
5. Base cases reached:
   calcFib(1) returns 1
   calcFib(0) returns 0
   
6. Working back up:
   calcFib(2) = 1 + 0 = 1
   calcFib(3) = 1 + 1 = 2  
   calcFib(4) = 2 + 1 = 3
   
7. calcFib(3) called again = 2 (recalculated!)
   
8. calcFib(5) = 3 + 2 = 5
```

### Function Call Count Analysis

```
Function calls for each number:
calcFib(0): 3 times
calcFib(1): 5 times  
calcFib(2): 3 times
calcFib(3): 2 times
calcFib(4): 1 time
calcFib(5): 1 time

Total function calls: 15
```

**Time Complexity:** O(2^n) - Exponential growth
**Space Complexity:** O(n) - Call stack depth

---

## Comparison Summary

| Solution | Approach | Time | Space | Pros | Cons |
|----------|----------|------|-------|------|------|
| **Solution 1** | Bottom-Up DP | O(n) | O(n) | Easy to understand, all values stored | Uses extra array |
| **Solution 2** | Space Optimized | O(n) | O(1) | Most efficient, constant space | Slightly more complex logic |
| **Solution 3** | Pure Recursion | O(2^n) | O(n) | Most intuitive, matches math definition | Extremely slow for large n |

## Performance for fib(10):

- **Solution 1:** 9 iterations, array[11]
- **Solution 2:** 9 iterations, 3 variables  
- **Solution 3:** 177 function calls!

## Execution Time Growth:

```
n=5:  Sol1=5 ops,   Sol2=5 ops,   Sol3=15 calls
n=10: Sol1=10 ops,  Sol2=10 ops,  Sol3=177 calls  
n=20: Sol1=20 ops,  Sol2=20 ops,  Sol3=21,891 calls
n=30: Sol1=30 ops,  Sol2=30 ops,  Sol3=2,692,537 calls!
```

**Bottom Line:** Solution 2 (space optimized) is the best for production code, while Solution 3 (pure recursion) is only good for understanding the problem conceptually.
