
---

### üåü **Problem: Compute the Nth Fibonacci Number using Memoization**

The Fibonacci sequence is:
```
F(0) = 0
F(1) = 1
F(n) = F(n-1) + F(n-2)
```

So: `0, 1, 1, 2, 3, 5, 8, 13, ...`

We want to compute `F(n)` efficiently using **recursion + memoization** (top-down DP).

---

### ‚úÖ Code Overview

```cpp
class Solution {
public:
    int calcFib(int n, vector<int> &dp) {
        if (n <= 1) return n;
        if (dp[n] != -1) return dp[n];

        dp[n] = calcFib(n-1, dp) + calcFib(n-2, dp);
        return dp[n];
    }

    int fib(int n) {
        vector<int> dp(n+1, -1);
        int res = calcFib(n, dp);
        return res;
    }
};
```

---

### üîç Step-by-Step Explanation

Let‚Äôs walk through `fib(5)`.

---

#### üîπ Step 1: `fib(5)` is called

```cpp
vector<int> dp(6, -1); // dp[0..5] all set to -1
```

Initial DP array:
```
Index:   0   1   2   3   4   5
        [-1, -1, -1, -1, -1, -1]
```

Then call `calcFib(5, dp)`

---

#### üîπ Step 2: `calcFib(5, dp)`

- `n = 5`, which is > 1 ‚Üí continue
- `dp[5] == -1` ‚Üí not memoized
- So compute: `calcFib(4, dp) + calcFib(3, dp)`

Now recurse into `calcFib(4, ...)`

---

#### üîπ Step 3: `calcFib(4, dp)`

- `n = 4 > 1`, `dp[4] == -1`
- Compute: `calcFib(3) + calcFib(2)`

Recurse into `calcFib(3, ...)`

---

#### üîπ Step 4: `calcFib(3, dp)`

- `n = 3 > 1`, `dp[3] == -1`
- Compute: `calcFib(2) + calcFib(1)`

Recurse into `calcFib(2, ...)`

---

#### üîπ Step 5: `calcFib(2, dp)`

- `n = 2 > 1`, `dp[2] == -1`
- Compute: `calcFib(1) + calcFib(0)`

Now:

- `calcFib(1)` ‚Üí `n <= 1` ‚Üí returns `1`
- `calcFib(0)` ‚Üí `n <= 1` ‚Üí returns `0`

So:
```cpp
dp[2] = 1 + 0 = 1
```

Update DP:
```
Index:   0   1   2   3   4   5
        [ 0,  1,  1, -1, -1, -1]
```

Return `1` to `calcFib(3)`

---

#### üîπ Step 6: Back to `calcFib(3)`

Now:
- `calcFib(2) = 1`
- `calcFib(1) = 1` (direct base case)

So:
```cpp
dp[3] = 1 + 1 = 2
```

Update DP:
```
Index:   0   1   2   3   4   5
        [ 0,  1,  1,  2, -1, -1]
```

Return `2` to `calcFib(4)`

---

#### üîπ Step 7: Back to `calcFib(4)`

Now:
- `calcFib(3) = 2`
- Need `calcFib(2)` ‚Üí but `dp[2] == 1`, so **return memoized value**

So:
```cpp
dp[4] = 2 + 1 = 3
```

Update DP:
```
Index:   0   1   2   3   4   5
        [ 0,  1,  1,  2,  3, -1]
```

Return `3` to `calcFib(5)`

---

#### üîπ Step 8: Back to `calcFib(5)`

Now:
- `calcFib(4) = 3`
- `calcFib(3)` ‚Üí `dp[3] == 2` ‚Üí return memoized

So:
```cpp
dp[5] = 3 + 2 = 5
```

Final DP:
```
Index:   0   1   2   3   4   5
        [ 0,  1,  1,  2,  3,  5]
```

Return `5`

---

### ‚úÖ Final Result: `fib(5) = 5`

---

### üìà ASCII Visualization of Recursion Tree with Memoization

```
                  fib(5)
                /        \
           fib(4)         fib(3)         ‚Üê fib(3) computed once
           /     \        /      \
      fib(3)   fib(2)  fib(2)   fib(1)   ‚Üê fib(2) computed once
      /    \     /  \     |        |
  fib(2) fib(1) fib(1)fib(0)      1
   /  \     |     |      |
fib(1)fib(0)   1       0
   |     |
   1     0
```

But with **memoization**, repeated calls are **avoided**:

- `fib(3)` is computed only once ‚Üí stored in `dp[3]`
- `fib(2)` is computed once ‚Üí reused
- So the tree doesn't expand fully ‚Äî many branches are **pruned** via cache.

---

### üß† Key Concepts

| Feature | Explanation |
|--------|-------------|
| `dp[n] = -1` | Indicates "not computed yet". Since Fibonacci values are ‚â• 0, `-1` is safe as "unvisited" |
| `if (n <= 1) return n;` | Base cases: F(0)=0, F(1)=1 |
| `if (dp[n] != -1) return dp[n]` | **Memoization check** ‚Äî avoid recomputation |
| `dp[n] = calcFib(n-1) + calcFib(n-2)` | Recursive relation with caching |
| Time Complexity | **O(n)** ‚Äî each state computed once |
| Space Complexity | **O(n)** ‚Äî for DP array + recursion stack |

---

### üîÑ Example Run for `n = 5`

```text
fib(5)
‚îú‚îÄ‚îÄ calcFib(5): dp[5]=-1 ‚Üí compute
‚îÇ   ‚îú‚îÄ‚îÄ calcFib(4): dp[4]=-1 ‚Üí compute
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ calcFib(3): dp[3]=-1 ‚Üí compute
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ calcFib(2): dp[2]=-1 ‚Üí compute
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ calcFib(1) ‚Üí 1
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ calcFib(0) ‚Üí 0
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚Üí dp[2] = 1
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ calcFib(1) ‚Üí 1
‚îÇ   ‚îÇ   ‚îÇ   ‚Üí dp[3] = 1 + 1 = 2
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ calcFib(2) ‚Üí dp[2]=1 ‚Üí return 1
‚îÇ   ‚îÇ   ‚Üí dp[4] = 2 + 1 = 3
‚îÇ   ‚îú‚îÄ‚îÄ calcFib(3) ‚Üí dp[3]=2 ‚Üí return 2
‚îÇ   ‚Üí dp[5] = 3 + 2 = 5
‚Üê Result: 5
```

---

### ‚úÖ Summary

This code efficiently computes the **n-th Fibonacci number** using **top-down dynamic programming (memoization)**. It avoids the exponential time of naive recursion by storing already computed results.

üîß **Why it's better than plain recursion?**  
Without memoization: `O(2^n)`  
With memoization: `O(n)`

