
---

## 📘 C++ STL: `map` Complete Tutorial for Competitive Programming

The `map` is an **ordered associative container** that stores **key-value pairs** with **unique keys** in **sorted order** (by default in ascending order of keys).

---

### 🔹 1. **Declaration and Initialization**

```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {
    map<string, int> m;
    m["apple"] = 3;
    m["banana"] = 5;

    cout << m["apple"] << " " << m["banana"] << endl;
    return 0;
}
```

🖨️ **Output:**

```
3 5
```

📌 **Note:**

* Syntax: `map<key_type, value_type> name;`
* Keys are **sorted automatically**.
* Values can be updated using `[]`.

---

### 🔹 2. **Insert Elements**

```cpp
m.insert({"mango", 10});
m.insert(make_pair("lemon", 2));
```

📌 **Note:** `insert()` does **not** overwrite existing keys.

---

### 🔹 3. **Access Elements**

```cpp
cout << m["apple"];       // Value
cout << m.at("apple");    // Throws exception if key doesn't exist
```

📌 **Warning:** `m["new"]` **creates a key with value 0** if it doesn’t exist.

---

### 🔹 4. **Iterate over a Map**

```cpp
for (auto it : m) {
    cout << it.first << " -> " << it.second << endl;
}
```

🖨️ **Output:**

```
apple -> 3
banana -> 5
lemon -> 2
mango -> 10
```

📌 **Note:** Always sorted by key (ascending).

---

### 🔹 5. **Check If Key Exists**

```cpp
if (m.count("apple")) cout << "Exists!";
else cout << "Not found";
```

📌 **Note:**

* `count(key)` returns 1 if key exists, else 0.
* You can also use `m.find("apple") != m.end()`

---

### 🔹 6. **Erase Elements**

```cpp
m.erase("banana");         // Erase by key
m.erase(m.begin());        // Erase by iterator
```

📌 **Note:** Efficient and safe way to remove keys.

---

### 🔹 7. **Size and Empty Check**

```cpp
cout << m.size();   // Number of pairs
cout << m.empty();  // true if map is empty
```

---

### 🔹 8. **Custom Comparator (Descending Order)**

```cpp
map<int, int, greater<int>> m; // Sorts keys in descending order
```

---

### 🔹 9. **Map of Pairs / Nested Maps**

```cpp
map<int, pair<int, int>> mp;
mp[1] = {10, 20};

map<int, map<int, int>> nested;
nested[1][2] = 100;
```

---

### 🔹 10. **Find Key with Iterator**

```cpp
auto it = m.find("apple");
if (it != m.end())
    cout << it->first << ": " << it->second << endl;
```

---

### 🔹 11. **Clear Map**

```cpp
m.clear();  // Removes all elements
```

---

### 🔹 12. **Time Complexities**

| Operation     | Time Complexity (Balanced BST) |
| ------------- | ------------------------------ |
| Insert        | O(log n)                       |
| Find / Access | O(log n)                       |
| Erase         | O(log n)                       |
| Iterate All   | O(n)                           |

📌 `map` is implemented as **Red-Black Tree (BST)**.

---

### 🔸 unordered\_map vs map

| Feature         | `map`                  | `unordered_map`          |
| --------------- | ---------------------- | ------------------------ |
| Order           | Sorted by key          | No order (random)        |
| Time Complexity | O(log n)               | O(1) average, O(n) worst |
| Use In CP       | Safer for ordered keys | Faster for hashing       |

---

### ✅ Use Cases in Competitive Programming

| Use Case                  | Example                           |
| ------------------------- | --------------------------------- |
| Frequency count           | `map<int, int> freq;`             |
| Coordinate compression    | `map<int, int> index;`            |
| Mapping values to index   | `map<string, int>`                |
| Nested data               | `map<int, map<int, int>>`         |
| Priority by key (ordered) | Sorted processing of tasks/events |

---

### 🔁 Bonus: Iterate in Reverse Order

```cpp
for (auto it = m.rbegin(); it != m.rend(); ++it)
    cout << it->first << " => " << it->second << endl;
```

---

