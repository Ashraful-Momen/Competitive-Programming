I'll show the matrix format first, then explain the code step by step.

## Initial Matrix Format (ASCII Visualization)

```
After: vector<vector<int>> adj(n + 1, vector<int>(n + 1, 0));

Matrix Structure (n = 4):
Row/Col   0     1     2     3     4
    0  [  0  ,  0  ,  0  ,  0  ,  0  ]
    1  [  0  ,  0  ,  0  ,  0  ,  0  ]
    2  [  0  ,  0  ,  0  ,  0  ,  0  ]
    3  [  0  ,  0  ,  0  ,  0  ,  0  ]
    4  [  0  ,  0  ,  0  ,  0  ,  0  ]

Key:
- Rows 1-4 represent nodes 1-4 (we'll use these)
- Row 0 and Column 0 are unused (wasted but convenient)
- All values initialized to 0 (no edges)
```

Now let's see the step-by-step code:

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    // Step 1: Define number of nodes
    int n = 4;
    
    // Step 2: Create adjacency matrix
    vector<vector<int>> adj(n + 1, 
                          vector<int>(n + 1, 0));
    
    // Step 3: Add edges to create this graph:
    //    1
    //   / \
    //  2   3
    //   \ /
    //    4
    
    adj[1][2] = 1;  // Edge 1-2
    adj[2][1] = 1;  // Edge 2-1 (undirected)
    
    adj[1][3] = 1;  // Edge 1-3
    adj[3][1] = 1;  // Edge 3-1 (undirected)
    
    adj[2][4] = 1;  // Edge 2-4
    adj[4][2] = 1;  // Edge 4-2 (undirected)
    
    adj[3][4] = 1;  // Edge 3-4
    adj[4][3] = 1;  // Edge 4-3 (undirected)
    
    // Step 4: Print the matrix
    cout << "Final Adjacency Matrix:" << endl;
    cout << "   ";
    for (int i = 1; i <= n; i++) {
        cout << i << " ";
    }
    cout << endl;
    
    for (int i = 1; i <= n; i++) {
        cout << i << ": ";
        for (int j = 1; j <= n; j++) {
            cout << adj[i][j] << " ";
        }
        cout << endl;
    }
    
    return 0;
}
```

| Code Step | Explanation & Current Matrix State |
|-----------|-----------------------------------|
| `int n = 4;` | **Initialize**: Creating graph with 4 nodes |
| `vector<vector<int>> adj(n + 1, vector<int>(n + 1, 0));` | **Create empty matrix**: <br>```<br>   0 1 2 3 4<br>0: 0 0 0 0 0<br>1: 0 0 0 0 0  <br>2: 0 0 0 0 0<br>3: 0 0 0 0 0<br>4: 0 0 0 0 0<br>``` |
| `adj[1][2] = 1; adj[2][1] = 1;` | **Add edge 1-2**: <br>```<br>   0 1 2 3 4<br>0: 0 0 0 0 0<br>1: 0 0 1 0 0  <br>2: 0 1 0 0 0<br>3: 0 0 0 0 0<br>4: 0 0 0 0 0<br>``` |
| `adj[1][3] = 1; adj[3][1] = 1;` | **Add edge 1-3**: <br>```<br>   0 1 2 3 4<br>0: 0 0 0 0 0<br>1: 0 0 1 1 0  <br>2: 0 1 0 0 0<br>3: 0 1 0 0 0<br>4: 0 0 0 0 0<br>``` |
| `adj[2][4] = 1; adj[4][2] = 1;` | **Add edge 2-4**: <br>```<br>   0 1 2 3 4<br>0: 0 0 0 0 0<br>1: 0 0 1 1 0  <br>2: 0 1 0 0 1<br>3: 0 1 0 0 0<br>4: 0 0 1 0 0<br>``` |
| `adj[3][4] = 1; adj[4][3] = 1;` | **Add edge 3-4**: <br>```<br>   0 1 2 3 4<br>0: 0 0 0 0 0<br>1: 0 0 1 1 0  <br>2: 0 1 0 0 1<br>3: 0 1 0 0 1<br>4: 0 0 1 1 0<br>``` |
| **Final Output**:<br>`   1 2 3 4`<br>`1: 0 1 1 0`<br>`2: 1 0 0 1`<br>`3: 1 0 0 1`<br>`4: 0 1 1 0` | **Final matrix (only nodes 1-4)**: <br>• Row 1: Node 1 → connected to 2, 3<br>• Row 2: Node 2 → connected to 1, 4<br>• Row 3: Node 3 → connected to 1, 4<br>• Row 4: Node 4 → connected to 2, 3 |

## Graph Visualization:

```
    1
   / \
  2   3
   \ /
    4
```

The matrix perfectly represents this diamond-shaped graph where:
- Node 1 connects to 2 and 3
- Node 2 connects to 1 and 4  
- Node 3 connects to 1 and 4
- Node 4 connects to 2 and 3

The `n + 1` pattern gives us clean 1-based indexing while the underlying C++ array handles the 0-based indexing automatically!
