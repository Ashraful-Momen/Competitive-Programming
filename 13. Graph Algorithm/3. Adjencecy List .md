Perfect 🚀 Let’s go step by step and cover **Graph Input & Output in C++** with examples.
In competitive programming, graphs are usually represented in **3 common ways**:

1. **Adjacency Matrix**
2. **Adjacency List**
3. **Edge List**

I’ll show you all three with input/output examples 👇

---

# 📌 Example Graph

We’ll use this undirected graph with **5 nodes and 6 edges**:

```
5 6
1 2
1 3
2 4
3 4
4 5
2 5
```

* `5 6` → 5 nodes, 6 edges
* Each line → an edge `u v` between `u` and `v`.

---

# 1️⃣ **Adjacency Matrix**

👉 Uses a 2D array `adj[n+1][n+1]`.

* Best for dense graphs.
* Memory heavy (O(n²)).

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, m; // n = number of nodes, m = number of edges
    cin >> n >> m;

    vector<vector<int>> adj(n + 1, vector<int>(n + 1, 0));

    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        adj[u][v] = 1;
        adj[v][u] = 1; // remove this line if graph is directed
    }

    // Print adjacency matrix
    cout << "Adjacency Matrix:\n";
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cout << adj[i][j] << " ";
        }
        cout << "\n";
    }
}
```

✅ Output:

```
Adjacency Matrix:
0 1 1 0 0 
1 0 0 1 1 
1 0 0 1 0 
0 1 1 0 1 
0 1 0 1 0 
```

---

# 2️⃣ **Adjacency List**

👉 Stores graph in `vector<int> adj[n+1]`.

* Best for sparse graphs.
* Efficient memory usage.

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;

    vector<vector<int>> adj(n + 1);

    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u); // remove for directed graph
    }

    // Print adjacency list
    cout << "Adjacency List:\n";
    for (int i = 1; i <= n; i++) {
        cout << i << " -> ";
        for (int v : adj[i]) {
            cout << v << " ";
        }
        cout << "\n";
    }
}
```

✅ Output:

```
Adjacency List:
1 -> 2 3 
2 -> 1 4 5 
3 -> 1 4 
4 -> 2 3 5 
5 -> 4 2 
```

---

# 3️⃣ **Edge List**

👉 Stores graph as a list of edges `(u, v)`.

* Useful for Kruskal’s MST, sorting edges.

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;

    vector<pair<int, int>> edges;

    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        edges.push_back({u, v});
    }

    // Print edge list
    cout << "Edge List:\n";
    for (auto e : edges) {
        cout << e.first << " - " << e.second << "\n";
    }
}
```

✅ Output:

```
Edge List:
1 - 2
1 - 3
2 - 4
3 - 4
4 - 5
2 - 5
```

---

# 📌 Summary

* **Adjacency Matrix** → Easy but memory heavy (O(n²)).
* **Adjacency List** → Most used in CP (O(n + m)).
* **Edge List** → Best for Kruskal’s MST & sorting edges.

---

👉 Do you want me to also show you how to **take input for a weighted graph** (with edge weights) in all 3 forms?
