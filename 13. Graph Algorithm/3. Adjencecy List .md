Perfect ğŸš€ Letâ€™s go step by step and cover **Graph Input & Output in C++** with examples.
In competitive programming, graphs are usually represented in **3 common ways**:

1. **Adjacency Matrix**
2. **Adjacency List**
3. **Edge List**

Iâ€™ll show you all three with input/output examples ğŸ‘‡

---

# ğŸ“Œ Example Graph

Weâ€™ll use this undirected graph with **5 nodes and 6 edges**:

```
5 6
1 2
1 3
2 4
3 4
4 5
2 5
```

* `5 6` â†’ 5 nodes, 6 edges
* Each line â†’ an edge `u v` between `u` and `v`.

---

# 1ï¸âƒ£ **Adjacency Matrix**

ğŸ‘‰ Uses a 2D array `adj[n+1][n+1]`.

* Best for dense graphs.
* Memory heavy (O(nÂ²)).

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, m; // n = number of nodes, m = number of edges
    cin >> n >> m;

    vector<vector<int>> adj(n + 1, vector<int>(n + 1, 0));

    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        adj[u][v] = 1;
        adj[v][u] = 1; // remove this line if graph is directed
    }

    // Print adjacency matrix
    cout << "Adjacency Matrix:\n";
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cout << adj[i][j] << " ";
        }
        cout << "\n";
    }
}
```

âœ… Output:

```
Adjacency Matrix:
0 1 1 0 0 
1 0 0 1 1 
1 0 0 1 0 
0 1 1 0 1 
0 1 0 1 0 
```

---

# 2ï¸âƒ£ **Adjacency List**

ğŸ‘‰ Stores graph in `vector<int> adj[n+1]`.

* Best for sparse graphs.
* Efficient memory usage.

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;

    vector<vector<int>> adj(n + 1);

    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u); // remove for directed graph
    }

    // Print adjacency list
    cout << "Adjacency List:\n";
    for (int i = 1; i <= n; i++) {
        cout << i << " -> ";
        for (int v : adj[i]) {
            cout << v << " ";
        }
        cout << "\n";
    }
}
```

âœ… Output:

```
Adjacency List:
1 -> 2 3 
2 -> 1 4 5 
3 -> 1 4 
4 -> 2 3 5 
5 -> 4 2 
```

---

# 3ï¸âƒ£ **Edge List**

ğŸ‘‰ Stores graph as a list of edges `(u, v)`.

* Useful for Kruskalâ€™s MST, sorting edges.

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;

    vector<pair<int, int>> edges;

    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        edges.push_back({u, v});
    }

    // Print edge list
    cout << "Edge List:\n";
    for (auto e : edges) {
        cout << e.first << " - " << e.second << "\n";
    }
}
```

âœ… Output:

```
Edge List:
1 - 2
1 - 3
2 - 4
3 - 4
4 - 5
2 - 5
```

---

# ğŸ“Œ Summary

* **Adjacency Matrix** â†’ Easy but memory heavy (O(nÂ²)).
* **Adjacency List** â†’ Most used in CP (O(n + m)).
* **Edge List** â†’ Best for Kruskalâ€™s MST & sorting edges.

---

ğŸ‘‰ Do you want me to also show you how to **take input for a weighted graph** (with edge weights) in all 3 forms?
