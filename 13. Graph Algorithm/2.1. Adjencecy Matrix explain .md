I'll show you how to create an adjacency matrix using arrays without `memset`, and explain each step clearly.

## Method 1: Using Manual Initialization (No memset)

```cpp
#include <iostream>
using namespace std;

int main() {
    int n = 5; // Number of nodes
    int m = 6; // Number of edges
    
    // Step 1: Create adjacency matrix
    int adj[n + 1][n + 1];
    
    // Step 2: Manual initialization to 0
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= n; j++) {
            adj[i][j] = 0;
        }
    }
    
    // Step 3: Add edges (undirected graph)
    int edges[6][2] = {{1,2}, {1,3}, {2,4}, {3,4}, {4,5}, {2,5}};
    
    for (int i = 0; i < m; i++) {
        int u = edges[i][0];
        int v = edges[i][1];
        adj[u][v] = 1;
        adj[v][u] = 1;
    }
    
    // Step 4: Print the matrix
    cout << "Adjacency Matrix:" << endl;
    cout << "   ";
    for (int i = 1; i <= n; i++) {
        cout << i << " ";
    }
    cout << endl;
    
    for (int i = 1; i <= n; i++) {
        cout << i << ": ";
        for (int j = 1; j <= n; j++) {
            cout << adj[i][j] << " ";
        }
        cout << endl;
    }
    
    return 0;
}
```

## Method 2: Using Array Initialization Syntax

```cpp
#include <iostream>
using namespace std;

int main() {
    int n = 5; // Number of nodes
    int m = 6; // Number of edges
    
    // Step 1: Create and initialize adjacency matrix to 0
    int adj[n + 1][n + 1] = {0}; // This initializes all elements to 0
    
    // Step 2: Add edges
    int edges[6][2] = {{1,2}, {1,3}, {2,4}, {3,4}, {4,5}, {2,5}};
    
    for (int i = 0; i < m; i++) {
        int u = edges[i][0];
        int v = edges[i][1];
        adj[u][v] = 1;
        adj[v][u] = 1;
    }
    
    // Step 3: Print the matrix
    cout << "Adjacency Matrix:" << endl;
    cout << "   ";
    for (int i = 1; i <= n; i++) {
        cout << i << " ";
    }
    cout << endl;
    
    for (int i = 1; i <= n; i++) {
        cout << i << ": ";
        for (int j = 1; j <= n; j++) {
            cout << adj[i][j] << " ";
        }
        cout << endl;
    }
    
    return 0;
}
```

## Output for Both Methods

```
Adjacency Matrix:
   1 2 3 4 5 
1: 0 1 1 0 0 
2: 1 0 0 1 1 
3: 1 0 0 1 0 
4: 0 1 1 0 1 
5: 0 1 0 1 0 
```

## Step-by-Step Explanation

| Code Step | Explanation |
|-----------|-------------|
| `int n = 5;` | We have 5 nodes numbered 1 through 5 |
| `int adj[n + 1][n + 1];` | Create 2D array with dimensions 6×6 (indices 0-5) |
| **Initialization**:<br>`for (int i = 0; i <= n; i++)`<br>`for (int j = 0; j <= n; j++)`<br>`adj[i][j] = 0;` | Set all matrix elements to 0 (no edges) |
| **Add edges**:<br>`adj[u][v] = 1;`<br>`adj[v][u] = 1;` | For each edge (u,v), mark both directions as 1<br>This creates an undirected graph |
| **Print headers**:<br>`cout << " ";`<br>`for (int i = 1; i <= n; i++)` | Print column numbers (1 through 5) |
| **Print matrix**:<br>`for (int i = 1; i <= n; i++)`<br>`for (int j = 1; j <= n; j++)` | Print only the relevant part (rows/cols 1-5)<br>Ignore index 0 |

## Graph Visualization

```
    1
   / \
  2   3
 / \ / \
5   4
 \ /
  (completed square)
```

The matrix shows:
- **Node 1**: Connected to 2, 3
- **Node 2**: Connected to 1, 4, 5  
- **Node 3**: Connected to 1, 4
- **Node 4**: Connected to 2, 3, 5
- **Node 5**: Connected to 2, 4

## Key Points

1. **No memset needed**: We can initialize arrays manually or use `= {0}` syntax
2. **1-based indexing**: We use `n + 1` to make nodes 1 through n accessible
3. **Memory efficient**: For small graphs (n ≤ 1000), this is very efficient
4. **Fast lookups**: O(1) time to check if an edge exists
5. **Symmetric**: For undirected graphs, the matrix is symmetric around the diagonal

## For Larger Graphs

For graphs with more than 1000 nodes, consider using:
- **Adjacency lists** (more memory efficient for sparse graphs)
- **Dynamic memory allocation** (but be careful with memory management)

This array-based approach is perfect for competitive programming and small to medium-sized graphs!
