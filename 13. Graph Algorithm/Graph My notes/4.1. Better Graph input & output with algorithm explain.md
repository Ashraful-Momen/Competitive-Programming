Nice — below is a complete, step-by-step algorithm and a fully explained C++ implementation that uses **`vector<vector<int>>` (adjacency list)** for graph input and output. I’ll also explain every loop and why its control variable is what it is.

# Algorithm (step-by-step)

1. Read `n` (number of nodes) and `m` (number of edges) from input.
2. Create an adjacency list `adj` of size `n+1` (use `n` if 0-indexed).
3. Repeat `m` times: read an edge `(u, v)` and add `v` to `adj[u]`.

   * If the graph is **undirected**, also add `u` to `adj[v]`.
4. Print the adjacency list: for each node `u` from `1` to `n`, print `u:` followed by its neighbors (the contents of `adj[u]`).
5. (Optional) Validate inputs, sort neighbor lists, or convert to adjacency matrix if needed.

---

# C++ code (ready to compile) — with inline comments

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false); // speed up IO
    cin.tie(nullptr);

    int n, m;
    cin >> n >> m;                   // 1) read number of nodes (n) and edges (m)

    vector<vector<int>> adj(n + 1);  // 2) adjacency list, 1-indexed: adj[1]..adj[n]
                                     // use vector<vector<int>> adj(n); for 0-indexed nodes

    // 3) Read edges (repeat exactly m times because each input line describes one edge)
    for (int i = 0; i < m; ++i) {
        int u, v;
        cin >> u >> v;               // read the endpoints of the i-th edge
        // optional input validation could be: if(u<1||u>n||v<1||v>n) handle_error();

        adj[u].push_back(v);         // add v to u's neighbor list
        adj[v].push_back(u);         // add u to v's neighbor list (comment out for directed graph)
    }

    // 4) Output adjacency list
    for (int u = 1; u <= n; ++u) {   // iterate nodes 1..n (outer loop dependent on number of nodes)
        cout << u << ":";           // print node label
        for (int v : adj[u]) {      // inner loop iterates over neighbors of u (dependent on degree of u)
            cout << " " << v;       // print each neighbor
        }
        cout << "\n";
    }

    return 0;
}
```

---

# Line-by-line / block explanation

### Top-of-file & IO setup

* `#include <bits/stdc++.h>` — convenience header that includes most STL headers (GCC/Clang).
* `using namespace std;` — avoids `std::` prefix.
* `ios::sync_with_stdio(false); cin.tie(nullptr);` — faster cin/cout (recommended for competitive programming / file redirection).

### Reading `n` and `m`

* `int n, m; cin >> n >> m;`

  * These two integers control the size of the graph and how many edge lines follow. Everything else (loops, allocations) depends on these values.

### Building adjacency list

* `vector<vector<int>> adj(n + 1);`

  * Allocates `n+1` inner vectors so you can index nodes `1..n` directly. `adj[u]` will be the neighbor list for node `u`.
  * Memory usage: roughly `O(n + m)` (sum of lengths of all neighbor lists is `2*m` for undirected graphs).

* `for (int i = 0; i < m; ++i) { ... }`

  * **Why loop over `m`?** Because the input provides exactly `m` edges; each iteration reads one edge and inserts it into adjacency lists. `i` is just a counter — we don't use `i` itself to index the graph, it's controlling how many inputs are read.

* Inside the loop:

  * `cin >> u >> v;` reads the endpoints.
  * `adj[u].push_back(v);` adds `v` to `u`'s neighbor list.
  * `adj[v].push_back(u);` adds `u` to `v`'s neighbor list (for undirected). For a **directed** graph, skip this line.

### Output adjacency list

* `for (int u = 1; u <= n; ++u) { ... }`

  * **Why loop over `u = 1..n`?** Because you want to print the adjacency list for **every node** in the graph — the outer loop is node-indexed. The number of iterations equals the number of nodes `n`.
* `for (int v : adj[u]) { ... }`

  * **Why iterate over `adj[u]`?** Each `adj[u]` contains exactly the neighbors of node `u`. The inner loop depends on `deg(u)` (the degree of node `u`) — so it iterates as many times as that node has neighbors.
  * This produces output lines like `u: v1 v2 v3` where `v1..vk` are neighbors.

---

# Why the loops depend on those variables (summary)

* **Edge input loop uses `m`**: input contains `m` edges; reading exactly `m` lines is correct. Each edge is processed once → O(m).
* **Outer output loop uses `n`**: you must list entries for all `n` nodes (even nodes with zero neighbors), so iterate `n` times → O(n).
* **Inner output loop uses `deg(u)`**: to print the neighbors of node `u` you must iterate over `adj[u]`, whose length equals the degree of `u`. Summed over all nodes, inner iterations = sum(deg(u)) = 2\*m (undirected) or m (directed).

So overall time complexity for building + printing the list is **O(n + m)**.

---

# Sample `input.txt` and expected `output.txt`

`input.txt`

```
4 4
1 2
1 3
2 4
3 4
```

Running:

```bash
g++ graph_io.cpp -o graph_io
./graph_io < input.txt > output.txt
```

`output.txt`

```
1: 2 3
2: 1 4
3: 1 4
4: 2 3
```

(Neighbors may appear in the insertion order. If you want them sorted, call `sort(adj[u].begin(), adj[u].end());` for each `u` before printing.)

---

# Variants & notes

* **Directed graph**: remove `adj[v].push_back(u);`. Then sum of degrees = `m`.
* **0-indexed nodes**: use `vector<vector<int>> adj(n);` and read nodes in `0..n-1`. Adjust loops accordingly.
* **Large graphs**: reserve space if you know degrees ahead: `adj[u].reserve(k)` to avoid reallocations.
* **Adjacency matrix**: use `vector<vector<int>> matrix(n+1, vector<int>(n+1, 0));` if you need O(1) existence checks but expect O(n^2) memory.

---

If you want, I can:

* provide a version that also prints the adjacency **matrix**,
* add input validation and sorting, or
* show BFS/DFS traversals with the same adjacency list and explain their loops (which depend on queue/stack and degrees).

Which of those next?
