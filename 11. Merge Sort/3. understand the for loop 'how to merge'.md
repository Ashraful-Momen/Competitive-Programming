Perfect! Let's take a **concrete example**:

### Given:
```cpp
arr = [4, 3, 2, 1]
```
We want to sort it using merge sort. Eventually, we reach the final `merge()` call where both halves are sorted and ready to be merged.

But first, let’s assume we’re at the **last step** of merge sort:

- Left half: `[3, 4]` → sorted
- Right half: `[1, 2]` → sorted

So before the final merge, after recursive calls, the array looks like this:

```
Index:   0   1   2   3
       [ 3 , 4 , 1 , 2 ]
         ↑   ↑   ↑   ↑
       low  mid  mid+1 high
        ↓         ↓
     left half   right half
```

Now we call:
```cpp
merge(arr, 0, 1, 3);
```
- `low = 0`
- `mid = 1`
- `high = 3`

Our goal: **merge `arr[0..1]` and `arr[2..3]`** into one sorted segment → `[1,2,3,4]`

---

## 🔁 Step-by-step: Inside `merge()` function

```cpp
int n = high - low + 1;  // n = 3 - 0 + 1 = 4
int temp[n];             // temp[4] → temporary array
int left = low;          // left = 0
int right = mid + 1;     // right = 2
int index = 0;           // index in temp
```

### 🔄 While both halves have elements:
```cpp
while (left <= mid && right <= high)
```

| Step | Compare | Action | temp | left | right | index |
|------|--------|--------|------|------|-------|-------|
| 1 | `arr[0]=3` vs `arr[2]=1` → 3 > 1 | Pick `1` | `[1]` | 0 | 3 | 1 |
| 2 | `arr[0]=3` vs `arr[3]=2` → 3 > 2 | Pick `2` | `[1,2]` | 0 | 4 (out) | 2 |
| 3 | Now `right=4 > high=3` → exit loop | — | — | — | — | — |

Now copy leftovers from **left half**:
```cpp
while (left <= mid) → left=0, mid=1 → run twice
```
- `temp[2] = arr[0] = 3` → `index=3`, `left=1`
- `temp[3] = arr[1] = 4` → `index=4`, `left=2`

✅ Final `temp = [1, 2, 3, 4]`

```
temp: [ 1 , 2 , 3 , 4 ]
       0   1   2   3
```

---

## 🔍 Now: The `for` loop that copies back

```cpp
for (int i = low; i <= high; i++) {
    arr[i] = temp[i - low];
}
```

Let’s break it down.

We are looping over the **original array indices** from `low` to `high`, which is `i = 0` to `3`.

And for each `i`, we set:
```cpp
arr[i] = temp[i - low];
```
Since `low = 0`, this becomes:
```cpp
arr[i] = temp[i - 0] = temp[i]
```

So:

| `i` | `i - low` | `temp[i - low]` | `arr[i] = ?` | Result |
|-----|-----------|------------------|---------------|--------|
| 0   | 0 - 0 = 0 | `temp[0] = 1`    | `arr[0] = 1`  | ✅ |
| 1   | 1 - 0 = 1 | `temp[1] = 2`    | `arr[1] = 2`  | ✅ |
| 2   | 2 - 0 = 2 | `temp[2] = 3`    | `arr[2] = 3`  | ✅ |
| 3   | 3 - 0 = 3 | `temp[3] = 4`    | `arr[3] = 4`  | ✅ |

🎯 After the loop:
```
arr = [1, 2, 3, 4]
```

🎉 The array is now sorted!

---

## 🖼️ ASCII Diagram: Index Mapping

```
Original array indices:     0    1    2    3
                           ↓    ↓    ↓    ↓
We want to write here → [ ???, ???, ???, ??? ]

From temp:              [  1 ,  2 ,  3 ,  4  ]
                          ↑    ↑    ↑    ↑
                         [0]  [1]  [2]  [3]

Mapping: i → i - low
         ↓
Since low = 0:
    arr[0] ← temp[0]
    arr[1] ← temp[1]
    arr[2] ← temp[2]
    arr[3] ← temp[3]
```

So it's a **direct copy** when `low = 0`.

---

## 🧠 What if `low` was not 0?

Let’s suppose we were merging a subarray starting at `low = 2`.

Example:
```cpp
arr = [99, 99, 3, 4, 1, 2]   // merge from index 2 to 5
              ↑           ↑
            low=2       high=5
```

After merge, `temp = [1,2,3,4]`

Now run:
```cpp
for (int i = 2; i <= 5; i++) {
    arr[i] = temp[i - 2];
}
```

| `i` | `i - 2` | `temp[i-2]` | `arr[i]` |
|-----|--------|-------------|----------|
| 2   | 0      | 1           | `arr[2] = 1` |
| 3   | 1      | 2           | `arr[3] = 2` |
| 4   | 2      | 3           | `arr[4] = 3` |
| 5   | 3      | 4           | `arr[5] = 4` |

✅ Result:
```
arr = [99, 99, 1, 2, 3, 4]
```

✔️ The mapping `i - low` works **regardless of where the segment starts**.

---

## ✅ Summary: Why `i - low`?

| Expression | Purpose |
|----------|--------|
| `i` | Loops through original array positions (`low` to `high`) |
| `i - low` | Converts global index to **local index in `temp`** |
| `temp[i - low]` | Gets the correct value from the merged result |
| `arr[i] = ...` | Puts it back in the right place |

🔁 This ensures:
- We don’t access `temp` out of bounds
- We correctly align the merged data with the original array segment

---

## 🎯 Final Answer to Your Question

> You said:  
> *"Suppose array = [4,3,2,1], and after merge, `temp = [1,2,3,4]`. Now explain the for loop."*

Even though the original array starts as `[4,3,2,1]`, by the time we call `merge()`, the **left and right halves have already been sorted recursively**, so we’re not merging `[4,3]` and `[2,1]` directly — we first sort them to `[3,4]` and `[1,2]`, then merge.

At the final `merge()` call:
- `temp = [1,2,3,4]`
- We copy it back using:
  ```cpp
  for (int i = low; i <= high; i++)
      arr[i] = temp[i - low];
  ```

Because `low = 0`, this becomes:
```cpp
arr[0] = temp[0] = 1
arr[1] = temp[1] = 2
arr[2] = temp[2] = 3
arr[3] = temp[3] = 4
```

🔚 Final result: `[1, 2, 3, 4]` — fully sorted!

---

Let me know if you'd like to see how it works with `low = 1` or a bigger array!
