Perfect! Let's take a **concrete example**:

### Given:
```cpp
arr = [4, 3, 2, 1]
```
We want to sort it using merge sort. Eventually, we reach the final `merge()` call where both halves are sorted and ready to be merged.

But first, letâ€™s assume weâ€™re at the **last step** of merge sort:

- Left half: `[3, 4]` â†’ sorted
- Right half: `[1, 2]` â†’ sorted

So before the final merge, after recursive calls, the array looks like this:

```
Index:   0   1   2   3
       [ 3 , 4 , 1 , 2 ]
         â†‘   â†‘   â†‘   â†‘
       low  mid  mid+1 high
        â†“         â†“
     left half   right half
```

Now we call:
```cpp
merge(arr, 0, 1, 3);
```
- `low = 0`
- `mid = 1`
- `high = 3`

Our goal: **merge `arr[0..1]` and `arr[2..3]`** into one sorted segment â†’ `[1,2,3,4]`

---

## ğŸ” Step-by-step: Inside `merge()` function

```cpp
int n = high - low + 1;  // n = 3 - 0 + 1 = 4
int temp[n];             // temp[4] â†’ temporary array
int left = low;          // left = 0
int right = mid + 1;     // right = 2
int index = 0;           // index in temp
```

### ğŸ”„ While both halves have elements:
```cpp
while (left <= mid && right <= high)
```

| Step | Compare | Action | temp | left | right | index |
|------|--------|--------|------|------|-------|-------|
| 1 | `arr[0]=3` vs `arr[2]=1` â†’ 3 > 1 | Pick `1` | `[1]` | 0 | 3 | 1 |
| 2 | `arr[0]=3` vs `arr[3]=2` â†’ 3 > 2 | Pick `2` | `[1,2]` | 0 | 4 (out) | 2 |
| 3 | Now `right=4 > high=3` â†’ exit loop | â€” | â€” | â€” | â€” | â€” |

Now copy leftovers from **left half**:
```cpp
while (left <= mid) â†’ left=0, mid=1 â†’ run twice
```
- `temp[2] = arr[0] = 3` â†’ `index=3`, `left=1`
- `temp[3] = arr[1] = 4` â†’ `index=4`, `left=2`

âœ… Final `temp = [1, 2, 3, 4]`

```
temp: [ 1 , 2 , 3 , 4 ]
       0   1   2   3
```

---

## ğŸ” Now: The `for` loop that copies back

```cpp
for (int i = low; i <= high; i++) {
    arr[i] = temp[i - low];
}
```

Letâ€™s break it down.

We are looping over the **original array indices** from `low` to `high`, which is `i = 0` to `3`.

And for each `i`, we set:
```cpp
arr[i] = temp[i - low];
```
Since `low = 0`, this becomes:
```cpp
arr[i] = temp[i - 0] = temp[i]
```

So:

| `i` | `i - low` | `temp[i - low]` | `arr[i] = ?` | Result |
|-----|-----------|------------------|---------------|--------|
| 0   | 0 - 0 = 0 | `temp[0] = 1`    | `arr[0] = 1`  | âœ… |
| 1   | 1 - 0 = 1 | `temp[1] = 2`    | `arr[1] = 2`  | âœ… |
| 2   | 2 - 0 = 2 | `temp[2] = 3`    | `arr[2] = 3`  | âœ… |
| 3   | 3 - 0 = 3 | `temp[3] = 4`    | `arr[3] = 4`  | âœ… |

ğŸ¯ After the loop:
```
arr = [1, 2, 3, 4]
```

ğŸ‰ The array is now sorted!

---

## ğŸ–¼ï¸ ASCII Diagram: Index Mapping

```
Original array indices:     0    1    2    3
                           â†“    â†“    â†“    â†“
We want to write here â†’ [ ???, ???, ???, ??? ]

From temp:              [  1 ,  2 ,  3 ,  4  ]
                          â†‘    â†‘    â†‘    â†‘
                         [0]  [1]  [2]  [3]

Mapping: i â†’ i - low
         â†“
Since low = 0:
    arr[0] â† temp[0]
    arr[1] â† temp[1]
    arr[2] â† temp[2]
    arr[3] â† temp[3]
```

So it's a **direct copy** when `low = 0`.

---

## ğŸ§  What if `low` was not 0?

Letâ€™s suppose we were merging a subarray starting at `low = 2`.

Example:
```cpp
arr = [99, 99, 3, 4, 1, 2]   // merge from index 2 to 5
              â†‘           â†‘
            low=2       high=5
```

After merge, `temp = [1,2,3,4]`

Now run:
```cpp
for (int i = 2; i <= 5; i++) {
    arr[i] = temp[i - 2];
}
```

| `i` | `i - 2` | `temp[i-2]` | `arr[i]` |
|-----|--------|-------------|----------|
| 2   | 0      | 1           | `arr[2] = 1` |
| 3   | 1      | 2           | `arr[3] = 2` |
| 4   | 2      | 3           | `arr[4] = 3` |
| 5   | 3      | 4           | `arr[5] = 4` |

âœ… Result:
```
arr = [99, 99, 1, 2, 3, 4]
```

âœ”ï¸ The mapping `i - low` works **regardless of where the segment starts**.

---

## âœ… Summary: Why `i - low`?

| Expression | Purpose |
|----------|--------|
| `i` | Loops through original array positions (`low` to `high`) |
| `i - low` | Converts global index to **local index in `temp`** |
| `temp[i - low]` | Gets the correct value from the merged result |
| `arr[i] = ...` | Puts it back in the right place |

ğŸ” This ensures:
- We donâ€™t access `temp` out of bounds
- We correctly align the merged data with the original array segment

---

## ğŸ¯ Final Answer to Your Question

> You said:  
> *"Suppose array = [4,3,2,1], and after merge, `temp = [1,2,3,4]`. Now explain the for loop."*

Even though the original array starts as `[4,3,2,1]`, by the time we call `merge()`, the **left and right halves have already been sorted recursively**, so weâ€™re not merging `[4,3]` and `[2,1]` directly â€” we first sort them to `[3,4]` and `[1,2]`, then merge.

At the final `merge()` call:
- `temp = [1,2,3,4]`
- We copy it back using:
  ```cpp
  for (int i = low; i <= high; i++)
      arr[i] = temp[i - low];
  ```

Because `low = 0`, this becomes:
```cpp
arr[0] = temp[0] = 1
arr[1] = temp[1] = 2
arr[2] = temp[2] = 3
arr[3] = temp[3] = 4
```

ğŸ”š Final result: `[1, 2, 3, 4]` â€” fully sorted!

---

Let me know if you'd like to see how it works with `low = 1` or a bigger array!
