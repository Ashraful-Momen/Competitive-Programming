Here's a **line-by-line explanation** of the **Merge Sort algorithm** in C++, including an **ASCII diagram** to help visualize how the `merge` and `mergeSort` functions work.

---

### 🔧 Function: `merge(vector<int>& arr, int low, int mid, int high)`

This function **merges two sorted subarrays**:
- Left: `arr[low .. mid]`
- Right: `arr[mid+1 .. high]`

We’ll go line by line.

```cpp
void merge(vector<int>& arr, int low, int mid, int high) {
```
> **Purpose**: Merges two sorted halves of the array into one sorted segment.  
> **Input**: A reference to the array and indices defining the two halves.

---

```cpp
    vector<int> temp;              // temporary buffer to build the merged result
```
> 📌 Creates a temporary vector to store the merged elements in sorted order.  
> 🔁 We can't modify `arr` directly during merging, so we build the result here first.

```
Example: temp = [ ]
```

---

```cpp
    int left  = low;               // pointer into the left half
    int right = mid + 1;           // pointer into the right half
```
> 🚩 Initializes two pointers:
> - `left` → starts at beginning of left half (`low`)
> - `right` → starts at beginning of right half (`mid+1`)

```
Array: [ ... | 1 3 5 | 2 4 6 | ... ]
               ↑       ↑
             left    right
            (low)   (mid+1)
```

---

```cpp
    while (left <= mid && right <= high) {
        if (arr[left] <= arr[right]) {  // <= keeps the sort stable
            temp.push_back(arr[left]);
            left++;
        } else {
            temp.push_back(arr[right]);
            right++;
        }
    }
```
> 🔁 While both halves still have elements:
> - Compare `arr[left]` and `arr[right]`
> - Pick the smaller one and add it to `temp`
> - Move that pointer forward

> ✅ Using `<=` makes the sort **stable** (equal elements keep their relative order).

```
Step-by-step example:

Left: [1, 3, 5]    Right: [2, 4, 6]

Compare 1 vs 2 → 1 < 2 → add 1 → left++
Compare 3 vs 2 → 2 < 3 → add 2 → right++
Compare 3 vs 4 → 3 < 4 → add 3 → left++
Compare 5 vs 4 → 4 < 5 → add 4 → right++
Compare 5 vs 6 → 5 < 6 → add 5 → left++

Now left > mid → exit loop

temp = [1, 2, 3, 4, 5]
```

---

```cpp
    while (left  <= mid)  { temp.push_back(arr[left]);  left++;  }
    while (right <= high) { temp.push_back(arr[right]); right++; }
```
> 📥 After the main loop, one half may still have leftover elements.  
> Only **one** of these loops runs — the one with remaining elements.

> Since each half was already sorted, we just append the rest.

```
Continuing example:
After loop, right = mid+3 (out of bounds), but left = mid+1? No — actually left > mid.

So only right has leftovers? No — in our case, right still has 6.

Wait — correction: after adding 5, left becomes mid+1 → left > mid → so left done.

But right points to 6 → still <= high → second loop runs:

→ Add 6 → right++

Final temp = [1, 2, 3, 4, 5, 6]
```

---

```cpp
    for (int i = low; i <= high; i++) {
        arr[i] = temp[i - low];    // i-low maps [low..high] -> [0..temp.size()-1]
    }
```
> 💾 Copy the merged result from `temp` back into the original array `arr[low..high]`.

> `i - low` converts the global index `i` to the local index in `temp`.

```
Example: low = 3, then:
i = 3 → temp[0]
i = 4 → temp[1]
...
i = 8 → temp[5]

So arr[3..8] = temp[0..5]
```

✅ Now `arr[low..high]` is sorted!

---

### 🌀 Function: `mergeSort(vector<int>& arr, int low, int high)`

Recursive function that divides and conquers.

```cpp
void mergeSort(vector<int>& arr, int low, int high) {
```
> 🎯 Sorts the subarray `arr[low .. high]` using divide-and-conquer.

---

```cpp
    if (low >= high) return;                 // 1 element = already sorted
```
> 🛑 Base case: if `low >= high`, there's **0 or 1 element**, which is trivially sorted.

```
[5] → already sorted
```

---

```cpp
    int mid = (low + high) / 2;
```
> 🔪 Divide the array into two halves:
> - Left: `low` to `mid`
> - Right: `mid+1` to `high`

```
Array: [3, 1, 4, 1, 5, 9, 2, 6]
       ↑                         ↑
      low                       high
                ↓
              mid = (0+7)/2 = 3
```

---

```cpp
    mergeSort(arr, low, mid);                // sort left half
```
> 🔁 Recursively sort the **left half**: `arr[low..mid]`

```
Calls mergeSort(arr, 0, 3)
→ Then further splits until single elements
```

---

```cpp
    mergeSort(arr, mid + 1, high);           // sort right half
```
> 🔁 Recursively sort the **right half**: `arr[mid+1..high]`

```
Calls mergeSort(arr, 4, 7)
```

---

```cpp
    merge(arr, low, mid, high);              // merge the two halves
```
> 🤝 Now that both halves are sorted, merge them into one sorted segment.

```
After both recursive calls:
Left: [1, 1, 3, 4]  Right: [2, 5, 6, 9]

Call merge(arr, 0, 3, 7) → produces sorted [1,1,2,3,4,5,6,9]
```

---

### 🖼️ ASCII Visualization of Merge Sort

Let’s trace on a small array: `[3, 1, 4, 2]`

```
Initial: [3, 1, 4, 2]
         low=0      high=3
               ↓
             mid=1

Step 1: Split into [3,1] and [4,2]

mergeSort(arr, 0, 1)         mergeSort(arr, 2, 3)
       ↓                             ↓
[3] and [1]                    [4] and [2]
   ↓     ↓                        ↓     ↓
Both base cases reached → then merge:

merge([3],[1]) → [1,3]      merge([4],[2]) → [2,4]

Now back to top level:
Left = [1,3], Right = [2,4]

Call merge(arr, 0, 1, 3):

Compare:
1 vs 2 → add 1
3 vs 2 → add 2
3 vs 4 → add 3
Leftover: 4 → add 4

Final: [1, 2, 3, 4]
```

#### ASCII Tree of Recursion:

```
           [3,1,4,2]            // mergeSort(0,3)
           /        \
      [3,1]          [4,2]       // mergeSort(0,1) & (2,3)
      /    \         /    \
    [3]    [1]     [4]    [2]    // base cases
     ↓      ↓       ↓      ↓
    [3]    [1]     [4]    [2]
      \    /         \    /
     [1,3]         [2,4]         // after merge
         \          /
         [1,2,3,4]               // final merge
```

---

### ✅ Summary

| Line | Explanation |
|------|-------------|
| `vector<int> temp;` | Temporary storage for merged result |
| `left = low`, `right = mid+1` | Pointers to start of left and right halves |
| `while (both pointers valid)` | Compare and pick smaller element |
| `if (arr[left] <= arr[right])` | Stable: prefer left when equal |
| `push_back(...); pointer++` | Add element and advance pointer |
| Two final `while` loops | Copy remaining elements (only one runs) |
| Final `for` loop | Copy `temp` back to `arr[low..high]` |
| `mergeSort`: base case | Stop when 1 or 0 elements |
| `mid = (low+high)/2` | Split array into two |
| Recursive calls | Sort left and right halves |
| `merge(...)` | Combine two sorted halves |

---

### 📌 Time Complexity

- **Time**: O(n log n) — balanced divide, merge takes O(n)
- **Space**: O(n) — due to `temp` array
- **Stable**: Yes — because of `<=` comparison

---

Let me know if you'd like an animation-style ASCII step-through for a specific input!
