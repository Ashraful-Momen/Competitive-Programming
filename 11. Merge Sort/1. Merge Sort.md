Here's a **line-by-line explanation** of the **Merge Sort algorithm** in C++, including an **ASCII diagram** to help visualize how the `merge` and `mergeSort` functions work.

---

### ğŸ”§ Function: `merge(vector<int>& arr, int low, int mid, int high)`

This function **merges two sorted subarrays**:
- Left: `arr[low .. mid]`
- Right: `arr[mid+1 .. high]`

Weâ€™ll go line by line.

```cpp
void merge(vector<int>& arr, int low, int mid, int high) {
```
> **Purpose**: Merges two sorted halves of the array into one sorted segment.  
> **Input**: A reference to the array and indices defining the two halves.

---

```cpp
    vector<int> temp;              // temporary buffer to build the merged result
```
> ğŸ“Œ Creates a temporary vector to store the merged elements in sorted order.  
> ğŸ” We can't modify `arr` directly during merging, so we build the result here first.

```
Example: temp = [ ]
```

---

```cpp
    int left  = low;               // pointer into the left half
    int right = mid + 1;           // pointer into the right half
```
> ğŸš© Initializes two pointers:
> - `left` â†’ starts at beginning of left half (`low`)
> - `right` â†’ starts at beginning of right half (`mid+1`)

```
Array: [ ... | 1 3 5 | 2 4 6 | ... ]
               â†‘       â†‘
             left    right
            (low)   (mid+1)
```

---

```cpp
    while (left <= mid && right <= high) {
        if (arr[left] <= arr[right]) {  // <= keeps the sort stable
            temp.push_back(arr[left]);
            left++;
        } else {
            temp.push_back(arr[right]);
            right++;
        }
    }
```
> ğŸ” While both halves still have elements:
> - Compare `arr[left]` and `arr[right]`
> - Pick the smaller one and add it to `temp`
> - Move that pointer forward

> âœ… Using `<=` makes the sort **stable** (equal elements keep their relative order).

```
Step-by-step example:

Left: [1, 3, 5]    Right: [2, 4, 6]

Compare 1 vs 2 â†’ 1 < 2 â†’ add 1 â†’ left++
Compare 3 vs 2 â†’ 2 < 3 â†’ add 2 â†’ right++
Compare 3 vs 4 â†’ 3 < 4 â†’ add 3 â†’ left++
Compare 5 vs 4 â†’ 4 < 5 â†’ add 4 â†’ right++
Compare 5 vs 6 â†’ 5 < 6 â†’ add 5 â†’ left++

Now left > mid â†’ exit loop

temp = [1, 2, 3, 4, 5]
```

---

```cpp
    while (left  <= mid)  { temp.push_back(arr[left]);  left++;  }
    while (right <= high) { temp.push_back(arr[right]); right++; }
```
> ğŸ“¥ After the main loop, one half may still have leftover elements.  
> Only **one** of these loops runs â€” the one with remaining elements.

> Since each half was already sorted, we just append the rest.

```
Continuing example:
After loop, right = mid+3 (out of bounds), but left = mid+1? No â€” actually left > mid.

So only right has leftovers? No â€” in our case, right still has 6.

Wait â€” correction: after adding 5, left becomes mid+1 â†’ left > mid â†’ so left done.

But right points to 6 â†’ still <= high â†’ second loop runs:

â†’ Add 6 â†’ right++

Final temp = [1, 2, 3, 4, 5, 6]
```

---

```cpp
    for (int i = low; i <= high; i++) {
        arr[i] = temp[i - low];    // i-low maps [low..high] -> [0..temp.size()-1]
    }
```
> ğŸ’¾ Copy the merged result from `temp` back into the original array `arr[low..high]`.

> `i - low` converts the global index `i` to the local index in `temp`.

```
Example: low = 3, then:
i = 3 â†’ temp[0]
i = 4 â†’ temp[1]
...
i = 8 â†’ temp[5]

So arr[3..8] = temp[0..5]
```

âœ… Now `arr[low..high]` is sorted!

---

### ğŸŒ€ Function: `mergeSort(vector<int>& arr, int low, int high)`

Recursive function that divides and conquers.

```cpp
void mergeSort(vector<int>& arr, int low, int high) {
```
> ğŸ¯ Sorts the subarray `arr[low .. high]` using divide-and-conquer.

---

```cpp
    if (low >= high) return;                 // 1 element = already sorted
```
> ğŸ›‘ Base case: if `low >= high`, there's **0 or 1 element**, which is trivially sorted.

```
[5] â†’ already sorted
```

---

```cpp
    int mid = (low + high) / 2;
```
> ğŸ”ª Divide the array into two halves:
> - Left: `low` to `mid`
> - Right: `mid+1` to `high`

```
Array: [3, 1, 4, 1, 5, 9, 2, 6]
       â†‘                         â†‘
      low                       high
                â†“
              mid = (0+7)/2 = 3
```

---

```cpp
    mergeSort(arr, low, mid);                // sort left half
```
> ğŸ” Recursively sort the **left half**: `arr[low..mid]`

```
Calls mergeSort(arr, 0, 3)
â†’ Then further splits until single elements
```

---

```cpp
    mergeSort(arr, mid + 1, high);           // sort right half
```
> ğŸ” Recursively sort the **right half**: `arr[mid+1..high]`

```
Calls mergeSort(arr, 4, 7)
```

---

```cpp
    merge(arr, low, mid, high);              // merge the two halves
```
> ğŸ¤ Now that both halves are sorted, merge them into one sorted segment.

```
After both recursive calls:
Left: [1, 1, 3, 4]  Right: [2, 5, 6, 9]

Call merge(arr, 0, 3, 7) â†’ produces sorted [1,1,2,3,4,5,6,9]
```

---

### ğŸ–¼ï¸ ASCII Visualization of Merge Sort

Letâ€™s trace on a small array: `[3, 1, 4, 2]`

```
Initial: [3, 1, 4, 2]
         low=0      high=3
               â†“
             mid=1

Step 1: Split into [3,1] and [4,2]

mergeSort(arr, 0, 1)         mergeSort(arr, 2, 3)
       â†“                             â†“
[3] and [1]                    [4] and [2]
   â†“     â†“                        â†“     â†“
Both base cases reached â†’ then merge:

merge([3],[1]) â†’ [1,3]      merge([4],[2]) â†’ [2,4]

Now back to top level:
Left = [1,3], Right = [2,4]

Call merge(arr, 0, 1, 3):

Compare:
1 vs 2 â†’ add 1
3 vs 2 â†’ add 2
3 vs 4 â†’ add 3
Leftover: 4 â†’ add 4

Final: [1, 2, 3, 4]
```

#### ASCII Tree of Recursion:

```
           [3,1,4,2]            // mergeSort(0,3)
           /        \
      [3,1]          [4,2]       // mergeSort(0,1) & (2,3)
      /    \         /    \
    [3]    [1]     [4]    [2]    // base cases
     â†“      â†“       â†“      â†“
    [3]    [1]     [4]    [2]
      \    /         \    /
     [1,3]         [2,4]         // after merge
         \          /
         [1,2,3,4]               // final merge
```

---

### âœ… Summary

| Line | Explanation |
|------|-------------|
| `vector<int> temp;` | Temporary storage for merged result |
| `left = low`, `right = mid+1` | Pointers to start of left and right halves |
| `while (both pointers valid)` | Compare and pick smaller element |
| `if (arr[left] <= arr[right])` | Stable: prefer left when equal |
| `push_back(...); pointer++` | Add element and advance pointer |
| Two final `while` loops | Copy remaining elements (only one runs) |
| Final `for` loop | Copy `temp` back to `arr[low..high]` |
| `mergeSort`: base case | Stop when 1 or 0 elements |
| `mid = (low+high)/2` | Split array into two |
| Recursive calls | Sort left and right halves |
| `merge(...)` | Combine two sorted halves |

---

### ğŸ“Œ Time Complexity

- **Time**: O(n log n) â€” balanced divide, merge takes O(n)
- **Space**: O(n) â€” due to `temp` array
- **Stable**: Yes â€” because of `<=` comparison

---

Let me know if you'd like an animation-style ASCII step-through for a specific input!
