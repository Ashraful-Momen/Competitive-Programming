# Big O Notation - ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ ‡¶ó‡¶æ‡¶á‡¶°
## Time Complexity ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£

---

## Big O ‡¶ï‡¶ø?
**Big O Notation** ‡¶π‡¶≤ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ó‡¶æ‡¶£‡¶ø‡¶§‡¶ø‡¶ï ‡¶â‡¶™‡¶æ‡¶Ø‡¶º ‡¶Ø‡¶æ ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶¨‡ßÅ‡¶ù‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø ‡¶è‡¶ï‡¶ü‡¶ø algorithm ‡¶ï‡¶§‡¶ü‡¶æ ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶®‡ßá‡¶¨‡ßá input size ‡¶¨‡¶æ‡¶°‡¶º‡¶æ‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶∏‡¶æ‡¶•‡ßá‡•§

### ‡¶Æ‡ßÇ‡¶≤ ‡¶®‡¶ø‡¶Ø‡¶º‡¶Æ:
```
O(1) < O(log n) < O(n) < O(n log n) < O(n¬≤) < O(n¬≥) < O(2‚Åø) < O(n!)
‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‚Üê                                                    ‚Üí ‡¶ß‡ßÄ‡¶∞
```

---

## ‡¶¨‡¶ø‡¶≠‡¶ø‡¶®‡ßç‡¶® Time Complexity ‡¶è‡¶∞ ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£

### 1. O(1) - Constant Time (‡¶∏‡ßç‡¶•‡¶ø‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º)
```cpp
int getFirst(int arr[]) {
    return arr[0];  // ‡¶∏‡¶¨‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶è‡¶ï‡¶á ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶≤‡¶æ‡¶ó‡ßá
}
```

**ASCII Visualization:**
```
Input Size ‚Üí Time
n=10      ‚Üí ‚ñ†
n=100     ‚Üí ‚ñ†  
n=1000    ‚Üí ‚ñ†
n=10000   ‚Üí ‚ñ†
```
**‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ:** Input ‡¶Ø‡¶§ ‡¶¨‡¶°‡¶º‡¶á ‡¶π‡ßã‡¶ï, ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶è‡¶ï‡¶á ‡¶•‡¶æ‡¶ï‡ßá‡•§

---

### 2. O(n) - Linear Time (‡¶∞‡ßà‡¶ñ‡¶ø‡¶ï ‡¶∏‡¶Æ‡¶Ø‡¶º)
```cpp
// ‡¶è‡¶ï‡¶ü‡¶ø array ‡¶§‡ßá maximum value ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ
int findMax(int arr[], int n) {
    int max = arr[0];
    for(int i = 1; i < n; i++) {  // n-1 ‡¶¨‡¶æ‡¶∞ ‡¶ö‡¶≤‡¶¨‡ßá
        if(arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}
```

**ASCII Visualization:**
```
Input Size ‚Üí Time
n=10      ‚Üí ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†
n=20      ‚Üí ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†
n=30      ‚Üí ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†
```
**‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ:** Input ‡¶è‡¶∞ size ‡¶¶‡ßç‡¶¨‡¶ø‡¶ó‡ßÅ‡¶£ ‡¶π‡¶≤‡ßá, time ‡¶ì ‡¶¶‡ßç‡¶¨‡¶ø‡¶ó‡ßÅ‡¶£ ‡¶π‡¶Ø‡¶º‡•§

---

### 3. O(n¬≤) - Quadratic Time (‡¶¨‡¶∞‡ßç‡¶ó‡ßÄ‡¶Ø‡¶º ‡¶∏‡¶Æ‡¶Ø‡¶º)
```cpp
// Bubble Sort Algorithm
void bubbleSort(int arr[], int n) {
    for(int i = 0; i < n; i++) {        // ‡¶¨‡¶æ‡¶á‡¶∞‡ßá‡¶∞ loop: n ‡¶¨‡¶æ‡¶∞
        for(int j = 0; j < n-i-1; j++) { // ‡¶≠‡¶ø‡¶§‡¶∞‡ßá‡¶∞ loop: (n-i-1) ‡¶¨‡¶æ‡¶∞
            if(arr[j] > arr[j+1]) {
                // swap
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}
```

**ASCII Visualization:**
```
n=3: ‚ñ†‚ñ†‚ñ†
     ‚ñ†‚ñ†‚ñ†    (3√ó3 = 9 operations)
     ‚ñ†‚ñ†‚ñ†

n=4: ‚ñ†‚ñ†‚ñ†‚ñ†
     ‚ñ†‚ñ†‚ñ†‚ñ†   (4√ó4 = 16 operations)  
     ‚ñ†‚ñ†‚ñ†‚ñ†
     ‚ñ†‚ñ†‚ñ†‚ñ†

n=5: ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†
     ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†  (5√ó5 = 25 operations)
     ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†
     ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†
     ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†
```
**‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ:** Input ‡¶è‡¶∞ size ‡¶¶‡ßç‡¶¨‡¶ø‡¶ó‡ßÅ‡¶£ ‡¶π‡¶≤‡ßá, time ‡¶ö‡¶æ‡¶∞‡¶ó‡ßÅ‡¶£ ‡¶π‡¶Ø‡¶º!

---

### 4. O(log n) - Logarithmic Time (‡¶≤‡¶ó‡¶æ‡¶∞‡¶ø‡¶¶‡¶Æ‡¶ø‡¶ï ‡¶∏‡¶Æ‡¶Ø‡¶º)
```cpp
// Binary Search Algorithm
int binarySearch(int arr[], int n, int target) {
    int left = 0, right = n - 1;
    
    while(left <= right) {
        int mid = left + (right - left) / 2;
        
        if(arr[mid] == target) {
            return mid;  // ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶ó‡ßá‡¶õ‡ßá!
        }
        else if(arr[mid] < target) {
            left = mid + 1;  // ‡¶°‡¶æ‡¶®‡¶¶‡¶ø‡¶ï‡ßá ‡¶ñ‡ßã‡¶Å‡¶ú‡ßã
        }
        else {
            right = mid - 1; // ‡¶¨‡¶æ‡¶Æ‡¶¶‡¶ø‡¶ï‡ßá ‡¶ñ‡ßã‡¶Å‡¶ú‡ßã
        }
    }
    return -1;  // ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø
}
```

**Binary Search ‡¶è‡¶∞ ‡¶ï‡¶æ‡¶ú ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®‡ßã:**
```
Array: [1, 3, 5, 7, 9, 11, 13, 15]
Target: 7

Step 1: [1, 3, 5, 7, 9, 11, 13, 15]
         ‚Üë           ‚Üë              ‚Üë
       left        mid            right
       mid = 9 > 7, so right = mid-1

Step 2: [1, 3, 5, 7]
         ‚Üë     ‚Üë   ‚Üë
       left  mid right  
       mid = 3 < 7, so left = mid+1

Step 3: [5, 7]
         ‚Üë  ‚Üë
       left=right=mid
       mid = 5 < 7, so left = mid+1

Step 4: [7]
         ‚Üë
    left=right=mid
    Found! arr[3] = 7
```

**ASCII Visualization:**
```
n=8   ‚Üí 3 steps  ‚ñ†‚ñ†‚ñ†
n=16  ‚Üí 4 steps  ‚ñ†‚ñ†‚ñ†‚ñ†
n=32  ‚Üí 5 steps  ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†
n=64  ‚Üí 6 steps  ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†
```

---

### 5. O(n log n) - Linearithmic Time
```cpp
// Merge Sort Algorithm ‡¶è‡¶∞ ‡¶∏‡¶∞‡¶≤‡ßÄ‡¶ï‡ßÉ‡¶§ version
void mergeSort(int arr[], int left, int right) {
    if(left < right) {
        int mid = left + (right - left) / 2;
        
        mergeSort(arr, left, mid);      // ‡¶¨‡¶æ‡¶Æ ‡¶Ö‡¶Ç‡¶∂ sort ‡¶ï‡¶∞
        mergeSort(arr, mid + 1, right); // ‡¶°‡¶æ‡¶® ‡¶Ö‡¶Ç‡¶∂ sort ‡¶ï‡¶∞
        merge(arr, left, mid, right);   // ‡¶¶‡ßÅ‡¶ü‡ßã ‡¶Ö‡¶Ç‡¶∂ ‡¶ú‡ßã‡¶°‡¶º‡¶æ ‡¶¶‡¶æ‡¶ì
    }
}
```

**ASCII Visualization (Tree Structure):**
```
                [8,3,1,4,7,6,2,5]
                     /    \
            [8,3,1,4]        [7,6,2,5]
             /    \            /    \
        [8,3]    [1,4]    [7,6]    [2,5]
         / \      / \      / \      / \
       [8] [3]  [1] [4]  [7] [6]  [2] [5]
```
**‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ:** log n ‡¶§‡¶æ level ‡¶Ü‡¶õ‡ßá, ‡¶™‡ßç‡¶∞‡¶§‡¶ø level ‡¶è n ‡¶ü‡¶æ operation‡•§

---

## For Loop Analysis ‡¶è‡¶∞ ‡¶®‡¶ø‡¶Ø‡¶º‡¶Æ

### 1. ‡¶è‡¶ï‡¶ï Loop = O(n)
```cpp
for(int i = 0; i < n; i++) {
    // O(1) operation
}
// Total: O(n)
```

### 2. Nested Loop = O(n¬≤)
```cpp
for(int i = 0; i < n; i++) {       // n ‡¶¨‡¶æ‡¶∞
    for(int j = 0; j < n; j++) {   // ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶¨‡¶æ‡¶∞ n ‡¶¨‡¶æ‡¶∞
        // O(1) operation
    }
}
// Total: n √ó n = O(n¬≤)
```

### 3. Dependent Nested Loop
```cpp
for(int i = 0; i < n; i++) {
    for(int j = i; j < n; j++) {   // j ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶π‡¶Ø‡¶º i ‡¶•‡ßá‡¶ï‡ßá
        // O(1) operation
    }
}
// Analysis: n + (n-1) + (n-2) + ... + 1 = n(n+1)/2 = O(n¬≤)
```

### 4. Logarithmic Loop
```cpp
for(int i = 1; i < n; i *= 2) {    // i = 1, 2, 4, 8, 16, ...
    // O(1) operation
}
// i ‡¶è‡¶∞ ‡¶Æ‡¶æ‡¶®: 2‚Å∞, 2¬π, 2¬≤, 2¬≥, ..., 2^k ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá 2^k < n
// k = log‚ÇÇ(n), ‡¶§‡¶æ‡¶á Time: O(log n)
```

---

## ‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶®‡¶ø‡¶Ø‡¶º‡¶Æ‡¶æ‡¶¨‡¶≤‡ßÄ

### 1. Constants Drop ‡¶ï‡¶∞‡ßã
```cpp
for(int i = 0; i < n; i++) {
    arr[i] = arr[i] * 5;  // 5 ‡¶è‡¶ï‡¶ü‡¶ø constant
}
// O(5n) = O(n)  [5 ‡¶ï‡ßá ‡¶¨‡¶æ‡¶¶ ‡¶¶‡¶æ‡¶ì]
```

### 2. ‡¶∏‡¶¨‡¶ö‡ßá‡¶Ø‡¶º‡ßá ‡¶¨‡¶°‡¶º Term ‡¶∞‡¶æ‡¶ñ‡ßã
```cpp
for(int i = 0; i < n; i++) {       // O(n)
    // some work
}
for(int i = 0; i < n; i++) {       // O(n¬≤)
    for(int j = 0; j < n; j++) {
        // some work
    }
}
// Total: O(n) + O(n¬≤) = O(n¬≤)  [‡¶õ‡ßã‡¶ü term ‡¶¨‡¶æ‡¶¶ ‡¶¶‡¶æ‡¶ì]
```

### 3. Sequential Operations = Addition
```cpp
// ‡¶™‡ßç‡¶∞‡¶•‡¶Æ loop
for(int i = 0; i < n; i++) { }     // O(n)

// ‡¶¶‡ßç‡¶¨‡¶ø‡¶§‡ßÄ‡¶Ø‡¶º loop  
for(int i = 0; i < m; i++) { }     // O(m)

// Total: O(n + m)
```

### 4. Nested Operations = Multiplication
```cpp
for(int i = 0; i < n; i++) {         // O(n)
    for(int j = 0; j < m; j++) {     // O(m)
        // work
    }
}
// Total: O(n √ó m) = O(nm)
```

---

## Space Complexity

### Memory ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ì ‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£!

```cpp
// O(1) Space - ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶ï‡¶Ø‡¶º‡ßá‡¶ï‡¶ü‡¶æ variable
int sum = 0;
for(int i = 0; i < n; i++) {
    sum += arr[i];
}

// O(n) Space - ‡¶®‡¶§‡ßÅ‡¶® array ‡¶¨‡¶æ‡¶®‡¶æ‡¶®‡ßã
int newArr[n];
for(int i = 0; i < n; i++) {
    newArr[i] = arr[i] * 2;
}

// O(n¬≤) Space - 2D array
int matrix[n][n];
```

---

## Practical Guidelines

### Input Size ‡¶Ö‡¶®‡ßÅ‡¶Ø‡¶æ‡¶Ø‡¶º‡ßÄ Complexity:
```
n ‚â§ 10     ‚Üí O(n!) ‡¶¨‡¶æ O(2‚Åø) ‡¶ö‡¶≤‡¶¨‡ßá
n ‚â§ 20     ‚Üí O(2‚Åø) ‡¶ö‡¶≤‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá  
n ‚â§ 100    ‚Üí O(n¬≥) ‡¶†‡¶ø‡¶ï ‡¶Ü‡¶õ‡ßá
n ‚â§ 1000   ‚Üí O(n¬≤) acceptable
n ‚â§ 10‚Åµ    ‚Üí O(n log n) ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®
n ‚â§ 10‚Å∂    ‚Üí O(n) ‡¶¨‡¶æ O(log n) ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá
n ‚â§ 10‚Å∏    ‚Üí O(log n) ‡¶¨‡¶æ O(1) ‡¶ö‡¶æ‡¶á
```

---

## ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ Algorithms ‡¶è‡¶∞ Complexity

### Sorting:
- **Bubble Sort**: O(n¬≤)
- **Merge Sort**: O(n log n)  
- **Quick Sort**: Average O(n log n), Worst O(n¬≤)

### Searching:
- **Linear Search**: O(n)
- **Binary Search**: O(log n)

### Data Structures:
- **Array Access**: O(1)
- **Hash Table**: Average O(1)
- **Binary Tree Search**: O(log n)

---

## ‡¶Æ‡¶®‡ßá ‡¶∞‡¶æ‡¶ñ‡¶æ‡¶∞ ‡¶ï‡ßå‡¶∂‡¶≤

### 1. **Big O Cheat Sheet:**
```
O(1)      ‚Üí Array[index] access
O(log n)  ‚Üí Binary Search, Tree operations  
O(n)      ‚Üí Single loop through array
O(n¬≤)     ‚Üí Nested loops, Bubble Sort
O(2‚Åø)     ‚Üí Recursive Fibonacci
```

### 2. **Loop ‡¶¶‡ßá‡¶ñ‡ßá ‡¶¨‡ßÅ‡¶ù‡ßã:**
- ‡ßß‡¶ü‡¶æ Loop = ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£‡¶§ O(n)
- ‡ß®‡¶ü‡¶æ Nested Loop = ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£‡¶§ O(n¬≤)  
- Loop ‡¶Ø‡¶¶‡¶ø ‡¶Ö‡¶∞‡ßç‡¶ß‡ßá‡¶ï ‡¶ï‡¶∞‡ßá ‡¶ï‡¶Æ‡ßá = O(log n)

### 3. **Optimization Tips:**
- Hash Table ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá O(1) lookup
- Sorting ‡¶ï‡¶∞‡ßá Binary Search
- Two Pointers technique
- Dynamic Programming

---

## Interview ‡¶è ‡¶Ø‡¶æ ‡¶¨‡¶≤‡¶¨‡ßá:

1. **Brute Force approach** ‡¶Ü‡¶ó‡ßá ‡¶¨‡¶≤
2. **Time ‡¶ì Space Complexity** ‡¶â‡¶≤‡ßç‡¶≤‡ßá‡¶ñ ‡¶ï‡¶∞
3. **Optimization** ‡¶è‡¶∞ ‡¶â‡¶™‡¶æ‡¶Ø‡¶º ‡¶Ü‡¶≤‡ßã‡¶ö‡¶®‡¶æ ‡¶ï‡¶∞
4. **Trade-offs** ‡¶®‡¶ø‡¶Ø‡¶º‡ßá ‡¶ï‡¶•‡¶æ ‡¶¨‡¶≤

**Example:**
> "‡¶Ü‡¶Æ‡¶æ‡¶∞ solution ‡¶ü‡¶æ O(n¬≤) time complexity ‡¶Ü‡¶õ‡ßá nested loop ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø‡•§ ‡¶Ø‡¶¶‡¶ø ‡¶Ü‡¶Æ‡¶ø hash table ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶ø, ‡¶§‡¶æ‡¶π‡¶≤‡ßá O(n) time ‡¶è ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßã ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ O(n) extra space ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá‡•§"

---

## ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™

Big O Notation ‡¶∂‡¶ø‡¶ñ‡ßá ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶¨‡ßÅ‡¶ù‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø:
- ‡¶ï‡ßã‡¶® algorithm ‡¶ï‡¶§‡¶ü‡¶æ efficient
- Large input ‡¶è ‡¶ï‡ßá‡¶Æ‡¶® perform ‡¶ï‡¶∞‡¶¨‡ßá  
- Memory ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶§ ‡¶π‡¶¨‡ßá
- ‡¶ï‡ßã‡¶•‡¶æ‡¶Ø‡¶º optimization ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º

**‡¶Æ‡ßÇ‡¶≤ ‡¶ï‡¶•‡¶æ:** ‡¶Ø‡¶§ practice ‡¶ï‡¶∞‡¶¨‡ßá, ‡¶§‡¶§ ‡¶≠‡¶æ‡¶≤ ‡¶π‡¶¨‡ßá! üöÄ

---

*"Premature optimization is the root of all evil, but knowing Big O is essential!"* - Programming Wisdom
