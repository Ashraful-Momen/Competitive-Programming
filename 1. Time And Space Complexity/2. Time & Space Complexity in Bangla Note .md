# C Programming - Time & Space Complexity ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶ó‡¶æ‡¶á‡¶°
## ‡¶ó‡¶æ‡¶£‡¶ø‡¶§‡¶ø‡¶ï ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£ ‡¶ì For Loop Patterns

---

## üéØ ‡¶Æ‡ßÇ‡¶≤ ‡¶ß‡¶æ‡¶™‡¶∏‡¶Æ‡ßÇ‡¶π

### **STEP 1: Input Size ‡¶ö‡¶ø‡¶π‡ßç‡¶®‡¶ø‡¶§ ‡¶ï‡¶∞‡ßÅ‡¶®**
- ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£‡¶§ `n` ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶™‡ßç‡¶∞‡¶ï‡¶æ‡¶∂ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º (array size, string length ‡¶á‡¶§‡ßç‡¶Ø‡¶æ‡¶¶‡¶ø)
- ‡¶ï‡¶ñ‡¶®‡¶ì ‡¶è‡¶ï‡¶æ‡¶ß‡¶ø‡¶ï input: `n`, `m`, `k`

### **STEP 2: Operations/Memory ‡¶ó‡¶£‡¶®‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®**

---

## üîç TIME COMPLEXITY ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£

### **Pattern 1: Single Loop = O(n)**

```c
#include <stdio.h>

// ‡¶è‡¶ï‡¶ï loop - O(n)
void printNumbers(int n) {
    for(int i = 0; i < n; i++) {    // n ‡¶¨‡¶æ‡¶∞ ‡¶ö‡¶≤‡¶¨‡ßá
        printf("%d ", i);           // O(1) operation
    }
}
// Total Time: O(n)
```

**ASCII Visualization:**
```
n=5:  ‚ñ† ‚ñ† ‚ñ† ‚ñ† ‚ñ†           (5 operations)
n=10: ‚ñ† ‚ñ† ‚ñ† ‚ñ† ‚ñ† ‚ñ† ‚ñ† ‚ñ† ‚ñ† ‚ñ†  (10 operations)
```

### **Pattern 2: Nested Loops = O(n¬≤)**

```c
// ‡¶¶‡ßç‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶∞‡ßÄ‡¶Ø‡¶º loop - O(n¬≤)  
void bubbleSort(int arr[], int n) {
    for(int i = 0; i < n; i++) {        // ‡¶¨‡¶æ‡¶á‡¶∞‡ßá‡¶∞ loop: n ‡¶¨‡¶æ‡¶∞
        for(int j = 0; j < n-1-i; j++) { // ‡¶≠‡¶ø‡¶§‡¶∞‡ßá‡¶∞ loop: (n-1-i) ‡¶¨‡¶æ‡¶∞
            if(arr[j] > arr[j+1]) {
                // Swap operation - O(1)
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}
```

**‡¶ó‡¶æ‡¶£‡¶ø‡¶§‡¶ø‡¶ï ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£:**
```
i=0: j ‡¶ö‡¶≤‡¶¨‡ßá (n-1) ‡¶¨‡¶æ‡¶∞
i=1: j ‡¶ö‡¶≤‡¶¨‡ßá (n-2) ‡¶¨‡¶æ‡¶∞  
i=2: j ‡¶ö‡¶≤‡¶¨‡ßá (n-3) ‡¶¨‡¶æ‡¶∞
...
i=n-1: j ‡¶ö‡¶≤‡¶¨‡ßá 0 ‡¶¨‡¶æ‡¶∞

‡¶Æ‡ßã‡¶ü operations = (n-1) + (n-2) + ... + 1
                = n(n-1)/2 
                = (n¬≤ - n)/2
                = O(n¬≤)
```

**ASCII Visualization:**
```
n=4 Matrix:
‚ñ† ‚ñ† ‚ñ† ‚ñ†
‚ñ† ‚ñ† ‚ñ† ‚ñ†    (4√ó4 = 16 operations)
‚ñ† ‚ñ† ‚ñ† ‚ñ†
‚ñ† ‚ñ† ‚ñ† ‚ñ†

n=3 Matrix:
‚ñ† ‚ñ† ‚ñ†
‚ñ† ‚ñ† ‚ñ†      (3√ó3 = 9 operations)  
‚ñ† ‚ñ† ‚ñ†
```

### **Pattern 3: Triple Nested = O(n¬≥)**

```c
// ‡¶§‡ßç‡¶∞‡¶ø‡¶∏‡ßç‡¶§‡¶∞‡ßÄ‡¶Ø‡¶º loop - O(n¬≥)
void matrixMultiplication(int A[][100], int B[][100], int C[][100], int n) {
    for(int i = 0; i < n; i++) {       // n ‡¶¨‡¶æ‡¶∞
        for(int j = 0; j < n; j++) {   // n ‡¶¨‡¶æ‡¶∞ (‡¶™‡ßç‡¶∞‡¶§‡¶ø i ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø)
            C[i][j] = 0;
            for(int k = 0; k < n; k++) { // n ‡¶¨‡¶æ‡¶∞ (‡¶™‡ßç‡¶∞‡¶§‡¶ø i,j ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø)
                C[i][j] += A[i][k] * B[k][j];  // O(1)
            }
        }
    }
}
// Total: n √ó n √ó n = O(n¬≥)
```

### **Pattern 4: Dependent Loop = O(n¬≤)**

```c
// ‡¶®‡¶ø‡¶∞‡ßç‡¶≠‡¶∞‡¶∂‡ßÄ‡¶≤ loop - O(n¬≤)
void printTriangle(int n) {
    for(int i = 0; i < n; i++) {       // i: 0 ‡¶•‡ßá‡¶ï‡ßá n-1
        for(int j = 0; j <= i; j++) {  // j: 0 ‡¶•‡ßá‡¶ï‡ßá i
            printf("* ");
        }
        printf("\n");
    }
}
```

**‡¶ó‡¶æ‡¶£‡¶ø‡¶§‡¶ø‡¶ï ‡¶™‡ßç‡¶∞‡¶Æ‡¶æ‡¶£:**
```
i=0: j ‡¶ö‡¶≤‡¶¨‡ßá 1 ‡¶¨‡¶æ‡¶∞ (0 ‡¶•‡ßá‡¶ï‡ßá 0)
i=1: j ‡¶ö‡¶≤‡¶¨‡ßá 2 ‡¶¨‡¶æ‡¶∞ (0 ‡¶•‡ßá‡¶ï‡ßá 1)
i=2: j ‡¶ö‡¶≤‡¶¨‡ßá 3 ‡¶¨‡¶æ‡¶∞ (0 ‡¶•‡ßá‡¶ï‡ßá 2)
...
i=n-1: j ‡¶ö‡¶≤‡¶¨‡ßá n ‡¶¨‡¶æ‡¶∞ (0 ‡¶•‡ßá‡¶ï‡ßá n-1)

‡¶Æ‡ßã‡¶ü = 1 + 2 + 3 + ... + n
    = n(n+1)/2
    = O(n¬≤)
```

**ASCII Output (n=4):**
```
*
* *
* * *  
* * * *
```

### **Pattern 5: Logarithmic = O(log n)**

```c
// Binary Search - O(log n)
int binarySearch(int arr[], int n, int target) {
    int left = 0, right = n - 1;
    
    while(left <= right) {              // log‚ÇÇ(n) ‡¶¨‡¶æ‡¶∞ ‡¶ö‡¶≤‡¶¨‡ßá
        int mid = left + (right - left) / 2;
        
        if(arr[mid] == target) {
            return mid;                 // ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶ó‡ßá‡¶õ‡ßá!
        }
        else if(arr[mid] < target) {
            left = mid + 1;             // ‡¶°‡¶æ‡¶®‡¶¶‡¶ø‡¶ï‡ßá ‡¶ñ‡ßã‡¶Å‡¶ú‡ßã
        } 
        else {
            right = mid - 1;            // ‡¶¨‡¶æ‡¶Æ‡¶¶‡¶ø‡¶ï‡ßá ‡¶ñ‡ßã‡¶Å‡¶ú‡ßã
        }
    }
    return -1;                          // ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø
}
```

**Binary Search ‡¶è‡¶∞ ‡¶ï‡¶æ‡¶ú:**
```
Array: [1, 3, 5, 7, 9, 11, 13, 15]  (n=8)
Target: 7

Step 1: [1, 3, 5, 7, 9, 11, 13, 15]
         ‚Üë           ‚Üë               ‚Üë
       left        mid             right
       mid=9 > 7, so right=mid-1

Step 2: [1, 3, 5, 7]
         ‚Üë     ‚Üë   ‚Üë  
       left  mid right
       mid=3 < 7, so left=mid+1

Step 3: [5, 7]
         ‚Üë  ‚Üë
       left=right=mid  
       mid=5 < 7, so left=mid+1

Step 4: [7]
         ‚Üë
    left=right=mid
    Found! return 3
```

**Loop Reduction Pattern:**
```c
// Dividing by 2 pattern - O(log n)
void logPattern(int n) {
    int i = n;
    while(i > 1) {
        printf("%d ", i);
        i = i / 2;                      // ‡¶Ö‡¶∞‡ßç‡¶ß‡ßá‡¶ï ‡¶ï‡¶∞‡ßá ‡¶ï‡¶Æ‡¶æ‡¶®‡ßã
    }
}
// i ‡¶è‡¶∞ ‡¶Æ‡¶æ‡¶®: n, n/2, n/4, n/8, ..., 1
// Steps = log‚ÇÇ(n), Time: O(log n)
```

### **Pattern 6: Exponential = O(2‚Åø)**

```c
// Fibonacci (Naive) - O(2‚Åø)
int fibonacci(int n) {
    if(n <= 1) {
        return n;                       // Base case
    }
    return fibonacci(n-1) + fibonacci(n-2);  // ‡¶¶‡ßÅ‡¶ü‡¶ø recursive call
}
```

**Recursion Tree (n=5):**
```
                    fib(5)
                   /      \
               fib(4)      fib(3)
               /    \      /    \
           fib(3)  fib(2) fib(2) fib(1)
           /   \   /   \   /   \
       fib(2) fib(1) fib(1) fib(0) fib(1) fib(0)
       /   \
   fib(1) fib(0)
```

**‡¶ó‡¶æ‡¶£‡¶ø‡¶§‡¶ø‡¶ï ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£:**
```
T(n) = T(n-1) + T(n-2) + O(1)
‡¶è‡¶á recurrence relation ‡¶è‡¶∞ solution:
T(n) ‚âà œÜ‚Åø ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá œÜ = (1+‚àö5)/2 ‚âà 1.618 (Golden Ratio)
‡¶§‡¶æ‡¶á T(n) = O(2‚Åø) (approximately)
```

---

## üßÆ ‡¶ó‡¶æ‡¶£‡¶ø‡¶§‡¶ø‡¶ï ‡¶∏‡ßÇ‡¶§‡ßç‡¶∞‡¶æ‡¶¨‡¶≤‡ßÄ (Mathematical Formulas)

### **1. Arithmetic Progression (‡¶∏‡¶Æ‡¶æ‡¶®‡ßç‡¶§‡¶∞ ‡¶Ö‡¶ó‡ßç‡¶∞‡¶ó‡¶§‡¶ø):**
```
‡¶∏‡ßÇ‡¶§‡ßç‡¶∞: Œ£(i=1 to n) i = 1 + 2 + 3 + ... + n = n(n+1)/2

‡¶ó‡¶æ‡¶£‡¶ø‡¶§‡¶ø‡¶ï ‡¶™‡ßç‡¶∞‡¶Æ‡¶æ‡¶£:
S = 1 + 2 + 3 + ... + n
S = n + (n-1) + (n-2) + ... + 1  [‡¶â‡¶≤‡ßç‡¶ü‡ßã ‡¶ï‡¶∞‡ßá ‡¶≤‡¶ø‡¶ñ‡¶≤‡¶æ‡¶Æ]
2S = (n+1) + (n+1) + ... + (n+1)  [n ‡¶¨‡¶æ‡¶∞]
2S = n(n+1)
S = n(n+1)/2 = O(n¬≤)
```

**C Code Example:**
```c
void dependentLoop(int n) {
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= i; j++) {    // j ‡¶ö‡¶≤‡¶¨‡ßá i ‡¶¨‡¶æ‡¶∞
            printf("%d,%d ", i, j);
        }
    }
}
// Total = 1 + 2 + 3 + ... + n = n(n+1)/2 = O(n¬≤)
```

### **2. Geometric Progression (‡¶ó‡ßÅ‡¶£‡ßã‡¶§‡ßç‡¶§‡¶∞ ‡¶Ö‡¶ó‡ßç‡¶∞‡¶ó‡¶§‡¶ø):**
```
‡¶∏‡ßÇ‡¶§‡ßç‡¶∞: Œ£(i=0 to n) 2^i = 1 + 2 + 4 + 8 + ... + 2^n = 2^(n+1) - 1

‡¶ó‡¶æ‡¶£‡¶ø‡¶§‡¶ø‡¶ï ‡¶™‡ßç‡¶∞‡¶Æ‡¶æ‡¶£:
S = 1 + 2 + 4 + ... + 2^n
2S = 2 + 4 + 8 + ... + 2^(n+1)
2S - S = 2^(n+1) - 1
S = 2^(n+1) - 1 = O(2^n)
```

### **3. Harmonic Series (‡¶π‡¶æ‡¶∞‡¶Æ‡¶®‡¶ø‡¶ï ‡¶ß‡¶æ‡¶∞‡¶æ):**
```
‡¶∏‡ßÇ‡¶§‡ßç‡¶∞: Œ£(i=1 to n) 1/i = 1 + 1/2 + 1/3 + ... + 1/n ‚âà ln(n) = O(log n)
```

**C Code Example:**
```c
void harmonicPattern(int n) {
    for(int i = 1; i <= n; i++) {           // i: 1 ‡¶•‡ßá‡¶ï‡ßá n
        for(int j = i; j <= n; j += i) {    // j: i, 2i, 3i, ... (n/i ‡¶¨‡¶æ‡¶∞)
            printf("%d ", j);
        }
    }
}
// Total = n/1 + n/2 + n/3 + ... + n/n = n(1 + 1/2 + 1/3 + ... + 1/n) = O(n log n)
```

---

## üîÑ Recursive Complexity Analysis

### **Master Theorem:**
```
Recurrence: T(n) = aT(n/b) + f(n)
‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá: a ‚â• 1, b > 1, f(n) > 0

c = log_b(a) ‡¶ß‡¶∞‡ßÅ‡¶®

Case 1: ‡¶Ø‡¶¶‡¶ø f(n) = O(n^d) ‡¶è‡¶¨‡¶Ç d < c ‡¶π‡¶Ø‡¶º
        ‡¶§‡¶æ‡¶π‡¶≤‡ßá T(n) = O(n^c)

Case 2: ‡¶Ø‡¶¶‡¶ø f(n) = O(n^c √ó log^k(n)) ‡¶è‡¶¨‡¶Ç k ‚â• 0 ‡¶π‡¶Ø‡¶º  
        ‡¶§‡¶æ‡¶π‡¶≤‡ßá T(n) = O(n^c √ó log^(k+1)(n))

Case 3: ‡¶Ø‡¶¶‡¶ø f(n) = O(n^d) ‡¶è‡¶¨‡¶Ç d > c ‡¶π‡¶Ø‡¶º ‡¶è‡¶¨‡¶Ç af(n/b) ‚â§ cf(n)
        ‡¶§‡¶æ‡¶π‡¶≤‡ßá T(n) = O(f(n))
```

### **Master Theorem Examples:**

**Example 1: Binary Search**
```c
int binarySearchRecursive(int arr[], int left, int right, int target) {
    if(left > right) return -1;
    
    int mid = left + (right - left) / 2;
    if(arr[mid] == target) return mid;
    else if(arr[mid] < target)
        return binarySearchRecursive(arr, mid+1, right, target);  // T(n/2)
    else
        return binarySearchRecursive(arr, left, mid-1, target);   // T(n/2)
}

// Recurrence: T(n) = T(n/2) + O(1)
// a=1, b=2, f(n)=O(1)=O(n^0)
// c = log‚ÇÇ(1) = 0
// ‡¶Ø‡ßá‡¶π‡ßá‡¶§‡ßÅ f(n) = O(n^0) ‡¶è‡¶¨‡¶Ç d = c = 0 ‚Üí Case 2
// T(n) = O(n^0 √ó log n) = O(log n)
```

**Example 2: Merge Sort**
```c
void mergeSort(int arr[], int left, int right) {
    if(left < right) {
        int mid = left + (right - left) / 2;
        
        mergeSort(arr, left, mid);          // T(n/2)
        mergeSort(arr, mid + 1, right);     // T(n/2)
        merge(arr, left, mid, right);       // O(n)
    }
}

// Recurrence: T(n) = 2T(n/2) + O(n)
// a=2, b=2, f(n)=O(n)=O(n^1)
// c = log‚ÇÇ(2) = 1  
// ‡¶Ø‡ßá‡¶π‡ßá‡¶§‡ßÅ f(n) = O(n^1) ‡¶è‡¶¨‡¶Ç d = c = 1 ‚Üí Case 2
// T(n) = O(n^1 √ó log n) = O(n log n)
```

---

## üíæ SPACE COMPLEXITY ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£

### **Pattern 1: Constant Space = O(1)**
```c
int findMax(int arr[], int n) {
    int max = arr[0];        // O(1) space
    int i;                   // O(1) space
    
    for(i = 1; i < n; i++) {
        if(arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}
// Total Space: O(1) - ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶ï‡¶Ø‡¶º‡ßá‡¶ï‡¶ü‡¶æ variable
```

### **Pattern 2: Linear Space = O(n)**
```c
int* createCopy(int arr[], int n) {
    int* copy = (int*)malloc(n * sizeof(int));  // O(n) space
    
    for(int i = 0; i < n; i++) {
        copy[i] = arr[i];
    }
    return copy;
}
// Total Space: O(n) - ‡¶®‡¶§‡ßÅ‡¶® array
```

### **Pattern 3: Quadratic Space = O(n¬≤)**
```c
int** create2DArray(int n) {
    int** matrix = (int**)malloc(n * sizeof(int*));     // O(n) pointers
    
    for(int i = 0; i < n; i++) {
        matrix[i] = (int*)malloc(n * sizeof(int));      // O(n) per row
    }
    
    return matrix;  // Total: n √ó n = O(n¬≤)
}
```

### **Pattern 4: Recursive Space (Call Stack)**
```c
int factorial(int n) {
    if(n <= 1) return 1;                    // Base case
    return n * factorial(n-1);              // Recursive call
}

// ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø call stack ‡¶è memory ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶π‡¶Ø‡¶º
// Maximum depth = n
// Space Complexity: O(n) due to call stack
```

**Call Stack Visualization (n=4):**
```
factorial(4)  ‚Üê Stack Frame 4
  ‚Üì
factorial(3)  ‚Üê Stack Frame 3  
  ‚Üì
factorial(2)  ‚Üê Stack Frame 2
  ‚Üì
factorial(1)  ‚Üê Stack Frame 1 (Base case)
```

---

## üéØ ‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§ ‡¶ö‡¶ø‡¶π‡ßç‡¶®‡¶ø‡¶§‡¶ï‡¶∞‡¶£ ‡¶®‡¶ø‡¶Ø‡¶º‡¶Æ‡¶æ‡¶¨‡¶≤‡ßÄ

### **Time Complexity Shortcuts:**
```c
// ‡¶è‡¶ï‡¶ü‡¶ø loop = O(n)
for(int i = 0; i < n; i++) { }

// ‡¶¶‡ßÅ‡¶ü‡¶ø nested loop = O(n¬≤)  
for(int i = 0; i < n; i++) {
    for(int j = 0; j < n; j++) { }
}

// ‡¶Ö‡¶∞‡ßç‡¶ß‡ßá‡¶ï ‡¶ï‡¶∞‡ßá ‡¶ï‡¶Æ‡¶æ‡¶®‡ßã = O(log n)
while(n > 1) { n = n/2; }

// Tree traversal = O(n)
// Sorting (good algorithms) = O(n log n)
// All permutations = O(n!)
// All subsets = O(2‚Åø)
```

### **Space Complexity Shortcuts:**
```c
// ‡¶ï‡¶Ø‡¶º‡ßá‡¶ï‡¶ü‡¶æ variable = O(1)
int a, b, c;

// ‡¶è‡¶ï‡¶ü‡¶æ array = O(n)  
int arr[n];

// 2D array = O(n¬≤)
int matrix[n][n];

// Recursion depth = O(depth)
// Memoization = O(unique states)
```

---

## üìä ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ Algorithm ‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ Complexity

### **Sorting Algorithms:**
```c
// Bubble Sort - O(n¬≤) time, O(1) space
void bubbleSort(int arr[], int n);

// Selection Sort - O(n¬≤) time, O(1) space  
void selectionSort(int arr[], int n);

// Insertion Sort - O(n¬≤) time, O(1) space
void insertionSort(int arr[], int n);

// Merge Sort - O(n log n) time, O(n) space
void mergeSort(int arr[], int left, int right);

// Quick Sort - O(n log n) average, O(n¬≤) worst, O(log n) space
void quickSort(int arr[], int low, int high);

// Heap Sort - O(n log n) time, O(1) space  
void heapSort(int arr[], int n);
```

### **Searching Algorithms:**
```c
// Linear Search - O(n) time, O(1) space
int linearSearch(int arr[], int n, int target);

// Binary Search - O(log n) time, O(1) space
int binarySearch(int arr[], int n, int target);
```

---

## üîß Optimization Techniques

### **1. Two Pointers Technique:**
```c
// O(n¬≤) ‡¶•‡ßá‡¶ï‡ßá O(n) ‡¶è optimize
int twoSum(int arr[], int n, int target) {
    // ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá sort ‡¶ï‡¶∞‡ßÅ‡¶® - O(n log n)
    
    int left = 0, right = n - 1;
    while(left < right) {               // O(n)
        int sum = arr[left] + arr[right];
        if(sum == target) {
            printf("Found: %d + %d = %d\n", arr[left], arr[right], target);
            return 1;
        }
        else if(sum < target) {
            left++;
        }
        else {
            right--;
        }
    }
    return 0;
}
// Total: O(n log n) instead of O(n¬≤)
```

### **2. Memoization (Dynamic Programming):**
```c
int memo[1000];  // Global memoization array

int fibonacciDP(int n) {
    if(n <= 1) return n;
    
    if(memo[n] != -1) {         // Already calculated
        return memo[n];
    }
    
    memo[n] = fibonacciDP(n-1) + fibonacciDP(n-2);
    return memo[n];
}
// Time: O(n) instead of O(2‚Åø)
// Space: O(n) for memoization
```

### **3. Sliding Window:**
```c
// Maximum sum subarray of size k
int maxSumSubarray(int arr[], int n, int k) {
    if(n < k) return -1;
    
    // Calculate first window sum
    int windowSum = 0;
    for(int i = 0; i < k; i++) {
        windowSum += arr[i];
    }
    
    int maxSum = windowSum;
    
    // Slide the window  
    for(int i = k; i < n; i++) {
        windowSum = windowSum - arr[i-k] + arr[i];  // O(1) per iteration
        if(windowSum > maxSum) {
            maxSum = windowSum;
        }
    }
    
    return maxSum;
}
// Time: O(n) instead of O(n√ók)
```

---

## üìà Complexity Hierarchy (‡¶∏‡¶¨‡¶ö‡ßá‡¶Ø‡¶º‡ßá ‡¶≠‡¶æ‡¶≤ ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶¨‡¶ö‡ßá‡¶Ø‡¶º‡ßá ‡¶ñ‡¶æ‡¶∞‡¶æ‡¶™)

```
O(1) < O(log n) < O(‚àön) < O(n) < O(n log n) < O(n¬≤) < O(n¬≥) < O(2‚Åø) < O(n!)

‡¶¶‡ßç‡¶∞‡ßÅ‡¶§‡¶§‡¶Æ ‚Üê                                                           ‚Üí ‡¶ß‡ßÄ‡¶∞‡¶§‡¶Æ
```

**Practical Limits (n ‡¶è‡¶∞ ‡¶Æ‡¶æ‡¶® ‡¶Ö‡¶®‡ßÅ‡¶Ø‡¶æ‡¶Ø‡¶º‡ßÄ):**
```
n ‚â§ 10:     O(n!) ‡¶¨‡¶æ O(2‚Åø) ‡¶ö‡¶≤‡¶¨‡ßá
n ‚â§ 20:     O(2‚Åø) ‡¶ö‡¶≤‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá
n ‚â§ 100:    O(n¬≥) ‡¶†‡¶ø‡¶ï ‡¶Ü‡¶õ‡ßá  
n ‚â§ 1000:   O(n¬≤) acceptable
n ‚â§ 10‚Åµ:    O(n log n) ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®
n ‚â§ 10‚Å∂:    O(n) ‡¶¨‡¶æ O(log n) ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá
n ‚â§ 10‚Å∏:    O(log n) ‡¶¨‡¶æ O(1) ‡¶ö‡¶æ‡¶á
```

---

## üéØ Step-by-Step Analysis Method

### **‡¶Ø‡ßá‡¶ï‡ßã‡¶®‡ßã C Code ‡¶è‡¶∞ Complexity ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ß‡¶æ‡¶™:**

1. **Input size ‡¶ö‡¶ø‡¶π‡ßç‡¶®‡¶ø‡¶§ ‡¶ï‡¶∞‡ßÅ‡¶®:** ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£‡¶§ `n`
2. **‡¶∏‡¶¨ loop ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®:** ‡¶ï‡¶Ø‡¶º‡¶ü‡¶æ ‡¶®‡ßá‡¶∏‡ßç‡¶ü‡ßá‡¶° ‡¶Ü‡¶õ‡ßá?
3. **Loop bounds ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®:** constant ‡¶®‡¶æ‡¶ï‡¶ø n ‡¶è‡¶∞ ‡¶â‡¶™‡¶∞ ‡¶®‡¶ø‡¶∞‡ßç‡¶≠‡¶∞‡¶∂‡ßÄ‡¶≤?
4. **Recursive calls ‡¶ó‡¶£‡¶®‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®:** ‡¶ï‡¶§‡¶ü‡¶æ ‡¶è‡¶¨‡¶Ç ‡¶ï‡¶§ ‡¶ó‡¶≠‡ßÄ‡¶∞?
5. **Extra space ‡¶ó‡¶£‡¶®‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®:** arrays, recursion stack ‡¶á‡¶§‡ßç‡¶Ø‡¶æ‡¶¶‡¶ø
6. **‡¶ó‡¶æ‡¶£‡¶ø‡¶§‡¶ø‡¶ï ‡¶∏‡ßÇ‡¶§‡ßç‡¶∞ ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ó ‡¶ï‡¶∞‡ßÅ‡¶®:** Series sum ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶Ø‡¶¶‡¶ø ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶® ‡¶π‡¶Ø‡¶º
7. **Dominant term ‡¶®‡¶ø‡¶®:** constants ‡¶è‡¶¨‡¶Ç ‡¶õ‡ßã‡¶ü terms ‡¶¨‡¶æ‡¶¶ ‡¶¶‡¶ø‡¶®

### **Final Rules:**
- **Constants ‡¶¨‡¶æ‡¶¶ ‡¶¶‡¶ø‡¶®:** O(5n) ‚Üí O(n)
- **Lower terms ‡¶¨‡¶æ‡¶¶ ‡¶¶‡¶ø‡¶®:** O(n¬≤ + n) ‚Üí O(n¬≤)
- **Worst case ‡¶¨‡¶ø‡¶¨‡ßá‡¶ö‡¶®‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®:** ‡¶∏‡¶¨‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶∏‡¶¨‡¶ö‡ßá‡¶Ø‡¶º‡ßá ‡¶ñ‡¶æ‡¶∞‡¶æ‡¶™ scenario

---

## üí° Pro Tips

### **1. Quick Recognition:**
```c
// ‡¶è‡¶ï‡¶ü‡¶æ loop ‡¶¶‡ßá‡¶ñ‡¶≤‡ßá‡¶á ‡¶¨‡ßÅ‡¶ù‡¶¨‡ßá‡¶® O(n)
for(int i = 0; i < n; i++) { }

// ‡¶¶‡ßÅ‡¶ü‡¶æ nested loop ‡¶¶‡ßá‡¶ñ‡¶≤‡ßá‡¶á ‡¶¨‡ßÅ‡¶ù‡¶¨‡ßá‡¶® O(n¬≤)
for(int i = 0; i < n; i++) {
    for(int j = 0; j < n; j++) { }
}

// ‡¶Ö‡¶∞‡ßç‡¶ß‡ßá‡¶ï ‡¶ï‡¶∞‡ßá ‡¶ï‡¶Æ‡¶≤‡ßá‡¶á ‡¶¨‡ßÅ‡¶ù‡¶¨‡ßá‡¶® O(log n)
while(n > 1) { n /= 2; }
```

### **2. Interview ‡¶è ‡¶Ø‡¶æ ‡¶¨‡¶≤‡¶¨‡ßá‡¶®:**
- ‡¶Ü‡¶ó‡ßá **Brute Force** approach ‡¶¨‡¶≤‡ßÅ‡¶®
- **Time ‡¶ì Space Complexity** ‡¶â‡¶≤‡ßç‡¶≤‡ßá‡¶ñ ‡¶ï‡¶∞‡ßÅ‡¶®  
- **Optimization** ‡¶è‡¶∞ ‡¶â‡¶™‡¶æ‡¶Ø‡¶º ‡¶Ü‡¶≤‡ßã‡¶ö‡¶®‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®
- **Trade-offs** ‡¶®‡¶ø‡¶Ø‡¶º‡ßá ‡¶ï‡¶•‡¶æ ‡¶¨‡¶≤‡ßÅ‡¶®

### **3. Common Mistakes ‡¶è‡¶°‡¶º‡¶ø‡¶Ø‡¶º‡ßá ‡¶ö‡¶≤‡ßÅ‡¶®:**
- Constants ‡¶ï‡ßá ignore ‡¶ï‡¶∞‡¶§‡ßá ‡¶≠‡ßÅ‡¶≤‡¶¨‡ßá‡¶® ‡¶®‡¶æ
- Nested loops ‡¶è‡¶∞ dependency check ‡¶ï‡¶∞‡ßÅ‡¶®
- Recursion ‡¶è‡¶∞ depth ‡¶Æ‡¶®‡ßá ‡¶∞‡¶æ‡¶ñ‡ßÅ‡¶®
- Space complexity ‡¶≠‡ßÅ‡¶≤‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá‡¶® ‡¶®‡¶æ

---

## üöÄ ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™

Time ‡¶ì Space Complexity ‡¶∂‡¶ø‡¶ñ‡ßá ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶¨‡ßÅ‡¶ù‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø:
- **‡¶ï‡ßã‡¶® algorithm ‡¶ï‡¶§‡¶ü‡¶æ efficient**
- **Large input ‡¶è ‡¶ï‡ßá‡¶Æ‡¶® perform ‡¶ï‡¶∞‡¶¨‡ßá**
- **Memory ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡ßá‡¶Æ‡¶® ‡¶π‡¶¨‡ßá**
- **‡¶ï‡ßã‡¶•‡¶æ‡¶Ø‡¶º optimization ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º**

**‡¶Æ‡ßÇ‡¶≤ ‡¶ï‡¶•‡¶æ:** ‡¶Ø‡¶§ ‡¶¨‡ßá‡¶∂‡¶ø practice ‡¶ï‡¶∞‡¶¨‡ßá‡¶®, ‡¶§‡¶§ ‡¶≠‡¶æ‡¶≤ ‡¶π‡¶¨‡ßá‡¶®! 

*"Algorithm analysis ‡¶ï‡¶∞‡¶æ ‡¶è‡¶ï‡¶ü‡¶æ skill - ‡¶è‡¶ü‡¶æ practice ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá improve ‡¶π‡¶Ø‡¶º!"* üéØ
