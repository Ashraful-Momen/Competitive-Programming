
---

# 📝 Connected Components in a Grid (DFS)

We are solving **LeetCode 200: Number of Islands**.
Here, a grid of `'1'` (land) and `'0'` (water) is given.
Each connected group of `'1'` (up, down, left, right) forms an **island** → one connected component.

---

## 🔹 Algorithm Intuition

1. **Traversal idea**

   * Visit every cell in the grid.
   * When we find a `'1'` (land), we **launch DFS** from it.
   * DFS will “sink” the entire connected component by marking visited cells as `'#'`.
   * Increase island count by `1`.

2. **DFS meaning here**

   * DFS explores in **4 directions** (top, bottom, left, right).
   * If neighbor is also `'1'`, we recursively explore it.
   * This way, the whole island gets marked.

3. **End result**

   * Every time we start a new DFS, we discover a **new island (connected component)**.
   * Answer = number of DFS calls started.

---

## 🔹 Code Walkthrough

### DFS Function

```cpp
void dfs (int x, int y, int n, int m, vector<vector<char>>& grid) {
    grid[x][y] = '#';  // mark as visited (sink land)

    int dx[] = {1, -1, 0, 0}; // row moves
    int dy[] = {0, 0, 1, -1}; // col moves

    for ( int i = 0; i < 4; i++ ) {
        int nx = x + dx[i];
        int ny = y + dy[i];

        // check bounds + land cell
        if ( nx >= 0 && ny >= 0 && nx < n && ny < m && grid[nx][ny] == '1') {
            dfs ( nx, ny, n, m, grid );
        }
    }
}
```

* Marks `(x,y)` visited.
* Explores **neighbors** recursively.

---

### Main Function

```cpp
int numIslands(vector<vector<char>>& grid) {
    int n = grid.size();
    int m = grid[0].size();

    int ans = 0;
    for ( int x = 0; x < n; x++ ) {
        for ( int y = 0; y < m; y++ ) {
            if ( grid[x][y] == '1' ) {
                ans++;              // new island found
                dfs ( x, y, n, m, grid ); // explore & sink it
            }
        }
    }

    return ans;
}
```

* Loops through all cells.
* Each `'1'` not yet visited starts a **new DFS** → new island.
* Answer = number of DFS launches.

---

## 🔹 Dry Run Example

### Input Grid

```
grid = [
  ['1','1','0','0'],
  ['1','0','0','1'],
  ['0','0','1','1'],
  ['0','0','0','1']
]
```

### Step 1

* Start at `(0,0)` → land → **island #1**
* DFS explores `(0,1)` and `(1,0)`
  Grid after DFS:

```
[# # 0 0]
[# 0 0 1]
[0 0 1 1]
[0 0 0 1]
```

---

### Step 2

* Next land `(1,3)` → **island #2**
  DFS explores `(2,3), (2,2), (3,3)`
  Grid after DFS:

```
[# # 0 0]
[# 0 0 #]
[0 0 # #]
[0 0 0 #]
```

---

### Step 3

* No more `'1'`.
* **Answer = 2 islands (connected components).**

---

## 🔹 Complexity

* **Time:** `O(N*M)` → each cell visited once.
* **Space:** `O(N*M)` in recursion stack (worst case: whole grid is land).

---

## 🔹 Real-world Use Cases

This "connected components with DFS" idea is used in:

1. **Image segmentation** → detect shapes in pictures.
2. **Cluster detection** → find groups in networks/social graphs.
3. **Game maps** → flood-fill for areas.
4. **Geography problems** → counting islands, lakes, forests, etc.

---

✅ So this algorithm = **DFS to find number of connected components in a 2D grid**.
It’s exactly the same idea as **connected components in a graph using adjacency list**, just applied to a **matrix graph**.

---
