Perfect! This is **LeetCode 733: Flood Fill**. Let‚Äôs make a **node/tree style diagram** to visualize how DFS works here. I‚Äôll also give a structured explanation similar to your previous notes.

---

# üìù Flood Fill (DFS)

We are given a 2D image represented as a **matrix of colors**, and a starting pixel `(sr, sc)`.
The goal is to **change the color of the starting pixel and all connected pixels with the same original color** to a new color.

---

## üîπ Algorithm Intuition

1. **DFS idea**

   * Start at `(sr, sc)` (the starting pixel).
   * Remember its original color `prevColor`.
   * Change its color to the new color.
   * Recursively explore neighbors **up, down, left, right** that have the same original color.

2. **End result**

   * All connected pixels with the original color are replaced by the new color.

---

## üîπ Code Walkthrough

### DFS Function

```cpp
void dfs (int x, int y, int n, int m, int color, vector<vector<int>>& image) {
    int prevColor = image[x][y];
    image[x][y] = color;

    int dx[] = {1, -1, 0, 0};
    int dy[] = {0, 0, 1, -1};

    for ( int i = 0; i < 4; i++ ) {
        int nx = x + dx[i];
        int ny = y + dy[i];

        if( nx >= 0 && ny >= 0 && nx < n && ny < m && image[nx][ny] == prevColor ) {
            dfs ( nx, ny, n, m, color, image );
        }
    }
}
```

### Main Function

```cpp
vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {
    int n = image.size();
    int m = image[0].size();

    if(image[sr][sc] != color) {
        dfs ( sr, sc, n, m, color, image );
    }

    return image;
}
```

* Only start DFS if the starting pixel is not already the target color.
* DFS explores **all connected pixels of the same color**.

---

## üîπ Dry Run Example

### Input

```
image = [
  [1,1,1],
  [1,1,0],
  [1,0,1]
]
sr = 1, sc = 1, color = 2
```

Original image:

```
1 1 1
1 1 0
1 0 1
```

---

### Step 1: Start DFS at (1,1)

* Original color = `1`
* Change `(1,1)` ‚Üí `2`
* Explore neighbors `(0,1),(2,1),(1,0),(1,2)` with original color `1`.

---

### Step 2: DFS explores `(0,1)`

* Change `(0,1)` ‚Üí `2`
* Explore neighbors with original color `1`: `(0,0),(0,2),(1,1)`

---

### Step 3: DFS explores `(0,0)` and `(0,2)`

* Change them ‚Üí `2`
* Explore neighbors recursively

---

### Step 4: DFS explores `(1,0)` and `(2,0)`

* Change them ‚Üí `2`

---

### Step 5: Pixels with color `0` are skipped.

Final image:

```
2 2 2
2 2 0
2 0 1
```

---

## üîπ Graph Tree (DFS Exploration Visualization)

Starting DFS from `(1,1)`:

```
         (1,1)
        /  |  \  \
   (0,1) (2,1) (1,0) (1,2)
    / \          \
(0,0)(0,2)      (2,0)
```

* Only nodes with the **same original color** are explored.
* Nodes with different colors (`0` or already changed) are **not visited**.

---

## üîπ Complexity

* **Time:** `O(N*M)` ‚Üí each pixel visited at most once
* **Space:** `O(N*M)` recursion stack in worst case (whole image same color)

---

## üîπ Use Cases

1. **Image editing software** ‚Üí paint bucket tool.
2. **Game maps** ‚Üí flood-fill areas (like ‚Äúfill water‚Äù or ‚Äúterritory coloring‚Äù).
3. **Graph problems** ‚Üí same DFS principle as islands or provinces.

---

‚úÖ Key Idea:

> Flood fill is just **DFS on a 2D grid**, where you explore **all connected pixels of the same value** and mark them with a new value.

---

If you want, I can also **draw a full ASCII-style node/tree traversal for a 3x3 or 4x4 image**, showing exactly **step by step how DFS explores each pixel**, just like the islands/provinces trees.

Do you want me to do that?
