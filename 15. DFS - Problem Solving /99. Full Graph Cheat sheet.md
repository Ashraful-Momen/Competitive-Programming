# Complete Graph Algorithms Cheat Sheet

## ðŸ”¹ Quick Reference Index
1. [Graph Input/Output Templates](#graph-inputoutput-templates)
2. [Graph Representations](#graph-representations)
3. [Graph Traversals](#graph-traversals)
4. [Connected Components](#connected-components)
5. [Path Finding](#path-finding)
6. [Cycle Detection](#cycle-detection)
7. [Shortest Path Algorithms](#shortest-path-algorithms)
8. [Tree Algorithms](#tree-algorithms)
9. [Complexity Reference](#complexity-reference)

---

## ðŸ”¹ Graph Input/Output Templates

### **Standard Input Format**
```
n m          // n = nodes, m = edges
u1 v1        // edge 1
u2 v2        // edge 2
...
um vm        // edge m
```

### **1. Unweighted Graph Input**
```cpp
int n, m;
cin >> n >> m;
vector<vector<int>> adj(n + 1);

for (int i = 0; i < m; i++) {
    int u, v;
    cin >> u >> v;
    adj[u].push_back(v);
    adj[v].push_back(u);  // Remove for directed
}
```

### **2. Weighted Graph Input**
```cpp
int n, m;
cin >> n >> m;
vector<vector<pair<int, int>>> adj(n + 1);  // {neighbor, weight}

for (int i = 0; i < m; i++) {
    int u, v, w;
    cin >> u >> v >> w;
    adj[u].push_back({v, w});
    adj[v].push_back({u, w});  // Remove for directed
}
```

### **3. Adjacency Matrix Input**
```cpp
int n;
cin >> n;
vector<vector<int>> adj(n + 1, vector<int>(n + 1, 0));

for (int i = 0; i < m; i++) {
    int u, v;
    cin >> u >> v;
    adj[u][v] = 1;
    adj[v][u] = 1;  // Remove for directed
}
```

---

## ðŸ”¹ Graph Representations

### **Adjacency List vs Matrix**
| Operation | Adjacency List | Adjacency Matrix |
|-----------|----------------|------------------|
| Space | O(V + E) | O(VÂ²) |
| Add edge | O(1) | O(1) |
| Check edge | O(degree) | O(1) |
| Get neighbors | O(degree) | O(V) |
| Best for | Sparse graphs | Dense graphs |

### **Adjacency List (Recommended)**
```cpp
vector<vector<int>> adj(n + 1);           // Unweighted
vector<vector<pair<int,int>>> adj(n + 1); // Weighted {node, weight}
vector<vector<pair<int,int>>> adj(n + 1); // Edge list {to, weight}
```

### **Adjacency Matrix**
```cpp
vector<vector<int>> adj(n + 1, vector<int>(n + 1, 0));     // Unweighted
vector<vector<int>> adj(n + 1, vector<int>(n + 1, INF));   // Weighted
```

---

## ðŸ”¹ Graph Traversals

### **1. DFS (Depth First Search)**
```cpp
vector<bool> visited(n + 1, false);

void dfs(int u) {
    visited[u] = true;
    cout << u << " ";
    
    for (int v : adj[u]) {
        if (!visited[v]) {
            dfs(v);
        }
    }
}

// Usage: dfs(1);
```

### **2. BFS (Breadth First Search)**
```cpp
vector<bool> visited(n + 1, false);

void bfs(int start) {
    queue<int> q;
    q.push(start);
    visited[start] = true;
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        cout << u << " ";
        
        for (int v : adj[u]) {
            if (!visited[v]) {
                visited[v] = true;
                q.push(v);
            }
        }
    }
}
```

### **3. Grid DFS (4-directions)**
```cpp
int dx[] = {-1, 1, 0, 0};  // up, down, right, left
int dy[] = {0, 0, 1, -1};

void dfs(int x, int y, vector<vector<int>>& grid) {
    int n = grid.size(), m = grid[0].size();
    grid[x][y] = -1;  // Mark visited
    
    for (int i = 0; i < 4; i++) {
        int nx = x + dx[i];
        int ny = y + dy[i];
        
        if (nx >= 0 && ny >= 0 && nx < n && ny < m && grid[nx][ny] == 1) {
            dfs(nx, ny, grid);
        }
    }
}
```

---

## ðŸ”¹ Connected Components

### **1. Count Connected Components**
```cpp
int countComponents() {
    vector<bool> visited(n + 1, false);
    int components = 0;
    
    for (int i = 1; i <= n; i++) {
        if (!visited[i]) {
            components++;
            dfs(i);  // Explore entire component
        }
    }
    return components;
}
```

### **2. Find Component Sizes**
```cpp
vector<int> componentSize;

int dfsSize(int u, vector<bool>& visited) {
    visited[u] = true;
    int size = 1;
    
    for (int v : adj[u]) {
        if (!visited[v]) {
            size += dfsSize(v, visited);
        }
    }
    return size;
}

void findComponentSizes() {
    vector<bool> visited(n + 1, false);
    
    for (int i = 1; i <= n; i++) {
        if (!visited[i]) {
            int size = dfsSize(i, visited);
            componentSize.push_back(size);
        }
    }
}
```

### **3. Check if Two Nodes Connected**
```cpp
bool areConnected(int start, int target) {
    vector<bool> visited(n + 1, false);
    queue<int> q;
    q.push(start);
    visited[start] = true;
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        
        if (u == target) return true;
        
        for (int v : adj[u]) {
            if (!visited[v]) {
                visited[v] = true;
                q.push(v);
            }
        }
    }
    return false;
}
```

---

## ðŸ”¹ Path Finding

### **1. Check if Path Exists (DFS)**
```cpp
bool hasPath(int start, int end, vector<bool>& visited) {
    if (start == end) return true;
    
    visited[start] = true;
    for (int neighbor : adj[start]) {
        if (!visited[neighbor]) {
            if (hasPath(neighbor, end, visited)) {
                return true;
            }
        }
    }
    return false;
}
```

### **2. Find Shortest Path (BFS)**
```cpp
vector<int> shortestPath(int start, int end) {
    vector<int> dist(n + 1, -1);
    vector<int> parent(n + 1, -1);
    queue<int> q;
    
    q.push(start);
    dist[start] = 0;
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        
        if (u == end) break;
        
        for (int v : adj[u]) {
            if (dist[v] == -1) {
                dist[v] = dist[u] + 1;
                parent[v] = u;
                q.push(v);
            }
        }
    }
    
    // Reconstruct path
    vector<int> path;
    if (dist[end] == -1) return path;  // No path
    
    int curr = end;
    while (curr != -1) {
        path.push_back(curr);
        curr = parent[curr];
    }
    reverse(path.begin(), path.end());
    return path;
}
```

### **3. All Paths from Source to Target**
```cpp
vector<vector<int>> allPaths;

void findAllPaths(int current, int target, vector<int>& path, vector<bool>& visited) {
    path.push_back(current);
    visited[current] = true;
    
    if (current == target) {
        allPaths.push_back(path);
    } else {
        for (int neighbor : adj[current]) {
            if (!visited[neighbor]) {
                findAllPaths(neighbor, target, path, visited);
            }
        }
    }
    
    // Backtrack
    path.pop_back();
    visited[current] = false;
}
```

---

## ðŸ”¹ Cycle Detection

### **1. Undirected Graph (DFS)**
```cpp
bool hasCycleDFS(int u, int parent, vector<bool>& visited) {
    visited[u] = true;
    
    for (int v : adj[u]) {
        if (!visited[v]) {
            if (hasCycleDFS(v, u, visited)) return true;
        } else if (v != parent) {
            return true;  // Back edge found
        }
    }
    return false;
}

bool hasCycle() {
    vector<bool> visited(n + 1, false);
    for (int i = 1; i <= n; i++) {
        if (!visited[i]) {
            if (hasCycleDFS(i, -1, visited)) return true;
        }
    }
    return false;
}
```

### **2. Directed Graph (DFS)**
```cpp
bool hasCycleDirected(int u, vector<int>& color) {
    color[u] = 1;  // Gray (processing)
    
    for (int v : adj[u]) {
        if (color[v] == 1) return true;  // Back edge
        if (color[v] == 0 && hasCycleDirected(v, color)) return true;
    }
    
    color[u] = 2;  // Black (processed)
    return false;
}

bool hasCycleDirected() {
    vector<int> color(n + 1, 0);  // 0=white, 1=gray, 2=black
    for (int i = 1; i <= n; i++) {
        if (color[i] == 0) {
            if (hasCycleDirected(i, color)) return true;
        }
    }
    return false;
}
```

---

## ðŸ”¹ Shortest Path Algorithms

### **1. Dijkstra's Algorithm (Single Source)**
```cpp
vector<int> dijkstra(int start) {
    vector<int> dist(n + 1, INT_MAX);
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
    
    dist[start] = 0;
    pq.push({0, start});  // {distance, node}
    
    while (!pq.empty()) {
        int d = pq.top().first;
        int u = pq.top().second;
        pq.pop();
        
        if (d > dist[u]) continue;
        
        for (auto& edge : adj[u]) {
            int v = edge.first;
            int w = edge.second;
            
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
    return dist;
}
```

### **2. Floyd-Warshall (All Pairs)**
```cpp
void floydWarshall() {
    vector<vector<int>> dist(n + 1, vector<int>(n + 1, INT_MAX));
    
    // Initialize
    for (int i = 1; i <= n; i++) dist[i][i] = 0;
    for (int u = 1; u <= n; u++) {
        for (auto& edge : adj[u]) {
            int v = edge.first;
            int w = edge.second;
            dist[u][v] = w;
        }
    }
    
    // Floyd-Warshall
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX) {
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }
    }
}
```

### **3. Bellman-Ford (Negative Edges)**
```cpp
vector<int> bellmanFord(int start) {
    vector<int> dist(n + 1, INT_MAX);
    dist[start] = 0;
    
    // Relax edges n-1 times
    for (int i = 0; i < n - 1; i++) {
        for (int u = 1; u <= n; u++) {
            if (dist[u] == INT_MAX) continue;
            for (auto& edge : adj[u]) {
                int v = edge.first;
                int w = edge.second;
                if (dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                }
            }
        }
    }
    
    // Check for negative cycles
    for (int u = 1; u <= n; u++) {
        if (dist[u] == INT_MAX) continue;
        for (auto& edge : adj[u]) {
            int v = edge.first;
            int w = edge.second;
            if (dist[u] + w < dist[v]) {
                // Negative cycle detected
                return {};
            }
        }
    }
    
    return dist;
}
```

---

## ðŸ”¹ Tree Algorithms

### **1. Tree Center**
```cpp
vector<int> findTreeCenter() {
    if (n == 1) return {1};
    
    vector<int> degree(n + 1);
    for (int i = 1; i <= n; i++) {
        degree[i] = adj[i].size();
    }
    
    queue<int> leaves;
    for (int i = 1; i <= n; i++) {
        if (degree[i] == 1) {
            leaves.push(i);
        }
    }
    
    int remaining = n;
    while (remaining > 2) {
        int leafCount = leaves.size();
        remaining -= leafCount;
        
        for (int i = 0; i < leafCount; i++) {
            int leaf = leaves.front();
            leaves.pop();
            
            for (int neighbor : adj[leaf]) {
                degree[neighbor]--;
                if (degree[neighbor] == 1) {
                    leaves.push(neighbor);
                }
            }
        }
    }
    
    vector<int> centers;
    while (!leaves.empty()) {
        centers.push_back(leaves.front());
        leaves.pop();
    }
    return centers;
}
```

### **2. Tree Diameter**
```cpp
pair<int, int> bfsFarthest(int start) {
    vector<int> dist(n + 1, -1);
    queue<int> q;
    q.push(start);
    dist[start] = 0;
    
    int farthest = start, maxDist = 0;
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        
        for (int v : adj[u]) {
            if (dist[v] == -1) {
                dist[v] = dist[u] + 1;
                q.push(v);
                if (dist[v] > maxDist) {
                    maxDist = dist[v];
                    farthest = v;
                }
            }
        }
    }
    
    return {farthest, maxDist};
}

int treeDiameter() {
    auto [node1, _] = bfsFarthest(1);
    auto [node2, diameter] = bfsFarthest(node1);
    return diameter;
}
```

---

## ðŸ”¹ Complexity Reference

| Algorithm | Time | Space | Use Case |
|-----------|------|-------|----------|
| DFS/BFS | O(V + E) | O(V) | Traversal, Components |
| Dijkstra | O((V + E) log V) | O(V) | Shortest path (non-negative) |
| Bellman-Ford | O(VE) | O(V) | Shortest path (negative edges) |
| Floyd-Warshall | O(VÂ³) | O(VÂ²) | All pairs shortest path |
| Topological Sort | O(V + E) | O(V) | DAG ordering |
| Union-Find | O(Î±(n)) | O(V) | Connected components |

---

## ðŸ”¹ Common Problem Patterns

### **1. Grid Problems**
```cpp
// Standard grid DFS/BFS
int dx[] = {-1, 1, 0, 0};
int dy[] = {0, 0, 1, -1};

// 8-directional
int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};
int dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};
```

### **2. Tree Problems**
- **Root to leaf paths:** DFS with path tracking
- **Level order:** BFS
- **Subtree problems:** DFS with return values

### **3. Graph Coloring (Bipartite Check)**
```cpp
bool isBipartite() {
    vector<int> color(n + 1, -1);
    
    for (int i = 1; i <= n; i++) {
        if (color[i] == -1) {
            queue<int> q;
            q.push(i);
            color[i] = 0;
            
            while (!q.empty()) {
                int u = q.front();
                q.pop();
                
                for (int v : adj[u]) {
                    if (color[v] == -1) {
                        color[v] = 1 - color[u];
                        q.push(v);
                    } else if (color[v] == color[u]) {
                        return false;
                    }
                }
            }
        }
    }
    return true;
}
```

---

## ðŸ”¹ Quick Templates

### **Basic Graph Setup**
```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m;
vector<vector<int>> adj;
vector<bool> visited;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    cin >> n >> m;
    adj.resize(n + 1);
    visited.resize(n + 1, false);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    // Your algorithm here
    
    return 0;
}
```

### **Grid Problem Setup**
```cpp
int n, m;
vector<vector<int>> grid;
int dx[] = {-1, 1, 0, 0};
int dy[] = {0, 0, 1, -1};

bool isValid(int x, int y) {
    return x >= 0 && y >= 0 && x < n && y < m;
}
```

---

**ðŸŽ¯ Remember:** Practice these patterns on problems like:
- Number of Islands, Connected Components
- Shortest Path in Grid, Word Ladder  
- Course Schedule, Alien Dictionary
- Network Delay Time, Cheapest Flights
