This is the **LeetCode 547: Number of Provinces** problem — it’s the **graph version of “Number of Islands”**.
---

# 📝 Connected Components in a Graph (Adjacency Matrix, DFS)

We are given a graph in the form of an **adjacency matrix**:

* `isConnected[i][j] = 1` → there is an edge between city `i` and city `j`.
* `isConnected[i][j] = 0` → no edge.

We need to find the number of **connected components (provinces)** in the graph.

---

## 🔹 Graph Example

Input:

```
isConnected = [
  [1,1,0],
  [1,1,0],
  [0,0,1]
]
```

Graph visualization:

```
   City 0 ----- City 1      City 2
       \__________↑
```

* `City 0` and `City 1` are connected (same province).
* `City 2` is isolated (separate province).

---

## 🔹 Algorithm Intuition

1. **Graph representation**

   * Cities = **nodes**.
   * Roads = **edges**.
   * `isConnected` is an adjacency matrix.

2. **DFS idea**

   * Start DFS from each unvisited city.
   * Visit all cities reachable from it.
   * Mark them visited.

3. **Counting provinces**

   * Each time you launch a new DFS → found a new province.

---

## 🔹 DFS Function

```cpp
void dfs (int u, vector<bool> &isVisited, int n, vector<vector<int>>& isConnected) {
    isVisited[u] = 1; // mark city as visited

    // explore neighbors
    for (int v = 0; v < n; v++) {
        if (isConnected[u][v] == 1 && isVisited[v] == 0) {
            dfs(v, isVisited, n, isConnected);
        }
    }
}
```

---

## 🔹 Main Function

```cpp
int findCircleNum(vector<vector<int>>& isConnected) {
    int n = isConnected.size();
    vector<bool> isVisited(n, 0);

    int ans = 0;
    for (int i = 0; i < n; i++) {
        if (isVisited[i] == 0) {
            ans++;                       // found new province
            dfs(i, isVisited, n, isConnected);
        }
    }
    return ans;
}
```

---

## 🔹 Dry Run Walkthrough

1. Start with `City 0` → not visited → Province count = 1.

   * DFS(0) visits `City 0` and `City 1`.

Visited status after DFS(0):

```
[1, 1, 0]
```

2. `City 1` already visited → skip.

3. `City 2` not visited → new Province → Province count = 2.

Visited status after DFS(2):

```
[1, 1, 1]
```

✅ Answer = **2 Provinces**

---

## 🔹 Complexity

* **Time:** `O(n^2)` (check all matrix entries).
* **Space:** `O(n)` (visited array + recursion stack).

---

## 🔹 Real-world Use Cases

* **Social Networks** → Find disconnected friend groups.
* **Network Topology** → Detect isolated subnetworks.
* **Transport Systems** → Identify independent clusters of connected cities.
* **Clustering** → Separate communities.

---

👉 So this is exactly the **graph/tree version of the Islands problem**.

* **Islands = grid DFS** 🏝️
* **Provinces = graph DFS** 🏙️

---
