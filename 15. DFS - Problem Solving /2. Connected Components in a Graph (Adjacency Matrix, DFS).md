This is the **LeetCode 547: Number of Provinces** problem â€” itâ€™s the **graph version of â€œNumber of Islandsâ€**.
---

# ğŸ“ Connected Components in a Graph (Adjacency Matrix, DFS)

We are given a graph in the form of an **adjacency matrix**:

* `isConnected[i][j] = 1` â†’ there is an edge between city `i` and city `j`.
* `isConnected[i][j] = 0` â†’ no edge.

We need to find the number of **connected components (provinces)** in the graph.

---

## ğŸ”¹ Graph Example

Input:

```
isConnected = [
  [1,1,0],
  [1,1,0],
  [0,0,1]
]
```

Graph visualization:

```
   City 0 ----- City 1      City 2
       \__________â†‘
```

* `City 0` and `City 1` are connected (same province).
* `City 2` is isolated (separate province).

---

## ğŸ”¹ Algorithm Intuition

1. **Graph representation**

   * Cities = **nodes**.
   * Roads = **edges**.
   * `isConnected` is an adjacency matrix.

2. **DFS idea**

   * Start DFS from each unvisited city.
   * Visit all cities reachable from it.
   * Mark them visited.

3. **Counting provinces**

   * Each time you launch a new DFS â†’ found a new province.

---

## ğŸ”¹ DFS Function

```cpp
void dfs (int u, vector<bool> &isVisited, int n, vector<vector<int>>& isConnected) {
    isVisited[u] = 1; // mark city as visited

    // explore neighbors
    for (int v = 0; v < n; v++) {
        if (isConnected[u][v] == 1 && isVisited[v] == 0) {
            dfs(v, isVisited, n, isConnected);
        }
    }
}
```

---

## ğŸ”¹ Main Function

```cpp
int findCircleNum(vector<vector<int>>& isConnected) {
    int n = isConnected.size();
    vector<bool> isVisited(n, 0);

    int ans = 0;
    for (int i = 0; i < n; i++) {
        if (isVisited[i] == 0) {
            ans++;                       // found new province
            dfs(i, isVisited, n, isConnected);
        }
    }
    return ans;
}
```

---

## ğŸ”¹ Dry Run Walkthrough

1. Start with `City 0` â†’ not visited â†’ Province count = 1.

   * DFS(0) visits `City 0` and `City 1`.

Visited status after DFS(0):

```
[1, 1, 0]
```

2. `City 1` already visited â†’ skip.

3. `City 2` not visited â†’ new Province â†’ Province count = 2.

Visited status after DFS(2):

```
[1, 1, 1]
```

âœ… Answer = **2 Provinces**

---

## ğŸ”¹ Complexity

* **Time:** `O(n^2)` (check all matrix entries).
* **Space:** `O(n)` (visited array + recursion stack).

---

## ğŸ”¹ Real-world Use Cases

* **Social Networks** â†’ Find disconnected friend groups.
* **Network Topology** â†’ Detect isolated subnetworks.
* **Transport Systems** â†’ Identify independent clusters of connected cities.
* **Clustering** â†’ Separate communities.

---

ğŸ‘‰ So this is exactly the **graph/tree version of the Islands problem**.

* **Islands = grid DFS** ğŸï¸
* **Provinces = graph DFS** ğŸ™ï¸

---
