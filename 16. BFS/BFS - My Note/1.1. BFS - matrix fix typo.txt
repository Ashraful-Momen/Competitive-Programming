#algorithm : (BFS)
-----------

int main(){

    // suppose , grid = {{1,2,3},{4,5,6},{7,8,9},{10,11,12},{13,14,15}}
    // This is a 5x3 grid → 5 rows, 3 columns
    // We treat each cell as a node. Total nodes = 15, but arranged in grid.

    vector<vector<int>> grid = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9},
        {10,11,12},
        {13,14,15}
    };

    // step 1: find out row (number of nodes in vertical) and col (horizontal)
    int n = grid.size();          // total rows = 5
    int m = grid[0].size();       // total columns = 3

    // step 2: we have to start traversal from a node. Source node is value = 1 → at (0,0)
    pair<int,int> s;
    s.first = 0;    // x = row index
    s.second = 0;   // y = col index
    // So, node '1' is at s = (0,0)

    // step 3: Declare level matrix, same size as grid, initialize all to -1
    vector<vector<int>> level(n, vector<int>(m, -1));
    // So the level looks like:
    // -------------------------
    //      col0 col1 col2
    // row0 [ -1  -1  -1 ]
    // row1 [ -1  -1  -1 ]
    // row2 [ -1  -1  -1 ]
    // row3 [ -1  -1  -1 ]
    // row4 [ -1  -1  -1 ]

    // step 4: initialize the source node level to 0
    level[s.first][s.second] = 0;  // level[0][0] = 0

    // step 5: declare queue (stores coordinates like source)
    queue<pair<int,int>> q;

    // step 6: push source node to queue
    q.push(s);  // q now has (0,0)

    // step 7: declare dx and dy for 4-directional movement (up, down, left, right)
    int dx[4] = {+1, -1, 0, 0};   // row changes
    int dy[4] = {0, 0, +1, -1};   // col changes

    // step 8: run while loop until queue is empty
    while (!q.empty())  // ⚠️ Fix: condition should be !q.empty()
    {
        // step 9: store front of queue in 'u'
        pair<int,int> u = q.front();  // u = (x, y)

        // step 11: pop the front
        q.pop();

        int x = u.first;
        int y = u.second;

        // step 12: loop over 4 directions
        for (int i = 0; i < 4; i++)  // ⚠️ Fix: proper for-loop syntax
        {
            int nx = x + dx[i];   // ⚠️ Fix: use dx[i], not d[i]
            int ny = y + dy[i];   // ⚠️ Fix: use dy[i]

            // step 13: check boundary and visit condition
            // Note: In your grid, all cells are valid (no obstacles like 0).
            // But if you want to treat all cells as traversable, just check bounds and unvisited.
            if (nx >= 0 && ny >= 0 && nx < n && ny < m && level[nx][ny] == -1)
            {
                // step 14: set level of neighbor
                level[nx][ny] = level[x][y] + 1;

                // step 15: push neighbor to queue
                q.push({nx, ny});
            }
        }
    }

    // Now, 'level' contains shortest distance (in steps) from node 1 (0,0) to every cell.
    return 0;
}
