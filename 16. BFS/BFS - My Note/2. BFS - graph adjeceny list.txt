#algorithm : (BFS on Nodes and Edges - Adjacency List)
-----------
the graph: 
------------

Level 0:        1
               / \
Level 1:      2   4
              |   |
Level 2:      3   5
                  |
Level 3:          6


#matrix form of the graph : 
---------------------------
adj[1] = {2, 4}
adj[2] = {1, 3}
adj[3] = {2}
adj[4] = {1, 5}
adj[5] = {4, 6}
adj[6] = {5}


// code start from here : ___________________________________


int main(){

    // suppose , we have a graph with 7 nodes and 8 edges
    // Edges are: 
    // 1-2, 1-4, 2-3, 3-5, 5-6, 6-7, 2-7, 4-5

    // step 1: declare adjacency list (global or inside main with size)
    vector<int> adj[100];   // adj[1] to adj[7] will be used (1-indexed)

    // step 2: take input for node and edge
    int n = 7;    // total nodes
    int m = 8;    // total edges

    // step 3: build the undirected graph using adjacency list
    for ( int i = 1; i <= m; i++ ) {
        int u, v;
        cin >> u >> v;

        // undirected → add both directions
        adj[u].push_back(v);   // u --> v
        adj[v].push_back(u);   // v --> u
    }

    // step 4: declare level array (size = n+1), initialize all with -1 (unvisited)
    vector<int> level(n+1, -1);
    // so level looks like:
    // index: 0  1  2  3  4  5  6  7
    //        ? -1 -1 -1 -1 -1 -1 -1   (index 0 unused)

    // step 5: source node is 1 (start BFS from node 1)
    int source = 1;

    // step 6: set level of source node to 0
    level[source] = 0;

    // step 7: declare queue for BFS (stores node numbers)
    queue<int> q;

    // step 8: push source node into queue
    q.push(source);   // q = [1]

    // step 9: run BFS until queue is empty
    while ( !q.empty() ) {

        // step 10: take front node as 'u' (current node)
        int u = q.front();

        // step 11: remove front node from queue
        q.pop();

        // step 12: traverse all neighbors of 'u'
        for ( auto v : adj[u] ) {   // v = each connected node

            // step 13: check if neighbor 'v' is unvisited (level == -1)
            if ( level[v] == -1 ) {

                // step 14: assign level to 'v' → parent level + 1
                level[v] = level[u] + 1;

                // step 15: push 'v' into queue for next level traversal
                q.push(v);
            }
        }
    }

    // step 16: print level of each node
    for ( int i = 1; i <= n; i++ ) {
        cout << i << " : " << level[i] << endl;
    }

    return 0;
}

output : 
------------
1 : 0
2 : 1
3 : 2
4 : 1
5 : 2
6 : 3
7 : 2
