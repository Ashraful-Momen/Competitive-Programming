Perfect 👍 You want the same **note style** but for **BFS on a grid** (matrix/maze).
Here’s a polished version in the same style as your graph BFS notes:

---

# 📌 BFS on Grid (Matrix) — Notes

**Concept:**
👉 BFS is widely used for **shortest path in grids/mazes**.
👉 Each cell is like a **graph node**.
👉 Neighbors = up, down, left, right (4-direction) or sometimes 8-direction (includes diagonals).
👉 Works level-by-level, ensuring the **shortest distance in unweighted grid**.

---

## 🔑 Core Idea

1. Start from a **source cell `(sx, sy)`**.
2. Put it into a **queue** and mark as visited.
3. While queue is not empty:

   * Pop a cell `(x, y)`.
   * For each valid unvisited neighbor `(nx, ny)`:

     * Mark visited
     * Set `dist[nx][ny] = dist[x][y] + 1`
     * Push `(nx, ny)` into the queue.
4. Repeat until queue is empty (or destination reached).

---

## 🧩 ASCII Example (Grid BFS)

Grid (5x5), `S = start`, `# = wall`, `.` = free cell:

```
S . . # .
. # . . .
. # . # .
. . . # .
. # . . E
```

👉 BFS expands in **waves (levels)**:

```
Level 0: S
Level 1: neighbors of S
Level 2: neighbors of Level 1
...
```

BFS guarantees the **shortest path** from `S` to `E`.

---

## ⚙️ BFS Algorithm (Grid)

👉 Each grid cell `(x,y)` is treated as a graph node.
👉 Valid move = within bounds & not a wall & not visited.
👉 Use arrays `dx, dy` for 4 directions:

```cpp
int dx[4] = {-1, 1, 0, 0}; // up, down, left, right
int dy[4] = {0, 0, -1, 1};
```

---

## ✅ BFS Code (C++ for Grid Shortest Path)

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Cell {
    int x, y;
};

int bfs_grid(vector<string>& grid, int sx, int sy, int ex, int ey) {
    int n = grid.size();
    int m = grid[0].size();

    vector<vector<int>> dist(n, vector<int>(m, -1));
    queue<Cell> q;

    // start
    q.push({sx, sy});
    dist[sx][sy] = 0;

    int dx[4] = {-1, 1, 0, 0};
    int dy[4] = {0, 0, -1, 1};

    while (!q.empty()) {
        auto cur = q.front(); q.pop();
        int x = cur.x, y = cur.y;

        // reached destination
        if (x == ex && y == ey) return dist[x][y];

        for (int dir = 0; dir < 4; dir++) {
            int nx = x + dx[dir];
            int ny = y + dy[dir];

            // check valid
            if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                if (grid[nx][ny] != '#' && dist[nx][ny] == -1) {
                    dist[nx][ny] = dist[x][y] + 1;
                    q.push({nx, ny});
                }
            }
        }
    }

    return -1; // unreachable
}

int main() {
    vector<string> grid = {
        "S..#.",
        ".#...",
        ".#.#.",
        "...#.",
        ".#..E"
    };

    int sx=0, sy=0, ex=4, ey=4; // start (0,0), end (4,4)
    int ans = bfs_grid(grid, sx, sy, ex, ey);

    if (ans != -1) cout << "Shortest path length = " << ans << "\n";
    else cout << "No path found\n";

    return 0;
}
```

---

## 📝 Cheatsheet (short recall)

* Treat **each grid cell = node**.
* Neighbors = valid cells in 4 (or 8) directions.
* Use BFS to expand level-by-level.
* `dist[x][y] = shortest distance from start`.
* Time Complexity = **O(N × M)** (N = rows, M = cols).

---

⚡ This is the **grid version of BFS** you can directly use in competitive programming.

👉 Do you also want me to extend this note with **path reconstruction** (not just shortest distance, but the actual path from `S → E`)?
