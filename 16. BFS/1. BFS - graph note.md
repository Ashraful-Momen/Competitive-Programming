
---

# ğŸ“Œ BFS (Breadth/Level First Search) â€” Notes

**Concept:**

ğŸ‘‰ BFS is a graph traversal algorithm that explores vertices **level by level** (like waves).

ğŸ‘‰ Uses a **Queue (FIFO)** to keep track of nodes.

ğŸ‘‰ Always visits all immediate neighbors first before going deeper.

---

## ğŸ”‘ Core Idea

1. Start from a **source node**.
2. Put it into a **queue** and mark as visited.
3. While queue is not empty:

   * Pop the front node.
   * Visit all its unvisited neighbors â†’ push them into the queue.
4. Repeat until queue is empty.

---

## ğŸ§© ASCII Example (Graph)

Graph (undirected):

```
   1     ------------------- > level 0
  / \
 2   3   ------------------- > level 1
 |   |
 4   5   ------------------- > level 2
```

Adjacency list:

```
1 -> [2,3]  
2 -> [1,4]  
3 -> [1,5]  
4 -> [2]  
5 -> [3]  
```

BFS Traversal (start = 1):

```
Queue process:  
Start â†’ [1]  
Pop 1 â†’ Visit â†’ Neighbors (2,3) â†’ Queue = [2,3]  
Pop 2 â†’ Visit â†’ Neighbor (4) â†’ Queue = [3,4]  
Pop 3 â†’ Visit â†’ Neighbor (5) â†’ Queue = [4,5]  
Pop 4 â†’ Visit â†’ Neighbor (none new) â†’ Queue = [5]  
Pop 5 â†’ Visit â†’ Done â†’ Queue = []  

Traversal order: 1, 2, 3, 4, 5
```

---

## âš™ï¸ BFS Algorithm

ğŸ‘‰ Uses Queue + Visited array/list.
ğŸ‘‰ Time Complexity: `O(V + E)` (V = vertices, E = edges).
ğŸ‘‰ Space Complexity: `O(V)` for visited + queue.

---

## âœ… BFS Code (C++)

```cpp
#include <bits/stdc++.h>
using namespace std;

void bfs(int start, vector<vector<int>>& adj, int n) {
    vector<bool> visited(n+1, false);  // visited array
    queue<int> q;                      // queue for BFS

    // step 1: push start node
    q.push(start);
    visited[start] = true;

    cout << "BFS Traversal: ";

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        cout << node << " ";

        // step 2: visit all unvisited neighbors
        for (int neigh : adj[node]) {
            if (!visited[neigh]) {
                q.push(neigh);
                visited[neigh] = true;
            }
        }
    }
    cout << "\n";
}

int main() {
    int n = 5; // number of nodes
    vector<vector<int>> adj(n+1);

    // undirected edges
    adj[1] = {2,3};
    adj[2] = {1,4};
    adj[3] = {1,5};
    adj[4] = {2};
    adj[5] = {3};

    bfs(1, adj, n);  // start BFS from node 1
    return 0;
}
```

---

## ğŸ“ Cheatsheet (short recall)

* **BFS = level order traversal using queue**
* Start â†’ push node â†’ mark visited
* While queue not empty â†’ pop front â†’ push all unvisited neighbors
* Complexity = **O(V+E)**

---
