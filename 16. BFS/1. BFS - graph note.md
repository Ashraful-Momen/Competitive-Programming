
---

# 📌 BFS (Breadth/Level First Search) — Notes

**Concept:**

👉 BFS is a graph traversal algorithm that explores vertices **level by level** (like waves).

👉 Uses a **Queue (FIFO)** to keep track of nodes.

👉 Always visits all immediate neighbors first before going deeper.

---

## 🔑 Core Idea

1. Start from a **source node**.
2. Put it into a **queue** and mark as visited.
3. While queue is not empty:

   * Pop the front node.
   * Visit all its unvisited neighbors → push them into the queue.
4. Repeat until queue is empty.

---

## 🧩 ASCII Example (Graph)

Graph (undirected):

```
   1     ------------------- > level 0
  / \
 2   3   ------------------- > level 1
 |   |
 4   5   ------------------- > level 2
```

Adjacency list:

```
1 -> [2,3]  
2 -> [1,4]  
3 -> [1,5]  
4 -> [2]  
5 -> [3]  
```

BFS Traversal (start = 1):

```
Queue process:  
Start → [1]  
Pop 1 → Visit → Neighbors (2,3) → Queue = [2,3]  
Pop 2 → Visit → Neighbor (4) → Queue = [3,4]  
Pop 3 → Visit → Neighbor (5) → Queue = [4,5]  
Pop 4 → Visit → Neighbor (none new) → Queue = [5]  
Pop 5 → Visit → Done → Queue = []  

Traversal order: 1, 2, 3, 4, 5
```

---

## ⚙️ BFS Algorithm

👉 Uses Queue + Visited array/list.
👉 Time Complexity: `O(V + E)` (V = vertices, E = edges).
👉 Space Complexity: `O(V)` for visited + queue.

---

## ✅ BFS Code (C++)

```cpp
#include <bits/stdc++.h>
using namespace std;

void bfs(int start, vector<vector<int>>& adj, int n) {
    vector<bool> visited(n+1, false);  // visited array
    queue<int> q;                      // queue for BFS

    // step 1: push start node
    q.push(start);
    visited[start] = true;

    cout << "BFS Traversal: ";

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        cout << node << " ";

        // step 2: visit all unvisited neighbors
        for (int neigh : adj[node]) {
            if (!visited[neigh]) {
                q.push(neigh);
                visited[neigh] = true;
            }
        }
    }
    cout << "\n";
}

int main() {
    int n = 5; // number of nodes
    vector<vector<int>> adj(n+1);

    // undirected edges
    adj[1] = {2,3};
    adj[2] = {1,4};
    adj[3] = {1,5};
    adj[4] = {2};
    adj[5] = {3};

    bfs(1, adj, n);  // start BFS from node 1
    return 0;
}
```

---

## 📝 Cheatsheet (short recall)

* **BFS = level order traversal using queue**
* Start → push node → mark visited
* While queue not empty → pop front → push all unvisited neighbors
* Complexity = **O(V+E)**

---
