Got it üëç You want the **same BFS traversal on a grid** but this time **without maintaining the `level` matrix**.
Instead, we‚Äôll just use a **visited matrix** (or directly mark cells in the grid) and carry the **steps in the queue**.

---

## üîπ BFS with Grid (without `level`)

```cpp
#include <bits/stdc++.h>
using namespace std;

#define optimize() ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);

int main()
{
    optimize();

    vector<vector<char>> grid = {
        {'#', '.', '.', '#', '#'},
        {'.', '.', '.', '.', '.'},
        {'.', '.', '.', '.', '#'},
        {'#', '.', '#', '#', '#'},
        {'#', '#', '.', '.', '.'}
    };

    int dx[] = {0, 0, 1, -1};
    int dy[] = {1, -1, 0, 0};

    int n = grid.size();
    int m = grid[0].size();

    // start cell
    pair<int,int> s = {2, 2};

    // queue stores {x, y, steps}
    queue<array<int,3>> q;
    q.push({s.first, s.second, 0});

    // visited matrix
    vector<vector<int>> visited(n, vector<int>(m, 0));
    visited[s.first][s.second] = 1;

    // BFS
    while (!q.empty()) {
        auto cur = q.front(); q.pop();
        int x = cur[0], y = cur[1], steps = cur[2];

        cout << "Visited (" << x << "," << y << ") at distance " << steps << "\n";

        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if(nx >= 0 && nx < n && ny >= 0 && ny < m && 
               grid[nx][ny] == '.' && !visited[nx][ny]) {
                visited[nx][ny] = 1;
                q.push({nx, ny, steps+1});
            }
        }
    }

    return 0;
}
```

---

## üîπ Key Differences from `level` Version

* Instead of storing **distance in a matrix**, we store the **current steps in the queue**.
* We only need a **visited matrix** (or could directly mark the grid as visited).
* The output here will be traversal order + distances printed along the way.

---

## üîπ Example Output (for given grid, start = `(2,2)`)

It will print something like:

```
Visited (2,2) at distance 0
Visited (2,1) at distance 1
Visited (2,3) at distance 1
Visited (1,2) at distance 1
Visited (3,1) at distance 1
Visited (1,1) at distance 2
Visited (1,3) at distance 2
Visited (0,2) at distance 2
...
```

---

‚úÖ This is the **BFS without `level` matrix**.
