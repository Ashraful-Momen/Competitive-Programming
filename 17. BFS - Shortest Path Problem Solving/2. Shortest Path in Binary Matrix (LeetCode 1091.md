
---

## ðŸ”¹ Question

**Shortest Path in Binary Matrix (LeetCode 1091)**

You are given an `n x n` binary matrix `grid`.

* `0` means open cell.
* `1` means blocked cell.

You can move in **8 directions**:

* up, down, left, right
* and diagonals (â†–, â†—, â†™, â†˜).

Find the **shortest path** from **top-left `(0,0)`** to **bottom-right `(n-1,n-1)`**.

ðŸ‘‰ Return the length of the shortest path, or `-1` if no path exists.

---

## ðŸ”¹ Example Input

```text
grid =
[ [0,1],
  [1,0] ]
```

---

## ðŸ”¹ ASCII Graph Representation

```
   0   1
0  S   1
1  1   T

Legend:
S = Start (0,0)
T = Target (n-1,n-1)
0 = open path
1 = blocked
```

---

## ðŸ”¹ Step-by-step Algorithm (BFS in 8 directions)

We use **Breadth First Search** because:

* We need the **minimum number of steps**.
* BFS explores all possible moves **level by level**.

### Algorithm:

1. If `grid[0][0] == 1`, return `-1` (start blocked).
2. If `n == 1` and `grid[0][0] == 0`, return `1` (start = target).
3. Initialize queue with `(0,0,0)` â†’ meaning position `(0,0)` at distance `0`.
4. Mark `(0,0)` as visited (`grid[0][0] = 1`).
5. While queue is not empty:

   * Pop `(x,y,dist)`.
   * Explore all **8 neighbors** `(nx,ny)`.
   * If neighbor is inside grid and `0` (open), push `(nx,ny,dist+1)`.
   * Mark visited (`grid[nx][ny] = 1`).
   * If `(nx,ny) == (n-1,n-1)`, return `dist+1`.
6. If loop ends â†’ no path â†’ return `-1`.

---

## ðŸ”¹ Dry Run on Example

### Input:

```
[ [0,1],
  [1,0] ]
```

### BFS steps:

```
Start (0,0), dist=0
Neighbors: only (1,1) is valid (diagonal).
Push (1,1,1)
```

```
At (1,1), dist=1
This is target (n-1,n-1).
Return dist+1 = 2 âœ…
```

---

## ðŸ”¹ C++ Code Explained

```cpp
class Solution {
public:
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        // 8 directions (including diagonals)
        int dx[] = {+1, -1, 0, 0, -1, +1, -1, +1};
        int dy[] = {0, 0, -1, +1, +1, -1, -1, +1};

        int n = grid.size();

        // If start is blocked
        if(grid[0][0] == 1) return -1;
        // If single cell grid
        if(n == 1) return 1;

        // BFS queue: {x, y, steps}
        queue<vector<int>> q;
        q.push({0, 0, 0});
        grid[0][0] = 1; // Mark visited

        while (!q.empty()) {
            vector<int> cur = q.front(); q.pop();
            int x = cur[0], y = cur[1], dist = cur[2];

            for (int i = 0; i < 8; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];

                // Check inside grid and not visited
                if(nx >= 0 && ny >= 0 && nx < n && ny < n && grid[nx][ny] == 0) {
                    int nextDist = dist + 1;
                    grid[nx][ny] = 1; // Mark visited

                    // If reached target
                    if(nx == n-1 && ny == n-1) {
                        return nextDist + 1;
                    }

                    q.push({nx, ny, nextDist});
                }
            }
        }

        return -1; // No path
    }
};
```

---

## ðŸ”¹ Output Example

### Input:

```
[ [0,1],
  [1,0] ]
```

### ASCII Path:

```
0   1
S   1
1   T

Path: (0,0) â†’ (1,1)
```

### Output:

```
2
```

---

## ðŸ”¹ Another Example

### Input:

```
[ [0,0,0],
  [1,1,0],
  [1,1,0] ]
```

### ASCII:

```
0   0   0
1   1   0
1   1   T
```

Path:
`(0,0) â†’ (0,1) â†’ (0,2) â†’ (1,2) â†’ (2,2)`

Steps = 4 edges â†’ Path length = **4+1 = 5**

Output:

```
5
```

---

âœ… Now you have the **full cycle** again:

1. Question
2. Graph ASCII
3. Step-by-step algorithm
4. Code explained
5. Dry run + Output

---
