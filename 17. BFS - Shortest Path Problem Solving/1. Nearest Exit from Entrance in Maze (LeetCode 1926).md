
---

## ðŸ”¹ Question:

**Nearest Exit from Entrance in Maze (LeetCode 1926)**

You are given a **m x n maze** (2D grid) consisting of empty cells (`"."`) and walls (`"+"`).

* You are also given the **entrance** of the maze, where `entrance = [row, col]`.
* You may move **up, down, left, or right** to an empty cell.
* Your goal is to find the **nearest exit** from the entrance.

An exit is defined as an **empty cell on the border of the maze**.
You **cannot use the entrance itself** as an exit.

ðŸ‘‰ Return the **minimum number of steps** to reach the nearest exit, or `-1` if no exit exists.

---

## ðŸ”¹ Example Input & Graph

```text
Maze:
[ ['+','+','.','+'],
  ['.','.','.','+'],
  ['+','+','+','.'] ]

Entrance: [1,0]
```

### ASCII Graph Representation:

```
   0   1   2   3
0  +   +   .   +
1  E   .   .   +
2  +   +   +   .

Legend:
+ -> Wall
. -> Empty path
E -> Entrance
```

---

## ðŸ”¹ Step-by-step Algorithm (BFS)

We use **Breadth First Search (BFS)** because:

* We want the **shortest path** (minimum steps).
* BFS explores level by level, so the **first time we reach an exit, it's guaranteed to be nearest**.

### Algorithm:

1. Start BFS from `entrance` cell.
2. Maintain a queue with `{x, y, steps}`.
3. Mark entrance as visited (turn it into `'+'`).
4. While queue is not empty:

   * Pop the current cell `(x,y,steps)`.
   * For each of the 4 directions (up, down, left, right):

     * If next cell is inside maze and `"."` â†’ push into queue with `steps+1`.
     * Mark it as visited (`"+"`).
     * If the cell is on the border â†’ return steps+1 immediately.
5. If no exit found â†’ return `-1`.

---

## ðŸ”¹ Dry Run on Example

Start: Entrance `(1,0)`
Queue initially: `[(1,0,0)]`

```
Step 0: at (1,0) [Entrance]
  Neighbors â†’ (1,1) valid, push with step=1

Queue: [(1,1,1)]
```

```
Step 1: at (1,1)
  Neighbors â†’ (1,2) valid, push with step=2

Queue: [(1,2,2)]
```

```
Step 2: at (1,2)
  Neighbors â†’ (0,2) valid, push with step=3
              (2,2) blocked
Queue: [(0,2,3)]
```

```
Step 3: at (0,2)
  It's on the BORDER â†’ EXIT FOUND âœ…
Answer = 3
```

---

## ðŸ”¹ C++ Code Explanation

```cpp
class Solution {
public:
    int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
        // Movement directions (down, up, right, left)
        int dx[] = {1, -1, 0, 0};
        int dy[] = {0, 0, 1, -1};
        
        int n = maze.size();
        int m = maze[0].size();

        // BFS queue stores {row, col, steps}
        queue<vector<int>> q;
        q.push({entrance[0], entrance[1], 0});

        // Mark entrance as visited
        maze[entrance[0]][entrance[1]] = '+';

        // BFS
        while (!q.empty()) {
            vector<int> curr = q.front(); q.pop();
            int x = curr[0], y = curr[1], steps = curr[2];

            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];

                // Valid move check
                if (nx >= 0 && ny >= 0 && nx < n && ny < m && maze[nx][ny] == '.') {
                    int nextSteps = steps + 1;
                    // Mark visited
                    maze[nx][ny] = '+';

                    // Check if border exit
                    if (nx == 0 || ny == 0 || nx == n-1 || ny == m-1) {
                        return nextSteps; // First found exit = nearest
                    }

                    // Continue BFS
                    q.push({nx, ny, nextSteps});
                }
            }
        }
        return -1; // No exit found
    }
};
```

---

## ðŸ”¹ Output for Given Example

```
Input:
maze = [ ['+','+','.','+'],
         ['.','.','.','+'],
         ['+','+','+','.'] ]
entrance = [1,0]

Output:
3
```

### ASCII of path found:

```
   0   1   2   3
0  +   +   E   +
1  +   +   +   +
2  +   +   +   .

Steps: 3
```

---

âœ… Now your full cycle is complete:

1. Question
2. Graph ASCII
3. Step-by-step algorithm
4. Code explained
5. Dry run + Output

---
