# üöÄ Complete C++ Object-Oriented Programming (OOP) Guide

## üìö Table of Contents
1. [Core OOP Concepts](#core-oop-concepts)
2. [Class and Object](#class-and-object)
3. [Encapsulation](#encapsulation)
4. [Inheritance](#inheritance)
5. [Polymorphism](#polymorphism)
6. [Abstraction](#abstraction)
7. [Interface vs Abstract Class](#interface-vs-abstract-class)
8. [Constructors & Destructors](#constructors--destructors)
9. [Access Modifiers](#access-modifiers)
10. [Advanced OOP Topics](#advanced-oop-topics)
11. [Memory Management](#memory-management)
12. [Best Practices](#best-practices)

---

## üéØ Core OOP Concepts

### The 4 Pillars of OOP:
1. **Encapsulation** - Data hiding and bundling
2. **Inheritance** - Code reusability
3. **Polymorphism** - One interface, multiple forms
4. **Abstraction** - Hiding implementation details

---

## 1Ô∏è‚É£ Class and Object

### üîπ Basic Class Definition
```cpp
#include <iostream>
#include <string>
using namespace std;

class Student {
public:
    string name;
    int rollNo;
    float marks;
    
    // Method to display student info
    void displayInfo() {
        cout << "Name: " << name << ", Roll: " << rollNo 
             << ", Marks: " << marks << endl;
    }
    
    // Method to calculate grade
    char getGrade() {
        if(marks >= 90) return 'A';
        else if(marks >= 80) return 'B';
        else if(marks >= 70) return 'C';
        else return 'F';
    }
};

int main() {
    // Creating objects
    Student s1, s2;
    
    // Setting values
    s1.name = "John";
    s1.rollNo = 101;
    s1.marks = 85.5;
    
    s2.name = "Alice";
    s2.rollNo = 102;
    s2.marks = 92.0;
    
    // Using methods
    s1.displayInfo();
    cout << "Grade: " << s1.getGrade() << endl;
    
    return 0;
}
```

### üîë Key Points:
- **Class**: Blueprint/Template
- **Object**: Instance of a class
- **Member Variables**: Data inside class
- **Member Functions**: Methods that operate on data

---

## 2Ô∏è‚É£ Encapsulation

### üîπ Data Hiding with Private Members
```cpp
#include <iostream>
using namespace std;

class BankAccount {
private:
    double balance;
    string accountNumber;
    
public:
    // Constructor
    BankAccount(string accNo, double initialBalance) {
        accountNumber = accNo;
        setBalance(initialBalance);
    }
    
    // Getter methods
    double getBalance() const {
        return balance;
    }
    
    string getAccountNumber() const {
        return accountNumber;
    }
    
    // Setter with validation
    void setBalance(double amount) {
        if(amount >= 0) {
            balance = amount;
        } else {
            cout << "Invalid amount!" << endl;
        }
    }
    
    // Deposit method
    void deposit(double amount) {
        if(amount > 0) {
            balance += amount;
            cout << "Deposited: $" << amount << endl;
        }
    }
    
    // Withdraw method
    bool withdraw(double amount) {
        if(amount > 0 && amount <= balance) {
            balance -= amount;
            cout << "Withdrawn: $" << amount << endl;
            return true;
        }
        cout << "Insufficient funds!" << endl;
        return false;
    }
};

int main() {
    BankAccount account("ACC-001", 1000.0);
    
    cout << "Initial Balance: $" << account.getBalance() << endl;
    
    account.deposit(500);
    account.withdraw(200);
    
    cout << "Final Balance: $" << account.getBalance() << endl;
    
    return 0;
}
```

### üîë Key Points:
- **Data Hiding**: Private members cannot be accessed directly
- **Getters/Setters**: Controlled access to private data
- **Validation**: Ensure data integrity
- **const Methods**: Methods that don't modify object state

---

## 3Ô∏è‚É£ Inheritance

### üîπ Single Inheritance
```cpp
#include <iostream>
using namespace std;

// Base class
class Vehicle {
protected:
    string brand;
    int year;
    
public:
    Vehicle(string b, int y) : brand(b), year(y) {}
    
    void startEngine() {
        cout << brand << " engine started!" << endl;
    }
    
    void displayInfo() {
        cout << "Brand: " << brand << ", Year: " << year << endl;
    }
};

// Derived class
class Car : public Vehicle {
private:
    int doors;
    
public:
    Car(string b, int y, int d) : Vehicle(b, y), doors(d) {}
    
    void honk() {
        cout << brand << " car is honking!" << endl;
    }
    
    void displayCarInfo() {
        displayInfo();  // Inherited method
        cout << "Doors: " << doors << endl;
    }
};

int main() {
    Car myCar("Toyota", 2023, 4);
    
    myCar.startEngine();    // Inherited method
    myCar.honk();          // Own method
    myCar.displayCarInfo(); // Uses both inherited and own data
    
    return 0;
}
```

### üîπ Multiple Inheritance
```cpp
#include <iostream>
using namespace std;

class Engine {
protected:
    int horsepower;
    
public:
    Engine(int hp) : horsepower(hp) {}
    
    void showPower() {
        cout << "Engine Power: " << horsepower << " HP" << endl;
    }
};

class Electronics {
protected:
    bool hasGPS;
    
public:
    Electronics(bool gps) : hasGPS(gps) {}
    
    void showFeatures() {
        cout << "GPS: " << (hasGPS ? "Yes" : "No") << endl;
    }
};

class ModernCar : public Vehicle, public Engine, public Electronics {
public:
    ModernCar(string b, int y, int hp, bool gps) 
        : Vehicle(b, y), Engine(hp), Electronics(gps) {}
    
    void showAllFeatures() {
        displayInfo();
        showPower();
        showFeatures();
    }
};

int main() {
    ModernCar car("Tesla", 2024, 400, true);
    car.showAllFeatures();
    
    return 0;
}
```

### üîπ Multilevel Inheritance
```cpp
#include <iostream>
using namespace std;

// Grandparent class
class Animal {
protected:
    string species;
    
public:
    Animal(string s) : species(s) {}
    
    void breathe() {
        cout << species << " is breathing" << endl;
    }
};

// Parent class
class Mammal : public Animal {
protected:
    bool hasHair;
    
public:
    Mammal(string s, bool hair) : Animal(s), hasHair(hair) {}
    
    void giveMilk() {
        cout << species << " gives milk" << endl;
    }
};

// Child class
class Dog : public Mammal {
private:
    string breed;
    
public:
    Dog(string b) : Mammal("Dog", true), breed(b) {}
    
    void bark() {
        cout << breed << " dog is barking!" << endl;
    }
    
    void showInfo() {
        breathe();    // From Animal
        giveMilk();   // From Mammal
        bark();       // Own method
    }
};

int main() {
    Dog myDog("Golden Retriever");
    myDog.showInfo();
    
    return 0;
}
```

### üîë Key Points:
- **Single**: One parent class
- **Multiple**: Multiple parent classes
- **Multilevel**: Chain of inheritance
- **Hierarchical**: One parent, multiple children
- **protected**: Accessible in derived classes

---

## 4Ô∏è‚É£ Polymorphism

### üîπ Function Overloading (Compile-time Polymorphism)
```cpp
#include <iostream>
using namespace std;

class Calculator {
public:
    // Same function name, different parameters
    int add(int a, int b) {
        return a + b;
    }
    
    double add(double a, double b) {
        return a + b;
    }
    
    int add(int a, int b, int c) {
        return a + b + c;
    }
    
    string add(string a, string b) {
        return a + b;
    }
};

int main() {
    Calculator calc;
    
    cout << calc.add(5, 3) << endl;           // int version
    cout << calc.add(5.5, 3.2) << endl;      // double version
    cout << calc.add(1, 2, 3) << endl;       // three parameter version
    cout << calc.add("Hello", "World") << endl; // string version
    
    return 0;
}
```

### üîπ Operator Overloading
```cpp
#include <iostream>
using namespace std;

class Complex {
private:
    double real, imag;
    
public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}
    
    // Overload + operator
    Complex operator+(const Complex& other) {
        return Complex(real + other.real, imag + other.imag);
    }
    
    // Overload == operator
    bool operator==(const Complex& other) {
        return (real == other.real && imag == other.imag);
    }
    
    // Overload << operator for output
    friend ostream& operator<<(ostream& out, const Complex& c) {
        out << c.real << " + " << c.imag << "i";
        return out;
    }
    
    // Overload >> operator for input
    friend istream& operator>>(istream& in, Complex& c) {
        in >> c.real >> c.imag;
        return in;
    }
};

int main() {
    Complex c1(3, 4);
    Complex c2(1, 2);
    Complex c3 = c1 + c2;  // Using overloaded + operator
    
    cout << "c1: " << c1 << endl;
    cout << "c2: " << c2 << endl;
    cout << "c3: " << c3 << endl;
    
    if(c1 == c2) {
        cout << "c1 and c2 are equal" << endl;
    } else {
        cout << "c1 and c2 are not equal" << endl;
    }
    
    return 0;
}
```

### üîπ Function Overriding (Runtime Polymorphism)
```cpp
#include <iostream>
using namespace std;

class Shape {
public:
    virtual double area() {
        return 0;
    }
    
    virtual void display() {
        cout << "This is a shape" << endl;
    }
    
    // Virtual destructor
    virtual ~Shape() {}
};

class Circle : public Shape {
private:
    double radius;
    
public:
    Circle(double r) : radius(r) {}
    
    double area() override {
        return 3.14159 * radius * radius;
    }
    
    void display() override {
        cout << "This is a circle with radius: " << radius << endl;
    }
};

class Rectangle : public Shape {
private:
    double length, width;
    
public:
    Rectangle(double l, double w) : length(l), width(w) {}
    
    double area() override {
        return length * width;
    }
    
    void display() override {
        cout << "This is a rectangle: " << length << "x" << width << endl;
    }
};

void printShapeInfo(Shape* shape) {
    shape->display();
    cout << "Area: " << shape->area() << endl << endl;
}

int main() {
    Shape* shapes[] = {
        new Circle(5),
        new Rectangle(4, 6),
        new Circle(3)
    };
    
    for(int i = 0; i < 3; i++) {
        printShapeInfo(shapes[i]);  // Runtime polymorphism
        delete shapes[i];
    }
    
    return 0;
}
```

### üîë Key Points:
- **Compile-time**: Function/Operator overloading
- **Runtime**: Virtual functions and function overriding
- **virtual**: Enables runtime polymorphism
- **override**: Explicit indication of overriding (C++11)

---

## 5Ô∏è‚É£ Abstraction

### üîπ Abstract Classes with Pure Virtual Functions
```cpp
#include <iostream>
using namespace std;

// Abstract base class
class Database {
protected:
    string connectionString;
    
public:
    Database(string conn) : connectionString(conn) {}
    
    // Pure virtual functions (make class abstract)
    virtual void connect() = 0;
    virtual void disconnect() = 0;
    virtual void executeQuery(string query) = 0;
    
    // Non-pure virtual function (can be overridden)
    virtual void showConnection() {
        cout << "Connection: " << connectionString << endl;
    }
    
    // Regular function (inherited as-is)
    void logActivity(string activity) {
        cout << "Log: " << activity << endl;
    }
    
    virtual ~Database() {}
};

class MySQL : public Database {
public:
    MySQL(string conn) : Database(conn) {}
    
    void connect() override {
        cout << "Connecting to MySQL database..." << endl;
        logActivity("MySQL connection established");
    }
    
    void disconnect() override {
        cout << "Disconnecting from MySQL..." << endl;
        logActivity("MySQL connection closed");
    }
    
    void executeQuery(string query) override {
        cout << "Executing MySQL query: " << query << endl;
    }
};

class PostgreSQL : public Database {
public:
    PostgreSQL(string conn) : Database(conn) {}
    
    void connect() override {
        cout << "Connecting to PostgreSQL database..." << endl;
        logActivity("PostgreSQL connection established");
    }
    
    void disconnect() override {
        cout << "Disconnecting from PostgreSQL..." << endl;
        logActivity("PostgreSQL connection closed");
    }
    
    void executeQuery(string query) override {
        cout << "Executing PostgreSQL query: " << query << endl;
    }
    
    void showConnection() override {
        cout << "PostgreSQL " << connectionString << endl;
    }
};

int main() {
    // Database db; // Error! Cannot instantiate abstract class
    
    Database* databases[] = {
        new MySQL("mysql://localhost:3306"),
        new PostgreSQL("postgresql://localhost:5432")
    };
    
    for(int i = 0; i < 2; i++) {
        databases[i]->showConnection();
        databases[i]->connect();
        databases[i]->executeQuery("SELECT * FROM users");
        databases[i]->disconnect();
        cout << endl;
        
        delete databases[i];
    }
    
    return 0;
}
```

### üîë Key Points:
- **Pure Virtual Function**: `virtual function() = 0;`
- **Abstract Class**: Has at least one pure virtual function
- **Cannot instantiate**: Abstract classes cannot create objects
- **Must Override**: Derived classes must implement pure virtual functions

---

## 6Ô∏è‚É£ Interface vs Abstract Class

### üîπ Interface Implementation
```cpp
#include <iostream>
using namespace std;

// Interface (Pure abstract class)
class Printable {
public:
    virtual void print() = 0;
    virtual ~Printable() {}
};

class Saveable {
public:
    virtual void save() = 0;
    virtual ~Saveable() {}
};

// Abstract class (partial implementation)
class Document {
protected:
    string title;
    string content;
    
public:
    Document(string t) : title(t) {}
    
    // Pure virtual (must override)
    virtual void format() = 0;
    
    // Virtual (can override)
    virtual void setContent(string c) {
        content = c;
    }
    
    // Regular method (inherited as-is)
    string getTitle() {
        return title;
    }
    
    virtual ~Document() {}
};

// Class implementing multiple interfaces and inheriting from abstract class
class PDFDocument : public Document, public Printable, public Saveable {
public:
    PDFDocument(string title) : Document(title) {}
    
    // From Document (abstract class)
    void format() override {
        cout << "Formatting PDF document: " << title << endl;
    }
    
    // From Printable interface
    void print() override {
        cout << "Printing PDF: " << title << endl;
    }
    
    // From Saveable interface
    void save() override {
        cout << "Saving PDF: " << title << ".pdf" << endl;
    }
};

class WordDocument : public Document, public Printable, public Saveable {
public:
    WordDocument(string title) : Document(title) {}
    
    void format() override {
        cout << "Formatting Word document: " << title << endl;
    }
    
    void print() override {
        cout << "Printing Word doc: " << title << endl;
    }
    
    void save() override {
        cout << "Saving Word doc: " << title << ".docx" << endl;
    }
    
    // Override inherited virtual method
    void setContent(string c) override {
        content = "Word: " + c;
        cout << "Content set for Word document" << endl;
    }
};

int main() {
    PDFDocument pdf("Report");
    WordDocument word("Letter");
    
    // Using abstract class methods
    pdf.setContent("PDF Content");
    word.setContent("Word Content");
    
    // Using interface methods through polymorphism
    Printable* printables[] = {&pdf, &word};
    Saveable* saveables[] = {&pdf, &word};
    
    for(int i = 0; i < 2; i++) {
        printables[i]->print();
        saveables[i]->save();
    }
    
    return 0;
}
```

### üìä Interface vs Abstract Class Comparison

| Feature | Interface | Abstract Class |
|---------|-----------|----------------|
| **Purpose** | Contract/Rules only | Partial implementation |
| **Methods** | Only pure virtual | Can have regular, virtual, and pure virtual |
| **Data Members** | Not typically used | Can have protected/private data |
| **Constructor** | Not used | Can have constructors |
| **Multiple Inheritance** | ‚úÖ Yes (multiple interfaces) | ‚ùå No (single inheritance in C++) |
| **Implementation** | 0% implemented | Partially implemented |
| **When to Use** | When you need a contract | When you have common functionality |

### üîë Key Points:
- **Interface**: Pure contract, no implementation
- **Abstract Class**: Blueprint with some implementation
- **Multiple Interfaces**: Possible through multiple inheritance
- **Diamond Problem**: Avoided with interfaces

---

## 7Ô∏è‚É£ Constructors & Destructors

### üîπ Types of Constructors
```cpp
#include <iostream>
#include <string>
using namespace std;

class Student {
private:
    string name;
    int age;
    double* grades;
    int numGrades;
    
public:
    // 1. Default Constructor
    Student() {
        cout << "Default constructor called" << endl;
        name = "Unknown";
        age = 0;
        grades = nullptr;
        numGrades = 0;
    }
    
    // 2. Parameterized Constructor
    Student(string n, int a) {
        cout << "Parameterized constructor called" << endl;
        name = n;
        age = a;
        grades = nullptr;
        numGrades = 0;
    }
    
    // 3. Constructor with dynamic memory
    Student(string n, int a, int gradeCount) {
        cout << "Constructor with memory allocation called" << endl;
        name = n;
        age = a;
        numGrades = gradeCount;
        grades = new double[numGrades];
        
        // Initialize grades to 0
        for(int i = 0; i < numGrades; i++) {
            grades[i] = 0.0;
        }
    }
    
    // 4. Copy Constructor
    Student(const Student& other) {
        cout << "Copy constructor called" << endl;
        name = other.name;
        age = other.age;
        numGrades = other.numGrades;
        
        if(other.grades) {
            grades = new double[numGrades];
            for(int i = 0; i < numGrades; i++) {
                grades[i] = other.grades[i];
            }
        } else {
            grades = nullptr;
        }
    }
    
    // 5. Assignment Operator Overloading
    Student& operator=(const Student& other) {
        cout << "Assignment operator called" << endl;
        
        if(this == &other) return *this; // Self-assignment check
        
        // Clean up existing memory
        delete[] grades;
        
        // Copy data
        name = other.name;
        age = other.age;
        numGrades = other.numGrades;
        
        if(other.grades) {
            grades = new double[numGrades];
            for(int i = 0; i < numGrades; i++) {
                grades[i] = other.grades[i];
            }
        } else {
            grades = nullptr;
        }
        
        return *this;
    }
    
    // Destructor
    ~Student() {
        cout << "Destructor called for " << name << endl;
        delete[] grades; // Clean up dynamic memory
    }
    
    // Utility methods
    void setGrade(int index, double grade) {
        if(index >= 0 && index < numGrades) {
            grades[index] = grade;
        }
    }
    
    void displayInfo() {
        cout << "Name: " << name << ", Age: " << age;
        if(grades) {
            cout << ", Grades: ";
            for(int i = 0; i < numGrades; i++) {
                cout << grades[i] << " ";
            }
        }
        cout << endl;
    }
};

int main() {
    cout << "=== Creating students ===" << endl;
    Student s1;                           // Default constructor
    Student s2("Alice", 20);             // Parameterized constructor
    Student s3("Bob", 21, 3);            // Constructor with memory allocation
    
    s3.setGrade(0, 85.5);
    s3.setGrade(1, 92.0);
    s3.setGrade(2, 78.5);
    
    cout << "\n=== Displaying info ===" << endl;
    s1.displayInfo();
    s2.displayInfo();
    s3.displayInfo();
    
    cout << "\n=== Copy constructor ===" << endl;
    Student s4 = s3;                     // Copy constructor
    s4.displayInfo();
    
    cout << "\n=== Assignment operator ===" << endl;
    s1 = s3;                             // Assignment operator
    s1.displayInfo();
    
    cout << "\n=== End of main (destructors will be called) ===" << endl;
    return 0;
}
```

### üîπ Constructor Delegation and Initialization Lists
```cpp
#include <iostream>
using namespace std;

class Rectangle {
private:
    double length;
    double width;
    const int id;           // const member
    static int nextId;      // static member
    
public:
    // Constructor delegation (C++11)
    Rectangle() : Rectangle(1.0, 1.0) {
        cout << "Default constructor (delegated)" << endl;
    }
    
    Rectangle(double side) : Rectangle(side, side) {
        cout << "Square constructor (delegated)" << endl;
    }
    
    // Main constructor with initialization list
    Rectangle(double l, double w) : length(l), width(w), id(nextId++) {
        cout << "Main constructor with id: " << id << endl;
        // Constructor body (if needed)
    }
    
    // Static method to access static member
    static int getNextId() {
        return nextId;
    }
    
    void displayInfo() {
        cout << "Rectangle " << id << ": " << length << "x" << width 
             << " (Area: " << length * width << ")" << endl;
    }
};

// Static member definition
int Rectangle::nextId = 1;

int main() {
    Rectangle r1;           // Default -> delegates to main constructor
    Rectangle r2(5.0);      // Square -> delegates to main constructor  
    Rectangle r3(3.0, 4.0); // Main constructor directly
    
    r1.displayInfo();
    r2.displayInfo();
    r3.displayInfo();
    
    cout << "Next ID will be: " << Rectangle::getNextId() << endl;
    
    return 0;
}
```

### üîë Key Points:
- **Initialization List**: Efficient way to initialize members
- **Constructor Delegation**: One constructor calls another (C++11)
- **Copy Constructor**: Deep copy for dynamic memory
- **Assignment Operator**: Handle self-assignment and memory cleanup
- **Destructor**: Always clean up dynamic memory

---

## 8Ô∏è‚É£ Access Modifiers

### üîπ Complete Access Modifier Example
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar = 1;
    
protected:
    int protectedVar = 2;
    
private:
    int privateVar = 3;
    
public:
    void showAccess() {
        cout << "From Base class:" << endl;
        cout << "Public: " << publicVar << endl;      // ‚úÖ Accessible
        cout << "Protected: " << protectedVar << endl; // ‚úÖ Accessible
        cout << "Private: " << privateVar << endl;     // ‚úÖ Accessible
    }
    
    // Getter for private member
    int getPrivateVar() {
        return privateVar;
    }
    
    // Setter for private member
    void setPrivateVar(int value) {
        privateVar = value;
    }
};

class Derived : public Base {
public:
    void showDerivedAccess() {
        cout << "From Derived class:" << endl;
        cout << "Public: " << publicVar << endl;      // ‚úÖ Accessible
        cout << "Protected: " << protectedVar << endl; // ‚úÖ Accessible
        // cout << "Private: " << privateVar << endl;  // ‚ùå Not accessible
        
        // Access private through public method
        cout << "Private (via getter): " << getPrivateVar() << endl;
    }
    
    void modifyProtected() {
        protectedVar = 20; // ‚úÖ Can modify protected in derived class
    }
};

int main() {
    Base base;
    Derived derived;
    
    cout << "=== External Access ===" << endl;
    cout << "Base public: " << base.publicVar << endl;        // ‚úÖ Accessible
    // cout << "Base protected: " << base.protectedVar << endl; // ‚ùå Not accessible
    // cout << "Base private: " << base.privateVar << endl;     // ‚ùå Not accessible
    
    cout << "Derived public: " << derived.publicVar << endl;  // ‚úÖ Accessible
    
    cout << "\n=== Class Methods ===" << endl;
    base.showAccess();
    
    cout << "\n=== Derived Class Methods ===" << endl;
    derived.showDerivedAccess();
    
    cout << "\n=== Modifying Protected ===" << endl;
    derived.modifyProtected();
    derived.showDerivedAccess();
    
    return 0;
}
```

### üîπ Inheritance Access Levels
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int pub = 1;
protected:
    int prot = 2;
private:
    int priv = 3;
};

// Public inheritance
class PublicDerived : public Base {
public:
    void show() {
        cout << "Public inheritance:" << endl;
        cout << "pub: " << pub << " (public)" << endl;     // public -> public
        cout << "prot: " << prot << " (protected)" << endl; // protected -> protected
        // priv is not accessible
    }
};

// Protected inheritance
class ProtectedDerived : protected Base {
public:
    void show() {
        cout << "Protected inheritance:" << endl;
        cout << "pub: " << pub << " (protected)" << endl;   // public -> protected
        cout << "prot: " << prot << " (protected)" << endl; // protected -> protected
        // priv is not accessible
    }
};

// Private inheritance
class PrivateDerived : private Base {
public:
    void show() {
        cout << "Private inheritance:" << endl;
        cout << "pub: " << pub << " (private)" << endl;     // public -> private
        cout << "prot: " << prot << " (private)" << endl;   // protected -> private
        // priv is not accessible
    }
};

int main() {
    PublicDerived pd;
    ProtectedDerived protd;
    PrivateDerived privd;
    
    // External access
    cout << "External access:" << endl;
    cout << "PublicDerived.pub: " << pd.pub << endl;    // ‚úÖ Accessible
    // cout << "ProtectedDerived.pub: " << protd.pub << endl; // ‚ùå Not accessible
    // cout << "PrivateDerived.pub: " << privd.pub << endl;   // ‚ùå Not accessible
    
    cout << "\nMethod access:" << endl;
    pd.show();
    protd.show();
    privd.show();
    
    return 0;
}
```

### üìä Access Modifier Summary Table

| Modifier | Same Class | Derived Class | Outside Class |
|----------|------------|---------------|---------------|
| `public` | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes |
| `protected` | ‚úÖ Yes | ‚úÖ Yes | ‚ùå No |
| `private` | ‚úÖ Yes | ‚ùå No | ‚ùå No |

### üìä Inheritance Access Table

| Base Access | public inherit | protected inherit | private inherit |
|-------------|----------------|-------------------|-----------------|
| `public` | public | protected | private |
| `protected` | protected | protected | private |
| `private` | Not accessible | Not accessible | Not accessible |

### üîë Key Points:
- **public**: Most permissive, accessible everywhere
- **protected**: For inheritance hierarchy only
- **private**: Only within the same class
- **Inheritance type**: Determines maximum access level in derived class

---

## 9Ô∏è‚É£ Advanced OOP Topics

### üîπ Friend Functions and Classes
```cpp
#include <iostream>
using namespace std;

class Rectangle; // Forward declaration

class Calculator {
public:
    // Friend function can access private members of Rectangle
    double calculateArea(const Rectangle& rect);
};

class Rectangle {
private:
    double length;
    double width;
    
public:
    Rectangle(double l, double w) : length(l), width(w) {}
    
    // Friend function declaration
    friend double Calculator::calculateArea(const Rectangle& rect);
    
    // Friend function (standalone)
    friend void displayDimensions(const Rectangle& rect);
    
    // Friend class
    friend class GeometryHelper;
    
    // Regular getter methods
    double getLength() const { return length; }
    double getWidth() const { return width; }
};

// Friend function implementation
double Calculator::calculateArea(const Rectangle& rect) {
    // Can access private members directly
    return rect.length * rect.width;
}

// Standalone friend function
void displayDimensions(const Rectangle& rect) {
    cout << "Dimensions: " << rect.length << " x " << rect.width << endl;
}

// Friend class - can access all private members
class GeometryHelper {
public:
    static double perimeter(const Rectangle& rect) {
        return 2 * (rect.length + rect.width);
    }
    
    static bool isSquare(const Rectangle& rect) {
        return rect.length == rect.width;
    }
    
    static void resize(Rectangle& rect, double factor) {
        rect.length *= factor;
        rect.width *= factor;
    }
};

int main() {
    Rectangle rect(5.0, 3.0);
    Calculator calc;
    
    cout << "Area: " << calc.calculateArea(rect) << endl;
    cout << "Perimeter: " << GeometryHelper::perimeter(rect) << endl;
    cout << "Is Square: " << (GeometryHelper::isSquare(rect) ? "Yes" : "No") << endl;
    
    displayDimensions(rect);
    
    GeometryHelper::resize(rect, 2.0);
    cout << "After resizing:" << endl;
    displayDimensions(rect);
    
    return 0;
}
```

### üîπ Static Members and Methods
```cpp
#include <iostream>
#include <vector>
using namespace std;

class Employee {
private:
    string name;
    int empId;
    double salary;
    
    // Static members
    static int totalEmployees;
    static double totalSalary;
    static vector<Employee*> employees;
    
public:
    // Constructor
    Employee(string n, double s) : name(n), salary(s) {
        empId = ++totalEmployees;
        totalSalary += salary;
        employees.push_back(this);
        cout << "Employee " << name << " hired with ID: " << empId << endl;
    }
    
    // Destructor
    ~Employee() {
        totalSalary -= salary;
        totalEmployees--;
        
        // Remove from vector
        for(auto it = employees.begin(); it != employees.end(); ++it) {
            if(*it == this) {
                employees.erase(it);
                break;
            }
        }
        cout << "Employee " << name << " removed" << endl;
    }
    
    // Static methods
    static int getTotalEmployees() {
        return totalEmployees;
    }
    
    static double getAverageSalary() {
        return totalEmployees > 0 ? totalSalary / totalEmployees : 0;
    }
    
    static void displayAllEmployees() {
        cout << "\n=== All Employees ===" << endl;
        for(const auto& emp : employees) {
            cout << "ID: " << emp->empId << ", Name: " << emp->name 
                 << ", Salary: $" << emp->salary << endl;
        }
    }
    
    static Employee* findHighestPaid() {
        if(employees.empty()) return nullptr;
        
        Employee* highest = employees[0];
        for(const auto& emp : employees) {
            if(emp->salary > highest->salary) {
                highest = emp;
            }
        }
        return highest;
    }
    
    // Instance methods
    void raiseSalary(double amount) {
        totalSalary -= salary;
        salary += amount;
        totalSalary += salary;
        cout << name << "'s salary raised by $" << amount << endl;
    }
    
    void displayInfo() const {
        cout << "Employee: " << name << " (ID: " << empId 
             << "), Salary: $" << salary << endl;
    }
    
    // Getters
    string getName() const { return name; }
    double getSalary() const { return salary; }
};

// Static member definitions
int Employee::totalEmployees = 0;
double Employee::totalSalary = 0.0;
vector<Employee*> Employee::employees;

int main() {
    cout << "Initial employees: " << Employee::getTotalEmployees() << endl;
    
    // Create employees
    Employee* emp1 = new Employee("Alice", 50000);
    Employee* emp2 = new Employee("Bob", 60000);
    Employee* emp3 = new Employee("Charlie", 55000);
    
    cout << "\nTotal Employees: " << Employee::getTotalEmployees() << endl;
    cout << "Average Salary: $" << Employee::getAverageSalary() << endl;
    
    Employee::displayAllEmployees();
    
    // Find highest paid
    Employee* highest = Employee::findHighestPaid();
    if(highest) {
        cout << "\nHighest paid employee: " << highest->getName() 
             << " ($" << highest->getSalary() << ")" << endl;
    }
    
    // Raise salary
    emp2->raiseSalary(5000);
    cout << "New average salary: $" << Employee::getAverageSalary() << endl;
    
    // Cleanup
    delete emp1;
    delete emp2;
    delete emp3;
    
    cout << "\nFinal employee count: " << Employee::getTotalEmployees() << endl;
    
    return 0;
}
```

### üîπ Nested Classes
```cpp
#include <iostream>
#include <vector>
using namespace std;

class University {
private:
    string universityName;
    
public:
    University(string name) : universityName(name) {}
    
    // Nested class
    class Department {
    private:
        string deptName;
        vector<Student> students;
        
    public:
        Department(string name) : deptName(name) {}
        
        // Nested class inside nested class
        class Student {
        private:
            string studentName;
            int rollNo;
            double gpa;
            
        public:
            Student(string name, int roll, double g) 
                : studentName(name), rollNo(roll), gpa(g) {}
            
            void displayStudent() const {
                cout << "Student: " << studentName << " (Roll: " << rollNo 
                     << ", GPA: " << gpa << ")" << endl;
            }
            
            string getName() const { return studentName; }
            double getGPA() const { return gpa; }
        };
        
        void addStudent(const Student& student) {
            students.push_back(student);
        }
        
        void displayDepartment() const {
            cout << "\nDepartment: " << deptName << endl;
            cout << "Students:" << endl;
            for(const auto& student : students) {
                student.displayStudent();
            }
        }
        
        double getAverageGPA() const {
            if(students.empty()) return 0.0;
            
            double total = 0.0;
            for(const auto& student : students) {
                total += student.getGPA();
            }
            return total / students.size();
        }
        
        string getDeptName() const { return deptName; }
    };
    
private:
    vector<Department> departments;
    
public:
    void addDepartment(const Department& dept) {
        departments.push_back(dept);
    }
    
    void displayUniversity() const {
        cout << "=== " << universityName << " ===" << endl;
        for(const auto& dept : departments) {
            dept.displayDepartment();
            cout << "Department Average GPA: " << dept.getAverageGPA() << endl;
        }
    }
    
    Department* findDepartment(const string& name) {
        for(auto& dept : departments) {
            if(dept.getDeptName() == name) {
                return &dept;
            }
        }
        return nullptr;
    }
};

int main() {
    University uni("Tech University");
    
    // Create departments
    University::Department cse("Computer Science");
    University::Department ee("Electrical Engineering");
    
    // Create students using nested class
    University::Department::Student s1("Alice Johnson", 101, 3.8);
    University::Department::Student s2("Bob Smith", 102, 3.6);
    University::Department::Student s3("Charlie Brown", 201, 3.9);
    University::Department::Student s4("Diana Prince", 202, 3.7);
    
    // Add students to departments
    cse.addStudent(s1);
    cse.addStudent(s2);
    ee.addStudent(s3);
    ee.addStudent(s4);
    
    // Add departments to university
    uni.addDepartment(cse);
    uni.addDepartment(ee);
    
    // Display everything
    uni.displayUniversity();
    
    return 0;
}
```

### üîπ Template Classes (Generic Programming)
```cpp
#include <iostream>
#include <vector>
#include <stdexcept>
using namespace std;

// Template class for a generic Stack
template<typename T>
class Stack {
private:
    vector<T> elements;
    size_t maxSize;
    
public:
    // Constructor
    Stack(size_t size = 100) : maxSize(size) {}
    
    // Push element
    void push(const T& element) {
        if(elements.size() >= maxSize) {
            throw overflow_error("Stack overflow");
        }
        elements.push_back(element);
    }
    
    // Pop element
    T pop() {
        if(isEmpty()) {
            throw underflow_error("Stack underflow");
        }
        T element = elements.back();
        elements.pop_back();
        return element;
    }
    
    // Peek top element
    T& top() {
        if(isEmpty()) {
            throw underflow_error("Stack is empty");
        }
        return elements.back();
    }
    
    // Check if empty
    bool isEmpty() const {
        return elements.empty();
    }
    
    // Get size
    size_t size() const {
        return elements.size();
    }
    
    // Display stack contents
    void display() const {
        cout << "Stack contents (top to bottom): ";
        for(auto it = elements.rbegin(); it != elements.rend(); ++it) {
            cout << *it << " ";
        }
        cout << endl;
    }
};

// Template specialization for string
template<>
class Stack<string> {
private:
    vector<string> elements;
    size_t maxSize;
    
public:
    Stack(size_t size = 100) : maxSize(size) {}
    
    void push(const string& element) {
        if(elements.size() >= maxSize) {
            throw overflow_error("Stack overflow");
        }
        // Special processing for strings
        string processed = "[" + element + "]";
        elements.push_back(processed);
    }
    
    string pop() {
        if(isEmpty()) {
            throw underflow_error("Stack underflow");
        }
        string element = elements.back();
        elements.pop_back();
        return element;
    }
    
    string& top() {
        if(isEmpty()) {
            throw underflow_error("Stack is empty");
        }
        return elements.back();
    }
    
    bool isEmpty() const {
        return elements.empty();
    }
    
    size_t size() const {
        return elements.size();
    }
    
    void display() const {
        cout << "String Stack contents: ";
        for(const auto& str : elements) {
            cout << str << " ";
        }
        cout << endl;
    }
};

// Template class with multiple parameters
template<typename KeyType, typename ValueType>
class KeyValuePair {
private:
    KeyType key;
    ValueType value;
    
public:
    KeyValuePair(const KeyType& k, const ValueType& v) : key(k), value(v) {}
    
    KeyType getKey() const { return key; }
    ValueType getValue() const { return value; }
    
    void setValue(const ValueType& v) { value = v; }
    
    void display() const {
        cout << "Key: " << key << ", Value: " << value << endl;
    }
};

int main() {
    try {
        // Integer stack
        Stack<int> intStack(5);
        intStack.push(10);
        intStack.push(20);
        intStack.push(30);
        intStack.display();
        
        cout << "Popped: " << intStack.pop() << endl;
        cout << "Top: " << intStack.top() << endl;
        intStack.display();
        
        // Double stack
        Stack<double> doubleStack;
        doubleStack.push(3.14);
        doubleStack.push(2.71);
        doubleStack.display();
        
        // String stack (specialized)
        Stack<string> stringStack;
        stringStack.push("Hello");
        stringStack.push("World");
        stringStack.display();
        
        // Key-Value pairs
        KeyValuePair<string, int> pair1("age", 25);
        KeyValuePair<int, string> pair2(101, "Alice");
        
        pair1.display();
        pair2.display();
        
        // Vector of pairs
        vector<KeyValuePair<string, double>> grades;
        grades.push_back(KeyValuePair<string, double>("Math", 95.5));
        grades.push_back(KeyValuePair<string, double>("Physics", 87.0));
        
        cout << "\nGrades:" << endl;
        for(const auto& grade : grades) {
            grade.display();
        }
        
    } catch(const exception& e) {
        cout << "Exception: " << e.what() << endl;
    }
    
    return 0;
}
```

### üîë Key Points:
- **Friend Functions**: Access private members from outside
- **Static Members**: Shared among all instances
- **Nested Classes**: Organization and encapsulation
- **Templates**: Generic programming, code reusability

---

## üîü Memory Management

### üîπ Smart Pointers and RAII
```cpp
#include <iostream>
#include <memory>
#include <vector>
using namespace std;

class Resource {
private:
    string name;
    int* data;
    size_t size;
    
public:
    Resource(string n, size_t s) : name(n), size(s) {
        data = new int[size];
        for(size_t i = 0; i < size; i++) {
            data[i] = i + 1;
        }
        cout << "Resource '" << name << "' created with " << size << " elements" << endl;
    }
    
    ~Resource() {
        delete[] data;
        cout << "Resource '" << name << "' destroyed" << endl;
    }
    
    void display() const {
        cout << "Resource '" << name << "': ";
        for(size_t i = 0; i < size && i < 5; i++) {
            cout << data[i] << " ";
        }
        if(size > 5) cout << "...";
        cout << endl;
    }
    
    string getName() const { return name; }
};

class ResourceManager {
private:
    vector<shared_ptr<Resource>> resources;
    
public:
    void addResource(const string& name, size_t size) {
        auto resource = make_shared<Resource>(name, size);
        resources.push_back(resource);
    }
    
    shared_ptr<Resource> getResource(const string& name) {
        for(auto& resource : resources) {
            if(resource->getName() == name) {
                return resource;
            }
        }
        return nullptr;
    }
    
    void displayAll() const {
        cout << "\n=== All Resources ===" << endl;
        for(const auto& resource : resources) {
            resource->display();
            cout << "Reference count: " << resource.use_count() << endl;
        }
    }
    
    size_t getResourceCount() const {
        return resources.size();
    }
};

void demonstrateUniquePtr() {
    cout << "\n=== unique_ptr Demo ===" << endl;
    
    // Create unique_ptr
    unique_ptr<Resource> res1 = make_unique<Resource>("Unique1", 3);
    res1->display();
    
    // Move ownership
    unique_ptr<Resource> res2 = move(res1);
    
    if(!res1) {
        cout << "res1 is now null after move" << endl;
    }
    
    if(res2) {
        cout << "res2 now owns the resource" << endl;
        res2->display();
    }
    
    // Automatic cleanup when res2 goes out of scope
}

void demonstrateSharedPtr() {
    cout << "\n=== shared_ptr Demo ===" << endl;
    
    shared_ptr<Resource> shared1 = make_shared<Resource>("Shared1", 4);
    cout << "Reference count: " << shared1.use_count() << endl;
    
    {
        shared_ptr<Resource> shared2 = shared1; // Copy, increases ref count
        cout << "Reference count after copy: " << shared1.use_count() << endl;
        
        shared_ptr<Resource> shared3 = shared1; // Another copy
        cout << "Reference count with 3 copies: " << shared1.use_count() << endl;
        
        shared1->display();
        shared2->display();
        shared3->display();
        
        // shared2 and shared3 go out of scope here
    }
    
    cout << "Reference count after scope exit: " << shared1.use_count() << endl;
    // shared1 will be destroyed when function ends
}

void demonstrateWeakPtr() {
    cout << "\n=== weak_ptr Demo ===" << endl;
    
    shared_ptr<Resource> shared = make_shared<Resource>("Weak1", 2);
    weak_ptr<Resource> weak = shared;
    
    cout << "Shared ref count: " << shared.use_count() << endl;
    cout << "Weak expired: " << weak.expired() << endl;
    
    // Use weak_ptr safely
    if(auto locked = weak.lock()) {
        cout << "Successfully locked weak_ptr" << endl;
        locked->display();
        cout << "Ref count during lock: " << shared.use_count() << endl;
    }
    
    // Reset shared_ptr
    shared.reset();
    cout << "After shared reset, weak expired: " << weak.expired() << endl;
    
    // Try to lock expired weak_ptr
    if(auto locked = weak.lock()) {
        cout << "This won't print" << endl;
    } else {
        cout << "Cannot lock expired weak_ptr" << endl;
    }
}

int main() {
    // Resource manager with shared_ptr
    ResourceManager manager;
    manager.addResource("Database", 1000);
    manager.addResource("Cache", 500);
    manager.addResource("Logger", 100);
    
    manager.displayAll();
    
    // Get shared access to resource
    {
        auto db = manager.getResource("Database");
        auto cache = manager.getResource("Cache");
        
        if(db && cache) {
            db->display();
            cache->display();
        }
        
        manager.displayAll(); // Reference counts should be higher
    }
    
    manager.displayAll(); // Reference counts back to 1
    
    // Demonstrate different smart pointer types
    demonstrateUniquePtr();
    demonstrateSharedPtr();
    demonstrateWeakPtr();
    
    cout << "\n=== Program End ===" << endl;
    return 0;
}
```

### üîπ Custom Memory Management
```cpp
#include <iostream>
#include <cstdlib>
using namespace std;

class MemoryPool {
private:
    void* pool;
    size_t poolSize;
    size_t blockSize;
    size_t totalBlocks;
    bool* allocated;
    
public:
    MemoryPool(size_t blocks, size_t blockSz) 
        : totalBlocks(blocks), blockSize(blockSz) {
        poolSize = totalBlocks * blockSize;
        pool = malloc(poolSize);
        allocated = new bool[totalBlocks];
        
        for(size_t i = 0; i < totalBlocks; i++) {
            allocated[i] = false;
        }
        
        cout << "Memory pool created: " << totalBlocks << " blocks of " 
             << blockSize << " bytes each" << endl;
    }
    
    ~MemoryPool() {
        free(pool);
        delete[] allocated;
        cout << "Memory pool destroyed" << endl;
    }
    
    void* allocate() {
        for(size_t i = 0; i < totalBlocks; i++) {
            if(!allocated[i]) {
                allocated[i] = true;
                void* ptr = static_cast<char*>(pool) + (i * blockSize);
                cout << "Allocated block " << i << " at address " << ptr << endl;
                return ptr;
            }
        }
        cout << "No free blocks available!" << endl;
        return nullptr;
    }
    
    void deallocate(void* ptr) {
        if(!ptr) return;
        
        char* baseAddr = static_cast<char*>(pool);
        char* targetAddr = static_cast<char*>(ptr);
        
        if(targetAddr < baseAddr || targetAddr >= baseAddr + poolSize) {
            cout << "Invalid pointer for deallocation!" << endl;
            return;
        }
        
        size_t blockIndex = (targetAddr - baseAddr) / blockSize;
        
        if(blockIndex < totalBlocks && allocated[blockIndex]) {
            allocated[blockIndex] = false;
            cout << "Deallocated block " << blockIndex << endl;
        } else {
            cout << "Double deallocation or invalid block!" << endl;
        }
    }
    
    void showStatus() const {
        cout << "\nMemory Pool Status:" << endl;
        size_t freeBlocks = 0;
        for(size_t i = 0; i < totalBlocks; i++) {
            if(!allocated[i]) freeBlocks++;
        }
        cout << "Free blocks: " << freeBlocks << "/" << totalBlocks << endl;
        cout << "Used blocks: " << (totalBlocks - freeBlocks) << "/" << totalBlocks << endl;
    }
};

class CustomObject {
private:
    int value;
    static MemoryPool* pool;
    
public:
    CustomObject(int v) : value(v) {
        cout << "CustomObject " << value << " constructed" << endl;
    }
    
    ~CustomObject() {
        cout << "CustomObject " << value << " destructed" << endl;
    }
    
    // Custom new operator
    static void* operator new(size_t size) {
        cout << "Custom new called for size " << size << endl;
        if(!pool) {
            pool = new MemoryPool(10, sizeof(CustomObject));
        }
        return pool->allocate();
    }
    
    // Custom delete operator
    static void operator delete(void* ptr) {
        cout << "Custom delete called" << endl;
        if(pool) {
            pool->deallocate(ptr);
        }
    }
    
    void display() const {
        cout << "CustomObject value: " << value << endl;
    }
    
    static void cleanupPool() {
        delete pool;
        pool = nullptr;
    }
    
    static void showPoolStatus() {
        if(pool) {
            pool->showStatus();
        }
    }
};

// Static member definition
MemoryPool* CustomObject::pool = nullptr;

int main() {
    cout << "=== Custom Memory Management Demo ===" << endl;
    
    // Create objects using custom memory management
    CustomObject* obj1 = new CustomObject(100);
    CustomObject* obj2 = new CustomObject(200);
    CustomObject* obj3 = new CustomObject(300);
    
    obj1->display();
    obj2->display();
    obj3->display();
    
    CustomObject::showPoolStatus();
    
    // Delete some objects
    delete obj2;
    CustomObject::showPoolStatus();
    
    // Create new object (should reuse freed memory)
    CustomObject* obj4 = new CustomObject(400);
    obj4->display();
    
    CustomObject::showPoolStatus();
    
    // Cleanup
    delete obj1;
    delete obj3;
    delete obj4;
    
    CustomObject::showPoolStatus();
    CustomObject::cleanupPool();
    
    return 0;
}
```

### üîë Key Points:
- **Smart Pointers**: Automatic memory management
- **unique_ptr**: Exclusive ownership, no copying
- **shared_ptr**: Shared ownership with reference counting
- **weak_ptr**: Non-owning observer, prevents circular references
- **RAII**: Resource Acquisition Is Initialization

---

## 1Ô∏è‚É£1Ô∏è‚É£ Best Practices

### üîπ SOLID Principles Implementation
```cpp
#include <iostream>
#include <vector>
#include <memory>
using namespace std;

// S - Single Responsibility Principle
class Logger {
public:
    virtual void log(const string& message) = 0;
    virtual ~Logger() = default;
};

class FileLogger : public Logger {
public:
    void log(const string& message) override {
        cout << "[FILE] " << message << endl;
    }
};

class ConsoleLogger : public Logger {
public:
    void log(const string& message) override {
        cout << "[CONSOLE] " << message << endl;
    }
};

// O - Open/Closed Principle
class Shape {
public:
    virtual double area() const = 0;
    virtual void draw() const = 0;
    virtual ~Shape() = default;
};

class Circle : public Shape {
private:
    double radius;
    
public:
    Circle(double r) : radius(r) {}
    
    double area() const override {
        return 3.14159 * radius * radius;
    }
    
    void draw() const override {
        cout << "Drawing circle with radius " << radius << endl;
    }
};

class Rectangle : public Shape {
private:
    double width, height;
    
public:
    Rectangle(double w, double h) : width(w), height(h) {}
    
    double area() const override {
        return width * height;
    }
    
    void draw() const override {
        cout << "Drawing rectangle " << width << "x" << height << endl;
    }
};

// Can add new shapes without modifying existing code
class Triangle : public Shape {
private:
    double base, height;
    
public:
    Triangle(double b, double h) : base(b), height(h) {}
    
    double area() const override {
        return 0.5 * base * height;
    }
    
    void draw() const override {
        cout << "Drawing triangle with base " << base << " and height " << height << endl;
    }
};

// L - Liskov Substitution Principle
class Bird {
public:
    virtual void eat() {
        cout << "Bird is eating" << endl;
    }
    virtual ~Bird() = default;
};

class FlyingBird : public Bird {
public:
    virtual void fly() {
        cout << "Bird is flying" << endl;
    }
};

class Sparrow : public FlyingBird {
public:
    void eat() override {
        cout << "Sparrow is eating seeds" << endl;
    }
    
    void fly() override {
        cout << "Sparrow is flying quickly" << endl;
    }
};

class Penguin : public Bird {  // Penguin doesn't inherit from FlyingBird
public:
    void eat() override {
        cout << "Penguin is eating fish" << endl;
    }
    
    void swim() {
        cout << "Penguin is swimming" << endl;
    }
};

// I - Interface Segregation Principle
class Readable {
public:
    virtual void read() = 0;
    virtual ~Readable() = default;
};

class Writable {
public:
    virtual void write() = 0;
    virtual ~Writable() = default;
};

class Executable {
public:
    virtual void execute() = 0;
    virtual ~Executable() = default;
};

class TextFile : public Readable, public Writable {
public:
    void read() override {
        cout << "Reading text file" << endl;
    }
    
    void write() override {
        cout << "Writing to text file" << endl;
    }
};

class ExecutableFile : public Readable, public Executable {
public:
    void read() override {
        cout << "Reading executable file" << endl;
    }
    
    void execute() override {
        cout << "Executing program" << endl;
    }
};

// D - Dependency Inversion Principle
class EmailService {
public:
    virtual void sendEmail(const string& message) = 0;
    virtual ~EmailService() = default;
};

class GmailService : public EmailService {
public:
    void sendEmail(const string& message) override {
        cout << "Sending via Gmail: " << message << endl;
    }
};

class OutlookService : public EmailService {
public:
    void sendEmail(const string& message) override {
        cout << "Sending via Outlook: " << message << endl;
    }
};

class NotificationManager {
private:
    unique_ptr<EmailService> emailService;
    unique_ptr<Logger> logger;
    
public:
    NotificationManager(unique_ptr<EmailService> email, unique_ptr<Logger> log)
        : emailService(move(email)), logger(move(log)) {}
    
    void sendNotification(const string& message) {
        logger->log("Preparing to send notification: " + message);
        emailService->sendEmail(message);
        logger->log("Notification sent successfully");
    }
};

void demonstrateSOLID() {
    cout << "\n=== SOLID Principles Demo ===" << endl;
    
    // Dependency Inversion - can easily switch implementations
    auto gmail = make_unique<GmailService>();
    auto fileLogger = make_unique<FileLogger>();
    
    NotificationManager manager(move(gmail), move(fileLogger));
    manager.sendNotification("Welcome to our service!");
    
    // Open/Closed - adding new shapes without modifying existing code
    vector<unique_ptr<Shape>> shapes;
    shapes.push_back(make_unique<Circle>(5.0));
    shapes.push_back(make_unique<Rectangle>(4.0, 6.0));
    shapes.push_back(make_unique<Triangle>(3.0, 4.0));
    
    cout << "\nDrawing shapes:" << endl;
    for(const auto& shape : shapes) {
        shape->draw();
        cout << "Area: " << shape->area() << endl;
    }
    
    // Liskov Substitution - can use derived classes wherever base is expected
    vector<unique_ptr<Bird>> birds;
    birds.push_back(make_unique<Sparrow>());
    birds.push_back(make_unique<Penguin>());
    
    cout << "\nBird behaviors:" << endl;
    for(const auto& bird : birds) {
        bird->eat(); // All birds can eat
    }
    
    // Interface Segregation - classes implement only what they need
    TextFile textFile;
    ExecutableFile exeFile;
    
    textFile.read();
    textFile.write();
    
    exeFile.read();
    exeFile.execute();
}
```

### üîπ Design Patterns

#### Singleton Pattern
```cpp
#include <iostream>
#include <mutex>
using namespace std;

class DatabaseConnection {
private:
    static DatabaseConnection* instance;
    static mutex mtx;
    string connectionString;
    
    // Private constructor
    DatabaseConnection(const string& connStr = "default_connection") 
        : connectionString(connStr) {
        cout << "Database connection created: " << connectionString << endl;
    }
    
    // Delete copy constructor and assignment operator
    DatabaseConnection(const DatabaseConnection&) = delete;
    DatabaseConnection& operator=(const DatabaseConnection&) = delete;
    
public:
    static DatabaseConnection* getInstance(const string& connStr = "default_connection") {
        lock_guard<mutex> lock(mtx); // Thread-safe
        if(instance == nullptr) {
            instance = new DatabaseConnection(connStr);
        }
        return instance;
    }
    
    void connect() {
        cout << "Connected to database: " << connectionString << endl;
    }
    
    void disconnect() {
        cout << "Disconnected from database" << endl;
    }
    
    void executeQuery(const string& query) {
        cout << "Executing query: " << query << endl;
    }
    
    static void cleanup() {
        delete instance;
        instance = nullptr;
    }
};

// Static member definitions
DatabaseConnection* DatabaseConnection::instance = nullptr;
mutex DatabaseConnection::mtx;

#### Factory Pattern
class Animal {
public:
    virtual void makeSound() = 0;
    virtual string getType() = 0;
    virtual ~Animal() = default;
};

class Dog : public Animal {
public:
    void makeSound() override {
        cout << "Woof! Woof!" << endl;
    }
    
    string getType() override {
        return "Dog";
    }
};

class Cat : public Animal {
public:
    void makeSound() override {
        cout << "Meow! Meow!" << endl;
    }
    
    string getType() override {
        return "Cat";
    }
};

class Bird : public Animal {
public:
    void makeSound() override {
        cout << "Tweet! Tweet!" << endl;
    }
    
    string getType() override {
        return "Bird";
    }
};

class AnimalFactory {
public:
    static unique_ptr<Animal> createAnimal(const string& type) {
        if(type == "dog") {
            return make_unique<Dog>();
        } else if(type == "cat") {
            return make_unique<Cat>();
        } else if(type == "bird") {
            return make_unique<Bird>();
        }
        return nullptr;
    }
    
    static vector<string> getSupportedTypes() {
        return {"dog", "cat", "bird"};
    }
};

#### Observer Pattern
class Observer {
public:
    virtual void update(const string& message) = 0;
    virtual string getName() = 0;
    virtual ~Observer() = default;
};

class Subject {
private:
    vector<Observer*> observers;
    string state;
    
public:
    void attach(Observer* observer) {
        observers.push_back(observer);
        cout << observer->getName() << " subscribed to notifications" << endl;
    }
    
    void detach(Observer* observer) {
        auto it = find(observers.begin(), observers.end(), observer);
        if(it != observers.end()) {
            observers.erase(it);
            cout << observer->getName() << " unsubscribed from notifications" << endl;
        }
    }
    
    void notify() {
        cout << "\nNotifying " << observers.size() << " observers..." << endl;
        for(Observer* observer : observers) {
            observer->update(state);
        }
    }
    
    void setState(const string& newState) {
        state = newState;
        cout << "State changed to: " << state << endl;
        notify();
    }
    
    string getState() const {
        return state;
    }
};

class EmailSubscriber : public Observer {
private:
    string email;
    
public:
    EmailSubscriber(const string& emailAddr) : email(emailAddr) {}
    
    void update(const string& message) override {
        cout << "Email sent to " << email << ": " << message << endl;
    }
    
    string getName() override {
        return "EmailSubscriber(" + email + ")";
    }
};

class SMSSubscriber : public Observer {
private:
    string phoneNumber;
    
public:
    SMSSubscriber(const string& phone) : phoneNumber(phone) {}
    
    void update(const string& message) override {
        cout << "SMS sent to " << phoneNumber << ": " << message << endl;
    }
    
    string getName() override {
        return "SMSSubscriber(" + phoneNumber + ")";
    }
};

void demonstrateDesignPatterns() {
    cout << "\n=== Design Patterns Demo ===" << endl;
    
    // Singleton Pattern
    cout << "\n--- Singleton Pattern ---" << endl;
    auto db1 = DatabaseConnection::getInstance("primary_db");
    auto db2 = DatabaseConnection::getInstance("secondary_db"); // Same instance
    
    db1->connect();
    db1->executeQuery("SELECT * FROM users");
    
    cout << "db1 == db2: " << (db1 == db2 ? "true" : "false") << endl;
    
    // Factory Pattern
    cout << "\n--- Factory Pattern ---" << endl;
    vector<string> animalTypes = {"dog", "cat", "bird", "elephant"};
    
    for(const string& type : animalTypes) {
        auto animal = AnimalFactory::createAnimal(type);
        if(animal) {
            cout << "Created " << animal->getType() << ": ";
            animal->makeSound();
        } else {
            cout << "Cannot create animal of type: " << type << endl;
        }
    }
    
    // Observer Pattern
    cout << "\n--- Observer Pattern ---" << endl;
    Subject newsAgency;
    
    EmailSubscriber email1("john@email.com");
    EmailSubscriber email2("alice@email.com");
    SMSSubscriber sms1("123-456-7890");
    SMSSubscriber sms2("098-765-4321");
    
    newsAgency.attach(&email1);
    newsAgency.attach(&email2);
    newsAgency.attach(&sms1);
    
    newsAgency.setState("Breaking News: New C++ Standard Released!");
    
    newsAgency.attach(&sms2);
    newsAgency.setState("Weather Update: Sunny with 25¬∞C");
    
    newsAgency.detach(&email1);
    newsAgency.setState("Sports: Local team wins championship!");
    
    // Cleanup
    DatabaseConnection::cleanup();
}
```

### üîπ Exception Handling Best Practices
```cpp
#include <iostream>
#include <stdexcept>
#include <fstream>
#include <memory>
using namespace std;

// Custom exception classes
class ValidationException : public runtime_error {
public:
    ValidationException(const string& message) : runtime_error("Validation Error: " + message) {}
};

class BusinessLogicException : public logic_error {
public:
    BusinessLogicException(const string& message) : logic_error("Business Logic Error: " + message) {}
};

class ResourceException : public runtime_error {
public:
    ResourceException(const string& message) : runtime_error("Resource Error: " + message) {}
};

class BankAccount {
private:
    string accountNumber;
    double balance;
    bool isActive;
    
public:
    BankAccount(const string& accNum, double initialBalance) 
        : accountNumber(accNum), balance(initialBalance), isActive(true) {
        
        if(accNum.empty()) {
            throw ValidationException("Account number cannot be empty");
        }
        
        if(initialBalance < 0) {
            throw ValidationException("Initial balance cannot be negative");
        }
        
        cout << "Account created: " << accountNumber << " with balance $" << balance << endl;
    }
    
    void deposit(double amount) {
        if(!isActive) {
            throw BusinessLogicException("Cannot deposit to inactive account");
        }
        
        if(amount <= 0) {
            throw ValidationException("Deposit amount must be positive");
        }
        
        balance += amount;
        cout << "Deposited $" << amount << ". New balance: $" << balance << endl;
    }
    
    void withdraw(double amount) {
        if(!isActive) {
            throw BusinessLogicException("Cannot withdraw from inactive account");
        }
        
        if(amount <= 0) {
            throw ValidationException("Withdrawal amount must be positive");
        }
        
        if(amount > balance) {
            throw BusinessLogicException("Insufficient funds. Balance: $" + to_string(balance) + 
                                       ", Requested: $" + to_string(amount));
        }
        
        balance -= amount;
        cout << "Withdrew $" << amount << ". New balance: $" << balance << endl;
    }
    
    void closeAccount() {
        if(!isActive) {
            throw BusinessLogicException("Account is already closed");
        }
        
        if(balance > 0) {
            throw BusinessLogicException("Cannot close account with positive balance: $" + to_string(balance));
        }
        
        isActive = false;
        cout << "Account " << accountNumber << " has been closed" << endl;
    }
    
    double getBalance() const { return balance; }
    bool getIsActive() const { return isActive; }
    string getAccountNumber() const { return accountNumber; }
};

class FileManager {
public:
    static string readFile(const string& filename) {
        ifstream file(filename);
        
        if(!file.is_open()) {
            throw ResourceException("Cannot open file: " + filename);
        }
        
        string content;
        string line;
        
        try {
            while(getline(file, line)) {
                content += line + "\n";
            }
        } catch(const ios_base::failure& e) {
            throw ResourceException("Error reading file: " + filename + " - " + e.what());
        }
        
        if(file.bad()) {
            throw ResourceException("File corruption detected: " + filename);
        }
        
        return content;
    }
    
    static void writeFile(const string& filename, const string& content) {
        ofstream file(filename);
        
        if(!file.is_open()) {
            throw ResourceException("Cannot create file: " + filename);
        }
        
        try {
            file << content;
            file.flush();
            
            if(file.fail()) {
                throw ResourceException("Failed to write to file: " + filename);
            }
        } catch(const ios_base::failure& e) {
            throw ResourceException("Error writing file: " + filename + " - " + e.what());
        }
    }
};

void demonstrateExceptionHandling() {
    cout << "\n=== Exception Handling Demo ===" << endl;
    
    // Bank account operations with exception handling
    try {
        BankAccount account("ACC-001", 1000.0);
        
        account.deposit(500.0);
        account.withdraw(200.0);
        
        // This will throw an exception
        account.withdraw(2000.0);
        
    } catch(const ValidationException& e) {
        cout << "Validation Error: " << e.what() << endl;
    } catch(const BusinessLogicException& e) {
        cout << "Business Logic Error: " << e.what() << endl;
    } catch(const exception& e) {
        cout << "Unexpected error: " << e.what() << endl;
    }
    
    // Multiple exception types
    cout << "\n--- Testing Various Exceptions ---" << endl;
    
    vector<function<void()>> testCases = {
        []() { BankAccount("", 100); },                    // ValidationException
        []() { BankAccount("ACC-002", -50); },             // ValidationException
        []() { 
            BankAccount acc("ACC-003", 100);
            acc.withdraw(-10);                             // ValidationException
        },
        []() {
            BankAccount acc("ACC-004", 100);
            acc.withdraw(200);                             // BusinessLogicException
        },
        []() {
            BankAccount acc("ACC-005", 0);
            acc.closeAccount();
            acc.deposit(50);                               // BusinessLogicException
        }
    };
    
    for(size_t i = 0; i < testCases.size(); i++) {
        cout << "\nTest case " << (i + 1) << ": ";
        try {
            testCases[i]();
            cout << "No exception thrown" << endl;
        } catch(const ValidationException& e) {
            cout << "ValidationException - " << e.what() << endl;
        } catch(const BusinessLogicException& e) {
            cout << "BusinessLogicException - " << e.what() << endl;
        } catch(const exception& e) {
            cout << "Other exception - " << e.what() << endl;
        }
    }
    
    // Resource management with exceptions
    cout << "\n--- File Operations with Exception Handling ---" << endl;
    
    try {
        // Try to read a non-existent file
        string content = FileManager::readFile("nonexistent.txt");
        cout << "File content: " << content << endl;
    } catch(const ResourceException& e) {
        cout << "File operation failed: " << e.what() << endl;
    }
    
    try {
        // Create and write a file
        FileManager::writeFile("test.txt", "Hello, World!\nThis is a test file.");
        cout << "File written successfully" << endl;
        
        // Read it back
        string content = FileManager::readFile("test.txt");
        cout << "File content read:\n" << content << endl;
    } catch(const ResourceException& e) {
        cout << "File operation failed: " << e.what() << endl;
    }
}
```

### üîπ Performance Optimization Tips
```cpp
#include <iostream>
#include <vector>
#include <chrono>
#include <algorithm>
using namespace std;
using namespace chrono;

class PerformanceOptimizedClass {
private:
    vector<int> data;
    mutable bool cacheValid = false;
    mutable double cachedAverage = 0.0;
    
public:
    // Rule of 5 implementation
    PerformanceOptimizedClass() = default;
    
    // Copy constructor
    PerformanceOptimizedClass(const PerformanceOptimizedClass& other) 
        : data(other.data), cacheValid(false) {}
    
    // Move constructor (noexcept for optimization)
    PerformanceOptimizedClass(PerformanceOptimizedClass&& other) noexcept
        : data(move(other.data)), cacheValid(other.cacheValid), cachedAverage(other.cachedAverage) {
        other.cacheValid = false;
    }
    
    // Copy assignment
    PerformanceOptimizedClass& operator=(const PerformanceOptimizedClass& other) {
        if(this != &other) {
            data = other.data;
            cacheValid = false;
        }
        return *this;
    }
    
    // Move assignment (noexcept for optimization)
    PerformanceOptimizedClass& operator=(PerformanceOptimizedClass&& other) noexcept {
        if(this != &other) {
            data = move(other.data);
            cacheValid = other.cacheValid;
            cachedAverage = other.cachedAverage;
            other.cacheValid = false;
        }
        return *this;
    }
    
    ~PerformanceOptimizedClass() = default;
    
    // Reserve space to avoid multiple reallocations
    void reserve(size_t capacity) {
        data.reserve(capacity);
    }
    
    // Efficient bulk insertion
    void addData(const vector<int>& newData) {
        data.reserve(data.size() + newData.size());
        data.insert(data.end(), newData.begin(), newData.end());
        cacheValid = false;
    }
    
    // Pass by const reference for large objects
    void processLargeData(const vector<int>& largeInput) {
        data.clear();
        data.reserve(largeInput.size());
        
        // Use algorithms instead of manual loops
        copy_if(largeInput.begin(), largeInput.end(), back_inserter(data),
                [](int x) { return x > 0; });
        
        cacheValid = false;
    }
    
    // Lazy evaluation with caching
    double getAverage() const {
        if(!cacheValid) {
            if(data.empty()) {
                cachedAverage = 0.0;
            } else {
                long long sum = 0;
                for(int value : data) {
                    sum += value;
                }
                cachedAverage = static_cast<double>(sum) / data.size();
            }
            cacheValid = true;
        }
        return cachedAverage;
    }
    
    // Return by const reference when possible
    const vector<int>& getData() const {
        return data;
    }
    
    // Inline small functions
    inline size_t size() const { return data.size(); }
    inline bool empty() const { return data.empty(); }
    
    // Use emplace instead of push for complex objects
    template<typename... Args>
    void emplaceData(Args&&... args) {
        data.emplace_back(forward<Args>(args)...);
        cacheValid = false;
    }
};

void demonstratePerformanceOptimizations() {
    cout << "\n=== Performance Optimization Demo ===" << endl;
    
    // Timing utility
    auto timeFunction = [](const string& name, function<void()> func) {
        auto start = high_resolution_clock::now();
        func();
        auto end = high_resolution_clock::now();
        auto duration = duration_cast<microseconds>(end - start);
        cout << name << " took: " << duration.count() << " microseconds" << endl;
    };
    
    const size_t dataSize = 100000;
    vector<int> testData(dataSize);
    
    // Generate test data
    for(size_t i = 0; i < dataSize; i++) {
        testData[i] = static_cast<int>(i % 1000 - 500);
    }
    
    // Test 1: Reserve vs No Reserve
    cout << "\n--- Memory Allocation Optimization ---" << endl;
    
    timeFunction("Without reserve", [&]() {
        PerformanceOptimizedClass obj1;
        for(int value : testData) {
            obj1.emplaceData(value);
        }
    });
    
    timeFunction("With reserve", [&]() {
        PerformanceOptimizedClass obj2;
        obj2.reserve(dataSize);
        for(int value : testData) {
            obj2.emplaceData(value);
        }
    });
    
    // Test 2: Bulk insertion vs Individual insertion
    cout << "\n--- Bulk vs Individual Insertion ---" << endl;
    
    timeFunction("Individual insertion", [&]() {
        PerformanceOptimizedClass obj;
        obj.reserve(dataSize);
        for(int value : testData) {
            obj.emplaceData(value);
        }
    });
    
    timeFunction("Bulk insertion", [&]() {
        PerformanceOptimizedClass obj;
        obj.addData(testData);
    });
    
    // Test 3: Copy vs Move semantics
    cout << "\n--- Copy vs Move Semantics ---" << endl;
    
    PerformanceOptimizedClass sourceObj;
    sourceObj.addData(testData);
    
    timeFunction("Copy constructor", [&]() {
        PerformanceOptimizedClass copied = sourceObj;
        (void)copied; // Suppress unused variable warning
    });
    
    timeFunction("Move constructor", [&]() {
        PerformanceOptimizedClass moved = move(PerformanceOptimizedClass(sourceObj));
        (void)moved; // Suppress unused variable warning
    });
    
    // Test 4: Caching effectiveness
    cout << "\n--- Caching Optimization ---" << endl;
    
    PerformanceOptimizedClass objWithCache;
    objWithCache.addData(testData);
    
    timeFunction("First average calculation (no cache)", [&]() {
        double avg = objWithCache.getAverage();
        (void)avg; // Suppress unused variable warning
    });
    
    timeFunction("Second average calculation (cached)", [&]() {
        double avg = objWithCache.getAverage();
        (void)avg; // Suppress unused variable warning
    });
    
    cout << "Average value: " << objWithCache.getAverage() << endl;
}

int main() {
    // Run all demonstrations
    demonstrateSOLID();
    demonstrateDesignPatterns();
    demonstrateExceptionHandling();
    demonstratePerformanceOptimizations();
    
    return 0;
}
```

### üîë Best Practices Summary:

#### Code Organization:
- **Single Responsibility**: Each class should have one reason to change
- **DRY Principle**: Don't Repeat Yourself
- **KISS Principle**: Keep It Simple, Stupid
- **Composition over Inheritance**: Prefer has-a over is-a relationships

#### Memory Management:
- Use smart pointers instead of raw pointers
- Follow RAII (Resource Acquisition Is Initialization)
- Implement Rule of 3/5 when managing resources
- Use move semantics for better performance

#### Exception Safety:
- Use RAII for automatic cleanup
- Throw by value, catch by const reference
- Create specific exception types for different error conditions
- Provide strong exception safety guarantee when possible

#### Performance:
- Pass large objects by const reference
- Use move semantics for temporary objects
- Reserve memory for containers when size is known
- Use algorithms instead of manual loops
- Implement lazy evaluation with caching
- Prefer `emplace` over `push` for complex objects

---

## üìñ Complete Reference Summary

### üéØ Core OOP Concepts Checklist:
- ‚úÖ **Classes & Objects**: Blueprint and instances
- ‚úÖ **Encapsulation**: Data hiding with getters/setters
- ‚úÖ **Inheritance**: Single, multiple, multilevel, hierarchical
- ‚úÖ **Polymorphism**: Compile-time (overloading) and runtime (overriding)
- ‚úÖ **Abstraction**: Pure virtual functions and abstract classes
- ‚úÖ **Interface vs Abstract**: Contract vs partial implementation

### üîß Advanced Features:
- ‚úÖ **Constructors**: Default, parameterized, copy, move
- ‚úÖ **Destructors**: Automatic cleanup and virtual destructors
- ‚úÖ **Access Modifiers**: public, protected, private
- ‚úÖ **Friend Functions/Classes**: Controlled access to private members
- ‚úÖ **Static Members**: Class-level data and methods
- ‚úÖ **Nested Classes**: Organization and encapsulation
- ‚úÖ **Templates**: Generic programming
- ‚úÖ **Smart Pointers**: Modern memory management

### üèóÔ∏è Design Patterns:
- ‚úÖ **Singleton**: Single instance creation
- ‚úÖ **Factory**: Object creation abstraction
- ‚úÖ **Observer**: Event notification system
- ‚úÖ **SOLID Principles**: Clean architecture guidelines

### ‚ö° Performance & Best Practices:
- ‚úÖ **Exception Handling**: Robust error management
- ‚úÖ **Memory Optimization**: Efficient resource usage
- ‚úÖ **Move Semantics**: Performance improvements
- ‚úÖ **RAII**: Automatic resource management

---

## üéì Final Notes

This comprehensive guide covers every aspect of C++ Object-Oriented Programming with practical, clean examples. Each concept builds upon the previous ones, providing a solid foundation for advanced C++ development.

**Key Takeaways:**
1. **Understand the fundamentals** before moving to advanced topics
2. **Practice with real-world examples** to solidify concepts
3. **Apply best practices** from the beginning
4. **Use modern C++ features** for better code quality
5. **Always consider performance** and memory management

**Next Steps:**
- Practice implementing these concepts in your own projects
- Study existing codebases to see OOP in action
- Learn about advanced topics like template metaprogramming
- Explore modern C++ standards (C++17, C++20, C++23)

Remember: Good OOP design is about creating maintainable, extensible, and robust software. Focus on writing clean, readable code that follows established principles and patterns!
