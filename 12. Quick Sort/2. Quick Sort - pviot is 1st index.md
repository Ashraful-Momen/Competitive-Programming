Perfect 👍
I’ll give you a **clean C++ note-style explanation** directly inside a `.cpp` file format so it feels like both code + documentation.

---

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
    ===============================================
    Quick Sort Algorithm (First Element as Pivot)
    ===============================================

    ❌ Stability:
        - Quick Sort is NOT stable
        - Merge Sort IS stable

    🎯 Idea:
        Quick Sort uses "Divide and Conquer":
        1. Pick pivot (here = first element)
        2. Partition the array into two halves:
           - Left side < pivot
           - Right side >= pivot
        3. Recursively apply Quick Sort on sub-arrays

    ⚡ Partition Method: Hoare's Partition Scheme
        - pivot = arr[low]
        - i = low, j = high
        - Move i → until element >= pivot
        - Move j ← until element <= pivot
        - Swap if i < j
        - Finally swap pivot (arr[low]) with arr[j]
        - Return j = final pivot position

    🕒 Time Complexity:
        - Best / Average: O(n log n)
        - Worst: O(n^2)  (if pivot is always min/max)
    💾 Space Complexity:
        - O(log n) due to recursion
*/

// Partition function (Hoare's partition, first element as pivot)
int partition(int arr[], int low, int high) {
    int pivot = arr[low];  // pivot = first element
    int i = low, j = high;

    while (i < j) {
        // move i right until element >= pivot
        while (arr[i] <= pivot && i < high) i++;

        // move j left until element <= pivot
        while (arr[j] > pivot) j--;

        // swap if i < j
        if (i < j) swap(arr[i], arr[j]);
    }

    // put pivot in correct position
    swap(arr[low], arr[j]);
    return j; // pivot index
}

// Quick Sort function
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pivotIndex = partition(arr, low, high);

        // sort left side
        quickSort(arr, low, pivotIndex - 1);

        // sort right side
        quickSort(arr, pivotIndex + 1, high);
    }
}

// Print array function
void printArray(int arr[], int n) {
    cout << "[ ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << "]\n";
}

// Driver code
int main() {
    int arr[] = {8, 3, 5, 4, 7, 6, 1, 2};
    int n = sizeof(arr) / sizeof(arr[0]);

    cout << "Original array: ";
    printArray(arr, n);

    quickSort(arr, 0, n - 1);

    cout << "Sorted array:   ";
    printArray(arr, n);

    return 0;
}

/*
    ✅ Example Run:

    Input:
        [ 8 3 5 4 7 6 1 2 ]

    Process (Pivot = 8 first):
        Partition → Pivot goes to correct position
        Recursively sort left and right halves

    Output:
        [ 1 2 3 4 5 6 7 8 ]
*/
```

---

Would you like me to also add an **ASCII trace of the partitioning steps** (like showing `i` and `j` movements visually inside comments), so you can follow exactly how elements swap for each pivot?
