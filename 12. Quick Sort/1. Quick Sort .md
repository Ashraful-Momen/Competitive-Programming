# Quick Sort Algorithm - Complete Notes (First Element as Pivot)

## ‚ùå Correction: Stability Statement
**Quick Sort is NOT stable, but Merge Sort IS stable**
- **Stable**: Maintains relative order of equal elements
- **Quick Sort**: Unstable (can change relative order of equal elements)
- **Merge Sort**: Stable (preserves relative order of equal elements)

## üéØ Quick Sort Algorithm Explanation

### How Quick Sort Works - Simple Understanding

Quick Sort follows **"Divide and Conquer"** strategy:
1. **Pick** the first element as pivot
2. **Partition** array using two pointers - all smaller elements go left, larger go right
3. **Recursively** sort the left and right sub-arrays

### Example Understanding: Array [10, 2, 8, 7]

#### Step 1: Choose Pivot (First Element)
```
Array: [10, 2, 8, 7]
        ‚Üë
    pivot = 10
```

#### Step 2: Partition Using Two Pointers (Hoare Scheme)
```
Initial setup:
Array: [10, 2, 8, 7]
        ‚Üë          ‚Üë
       i=0        j=3
    pivot=10

Step 1: Move i right until arr[i] >= pivot
- arr[0]=10 >= 10? YES ‚Üí i stops at 0

Step 2: Move j left until arr[j] < pivot  
- arr[3]=7 < 10? YES ‚Üí j stops at 3

Step 3: Since i < j, swap arr[i] and arr[j]
Array: [7, 2, 8, 10]
        ‚Üë          ‚Üë
       i=0        j=3

Step 4: Continue process
- i moves right: arr[1]=2 <= 10, arr[2]=8 <= 10, arr[3]=10 >= 10 ‚Üí i=3
- j moves left: arr[3]=10 > 10? NO, arr[2]=8 > 10? NO, arr[1]=2 > 10? NO ‚Üí j=1

Now i >= j (i=3, j=1), so loop ends

Step 5: Place pivot in correct position
Swap arr[l] with arr[j]: swap arr[0] with arr[1]
Array: [2, 7, 8, 10]
           ‚Üë      ‚Üë
        j=1   pivot now at position 1
```

#### Step 3: Recursively Sort Sub-arrays
```
Left sub-array: [2] ‚Üí already sorted
Right sub-array: [8, 10] ‚Üí apply Quick Sort again
```

## üìù Pseudocode

```
ALGORITHM QuickSort(array, l, h):
    IF l < h THEN
        p = Partition(array, l, h)
        QuickSort(array, l, p - 1)     // Sort left sub-array
        QuickSort(array, p + 1, h)     // Sort right sub-array

ALGORITHM Partition(array, l, h):
    pivot = array[l]                   // Choose first element as pivot
    i = l                              // Left pointer
    j = h                              // Right pointer
    
    WHILE i < j DO
        // Move i right until element >= pivot
        WHILE array[i] <= pivot AND i < h DO
            i = i + 1
        END WHILE
        
        // Move j left until element < pivot
        WHILE array[j] > pivot DO
            j = j - 1
        END WHILE
        
        // Swap if pointers haven't crossed
        IF i < j THEN
            SWAP array[i] with array[j]
        END IF
    END WHILE
    
    SWAP array[l] with array[j]        // Place pivot in correct position
    RETURN j                           // Return pivot position
```

## üíª Complete C++ Code Implementation

```cpp
#include <bits/stdc++.h>
using namespace std;

// Partition function: places pivot (first element) in correct position
int partition(int arr[], int l, int h) {
    int pivot = arr[l];               // pivot is first element
    int i = l, j = h;                 // Initialize two pointers
    
    while (i < j) {
        // Move i right until element >= pivot
        while (arr[i] <= pivot && i < h)
            i++;
        
        // Move j left until element < pivot
        while (arr[j] > pivot)
            j--;
        
        // Swap if i < j
        if (i < j)
            swap(arr[i], arr[j]);
    }
    
    // Place pivot in correct position
    swap(arr[l], arr[j]);
    return j;                         // return pivot index
}

// Quick sort function
void quickSort(int arr[], int l, int h) {
    if (l < h) {
        int p = partition(arr, l, h);
        quickSort(arr, l, p - 1);     // sort left partition
        quickSort(arr, p + 1, h);     // sort right partition
    }
}

int main() {
    int arr[] = {10, 2, 8, 7};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    cout << "Original array: ";
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
    cout << endl;
    
    quickSort(arr, 0, n - 1);
    
    cout << "Sorted array: ";
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
    cout << endl;
    
    return 0;
}
```

## üìä Line-by-Line Code Explanation

### Partition Function Detailed Breakdown:

```cpp
int partition(int arr[], int l, int h) {
```
**Line 1**: Function declaration
- `arr[]`: Input array to partition
- `l`: Starting index of current partition (left boundary)
- `h`: Ending index of current partition (right boundary)
- **Returns**: Final position of pivot after partitioning

```cpp
int pivot = arr[l];
```
**Line 2**: Select pivot element
- Always choose the **first element** as pivot
- `arr[l]` = first element in current partition range

```cpp
int i = l, j = h;
```
**Line 3**: Initialize two pointers
- `i` starts from left boundary (`l`)
- `j` starts from right boundary (`h`)
- These pointers will move towards each other

```cpp
while (i < j) {
```
**Line 4**: Main partitioning loop
- Continue until pointers meet or cross
- When `i >= j`, partitioning is complete

```cpp
while (arr[i] <= pivot && i < h)
    i++;
```
**Line 5-6**: Move left pointer right
- Skip elements that are ‚â§ pivot (they belong on left side)
- Stop when finding element > pivot OR reaching end
- **Important**: `i < h` prevents going out of bounds

```cpp
while (arr[j] > pivot)
    j--;
```
**Line 7-8**: Move right pointer left
- Skip elements that are > pivot (they belong on right side)  
- Stop when finding element ‚â§ pivot
- **Note**: No bounds check needed as `arr[l]` (pivot) will stop `j`

```cpp
if (i < j)
    swap(arr[i], arr[j]);
```
**Line 9-10**: Swap elements if pointers haven't crossed
- Only swap when `i < j` (pointers haven't met)
- This places smaller element on left, larger on right

```cpp
swap(arr[l], arr[j]);
```
**Line 11**: Place pivot in its correct final position
- `j` now points to the correct position for pivot
- Swap original pivot position (`l`) with final position (`j`)

```cpp
return j;
```
**Line 12**: Return pivot's final position
- `j` is where the pivot now resides
- This position divides array into left and right sub-arrays

## üé® ASCII Visualization with Complete Example

### Example Array: [10, 2, 8, 7]

#### **Level 0: Initial Call quickSort(arr, 0, 3)**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ LEVEL 0: quickSort([10, 2, 8, 7], 0, 3)            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Step 1: Partition around pivot = 10 (first element)

Initial state:
Array: [10, 2, 8, 7]
        ‚Üë          ‚Üë
       i=0        j=3
    pivot=10

Iteration 1:
- Move i right: 10 <= 10? YES, but i < h? YES ‚Üí i=1
                2 <= 10? YES, i < h? YES ‚Üí i=2  
                8 <= 10? YES, i < h? YES ‚Üí i=3
                7 <= 10? YES, i < h? NO ‚Üí i stops at 3
- Move j left:  7 > 10? NO ‚Üí j stops at 3
- Check i < j:  3 < 3? NO ‚Üí don't swap

Loop ends (i >= j)

Final step: swap(arr[0], arr[3])
Array: [7, 2, 8, 10]
           ‚Üë      ‚Üë
        j=3   pivot at position 3

Wait, let me recalculate this more carefully...

Actually, let me trace through this step by step:

Initial: [10, 2, 8, 7], i=0, j=3, pivot=10

First inner while loop (move i right):
- i=0: arr[0]=10 <= 10? YES, i < 3? YES ‚Üí i=1  
- i=1: arr[1]=2 <= 10? YES, i < 3? YES ‚Üí i=2
- i=2: arr[2]=8 <= 10? YES, i < 3? YES ‚Üí i=3
- i=3: arr[3]=7 <= 10? YES, i < 3? NO ‚Üí i stops at 3

Second inner while loop (move j left):
- j=3: arr[3]=7 > 10? NO ‚Üí j stops at 3

Check i < j: 3 < 3? NO ‚Üí don't swap

Now i >= j, so main while loop ends.
Final swap: swap(arr[0], arr[3])
Result: [7, 2, 8, 10]

Return j = 3
```

Wait, this doesn't seem right. Let me trace through the actual algorithm more carefully:

```
Initial: [10, 2, 8, 7], l=0, h=3, pivot=10
i=0, j=3

Main while loop: while (i < j) // 0 < 3? YES

Inner while 1: while (arr[i] <= pivot && i < h)
- i=0: arr[0]=10 <= 10? YES, 0 < 3? YES ‚Üí i++ ‚Üí i=1
- i=1: arr[1]=2 <= 10? YES, 1 < 3? YES ‚Üí i++ ‚Üí i=2  
- i=2: arr[2]=8 <= 10? YES, 2 < 3? YES ‚Üí i++ ‚Üí i=3
- i=3: arr[3]=7 <= 10? YES, 3 < 3? NO ‚Üí stop, i=3

Inner while 2: while (arr[j] > pivot)  
- j=3: arr[3]=7 > 10? NO ‚Üí stop, j=3

Check: if (i < j) // 3 < 3? NO ‚Üí don't swap

Back to main while: while (i < j) // 3 < 3? NO ‚Üí exit

Final: swap(arr[l], arr[j]) = swap(arr[0], arr[3])
Array becomes: [7, 2, 8, 10]
Return j=3
```

Actually, I think there might be an issue with my trace. Let me look at this algorithm again. The issue might be that when all elements are <= pivot except the last one, this creates a problem. Let me try a different example to understand better.

Let me use the example [10, 2, 8, 7] but trace it very carefully:

```
partition([10, 2, 8, 7], 0, 3):
pivot = arr[0] = 10
i = 0, j = 3

while (i < j): // 0 < 3? YES

  while (arr[i] <= pivot && i < h): // while (arr[i] <= 10 && i < 3)
    i=0: arr[0]=10 <= 10? YES, 0 < 3? YES ‚Üí i++ ‚Üí i=1
    i=1: arr[1]=2 <= 10? YES, 1 < 3? YES ‚Üí i++ ‚Üí i=2
    i=2: arr[2]=8 <= 10? YES, 2 < 3? YES ‚Üí i++ ‚Üí i=3  
    i=3: arr[3]=7 <= 10? YES, 3 < 3? NO ‚Üí exit loop
  // i is now 3
  
  while (arr[j] > pivot): // while (arr[j] > 10)
    j=3: arr[3]=7 > 10? NO ‚Üí exit immediately
  // j is still 3
  
  if (i < j): // 3 < 3? NO ‚Üí don't swap

while (i < j): // 3 < 3? NO ‚Üí exit main loop

swap(arr[l], arr[j]): swap(arr[0], arr[3])
Array: [10, 2, 8, 7] ‚Üí [7, 2, 8, 10]

Return j = 3
```

So the partitioning works, but let me try a better example where we can see the swapping in action. Let me use [4, 7, 1, 9, 3]:

```
partition([4, 7, 1, 9, 3], 0, 4):
pivot = arr[0] = 4
i = 0, j = 4

while (i < j): // 0 < 4? YES

  while (arr[i] <= pivot && i < h): // while (arr[i] <= 4 && i < 4)
    i=0: arr[0]=4 <= 4? YES, 0 < 4? YES ‚Üí i++ ‚Üí i=1
    i=1: arr[1]=7 <= 4? NO ‚Üí exit loop
  // i is now 1
  
  while (arr[j] > pivot): // while (arr[j] > 4)  
    j=4: arr[4]=3 > 4? NO ‚Üí exit immediately
  // j is still 4
  
  if (i < j): // 1 < 4? YES ‚Üí swap(arr[1], arr[4])
  Array: [4, 7, 1, 9, 3] ‚Üí [4, 3, 1, 9, 7]

while (i < j): // 1 < 4? YES (continue)

  while (arr[i] <= pivot && i < h): // while (arr[i] <= 4 && i < 4)
    i=1: arr[1]=3 <= 4? YES, 1 < 4? YES ‚Üí i++ ‚Üí i=2
    i=2: arr[2]=1 <= 4? YES, 2 < 4? YES ‚Üí i++ ‚Üí i=3
    i=3: arr[3]=9 <= 4? NO ‚Üí exit loop
  // i is now 3
  
  while (arr[j] > pivot): // while (arr[j] > 4)
    j=4: arr[4]=7 > 4? YES ‚Üí j-- ‚Üí j=3
    j=3: arr[3]=9 > 4? YES ‚Üí j-- ‚Üí j=2  
    j=2: arr[2]=1 > 4? NO ‚Üí exit loop
  // j is now 2
  
  if (i < j): // 3 < 2? NO ‚Üí don't swap

while (i < j): // 3 < 2? NO ‚Üí exit main loop

swap(arr[l], arr[j]): swap(arr[0], arr[2])
Array: [4, 3, 1, 9, 7] ‚Üí [1, 3, 4, 9, 7]

Return j = 2
```

This makes much more sense! Let me update the visualization with a better example.
```

#### **Updated Visualization with Better Example: [4, 7, 1, 9, 3]**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ LEVEL 0: quickSort([4, 7, 1, 9, 3], 0, 4)          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Step 1: Partition around pivot = 4 (first element)

Initial state:
Array: [4, 7, 1, 9, 3]
        ‚Üë              ‚Üë
       i=0            j=4
    pivot=4

Round 1:
- Move i right: 4 <= 4? YES ‚Üí i=1, 7 <= 4? NO ‚Üí i stops at 1
- Move j left:  3 > 4? NO ‚Üí j stops at 4
- i < j? 1 < 4? YES ‚Üí swap(arr[1], arr[4])

Array: [4, 3, 1, 9, 7]
           ‚Üë           ‚Üë
          i=1         j=4

Round 2:  
- Move i right: 3 <= 4? YES ‚Üí i=2, 1 <= 4? YES ‚Üí i=3, 9 <= 4? NO ‚Üí i stops at 3
- Move j left:  7 > 4? YES ‚Üí j=3, 9 > 4? YES ‚Üí j=2, 1 > 4? NO ‚Üí j stops at 2
- i < j? 3 < 2? NO ‚Üí don't swap

Final step: swap(arr[0], arr[2])
Array: [1, 3, 4, 9, 7]
           ‚Üë   ‚Üë
        j=2 pivot now at correct position

pivot_index = 2
```

#### **Level 1: Recursive Calls**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ LEVEL 1a: quickSort([1,3], 0, 1) ‚îÇ  ‚îÇ LEVEL 1b: quickSort([9,7], 3, 4) ‚îÇ
‚îÇ Partition around pivot=1        ‚îÇ  ‚îÇ Partition around pivot=9        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Left sub-array [1, 3]:              Right sub-array [9, 7]:
- pivot = 1                         - pivot = 9  
- After partition: [1, 3]           - After partition: [7, 9]
- No changes needed                 - Elements swapped

Final result: [1, 3, 4, 7, 9]
```

## üîç Why Use Hoare Partition Scheme?

### Key Advantages:

1. **Fewer Swaps**: Hoare partition performs fewer swaps on average compared to Lomuto
2. **Better Performance**: More efficient in practice due to fewer operations
3. **Symmetric Design**: Both pointers move towards each other naturally

### How Two Pointers Work:

```
[smaller elements] [PIVOT] [larger elements]
 ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ j              ‚îÄ‚îÄ‚îÄ‚îÄ i ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí

After partitioning:
[‚â§ pivot] [PIVOT] [> pivot]
```

**Why return `j`?**
- After the final swap `swap(arr[l], arr[j])`, the pivot is at position `j`
- Position `j` correctly divides the array:
  - Left sub-array: indices `l` to `j-1` (elements ‚â§ pivot)
  - Pivot: at index `j` (in correct sorted position)  
  - Right sub-array: indices `j+1` to `h` (elements > pivot)

## üìà Complete Recursion Tree Example

### Array: [4, 7, 1, 9, 3]

```
                    quickSort([4,7,1,9,3], 0, 4)
                              pivot=4, returns index=2
                    Array becomes: [1,3,4,9,7]
                                    /            \
                                   /              \
                    quickSort([1,3], 0, 1)    quickSort([9,7], 3, 4)
                       pivot=1, returns 0         pivot=9, returns 3
                    Array: [1,3,4,9,7]        Array: [1,3,4,7,9]
                           /        \              /            \
                          /          \            /              \
              quickSort([],0,-1)  quickSort([3],1,1)  quickSort([],3,2)  quickSort([],4,4)
                (base case)        (base case)        (base case)        (base case)

Final Sorted Array: [1, 3, 4, 7, 9]
```

## ‚è±Ô∏è Time & Space Complexity

| Case | Time Complexity | Space Complexity | Description |
|------|----------------|------------------|-------------|
| **Best Case** | O(n log n) | O(log n) | Pivot divides array into equal halves |
| **Average Case** | O(n log n) | O(log n) | Random pivot selection |
| **Worst Case** | O(n¬≤) | O(n) | Pivot is always smallest/largest element |

## ‚úÖ Key Points to Remember

1. **Pivot Selection**: **First element** (`arr[l]`) is chosen as pivot
2. **Two Pointer Approach**: `i` moves right, `j` moves left until they meet
3. **Partitioning Goal**: Elements ‚â§ pivot go left, > pivot go right  
4. **Return Value**: `j` is pivot's final position after partitioning
5. **Recursion**: Left and right sub-arrays sorted independently
6. **Base Case**: When `l ‚â• h`, sub-array has ‚â§ 1 element (already sorted)
7. **Hoare Scheme**: Generally more efficient than Lomuto due to fewer swaps

## üéØ Example Output

```
Original array: 10 2 8 7 
Sorted array: 2 7 8 10
```

---

*The Hoare partition scheme with first element as pivot is efficient and elegant‚Äîthe two pointers naturally converge to find the perfect position for the pivot element!*
