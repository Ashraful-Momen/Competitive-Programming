# Quick Sort Algorithm - Complete Notes (Last Element as Pivot)

## âŒ Correction: Stability Statement
**Quick Sort is NOT stable, but Merge Sort IS stable**
- **Stable**: Maintains relative order of equal elements
- **Quick Sort**: Unstable (can change relative order of equal elements)
- **Merge Sort**: Stable (preserves relative order of equal elements)

## ğŸ¯ Quick Sort Algorithm Explanation

### How Quick Sort Works - Simple Understanding

Quick Sort follows **"Divide and Conquer"** strategy:
1. **Pick** the last element as pivot
2. **Partition** array so all smaller elements go left, larger go right
3. **Recursively** sort the left and right sub-arrays

### Example Understanding: Array [8, 3, 5, 4, 7, 6, 1, 2]

#### Step 1: Choose Pivot (Last Element)
```
Array: [8, 3, 5, 4, 7, 6, 1, 2]
                              â†‘
                            pivot = 2
```

#### Step 2: Partition Around Pivot
```
Goal: Move all elements < 2 to left, elements â‰¥ 2 to right

Process each element:
- 8 â‰¥ 2? â†’ stays right
- 3 â‰¥ 2? â†’ stays right  
- 5 â‰¥ 2? â†’ stays right
- 4 â‰¥ 2? â†’ stays right
- 7 â‰¥ 2? â†’ stays right
- 6 â‰¥ 2? â†’ stays right
- 1 < 2? â†’ moves left

Result: [1, 3, 5, 4, 7, 6, 8, 2]
        â†‘                     â†‘
    left partition         pivot
```

#### Step 3: Place Pivot in Correct Position
```
Swap pivot with first element of right partition:
[1, 2, 5, 4, 7, 6, 8, 3]
  â†‘  â†‘
left pivot (now in correct position)
```

#### Step 4: Recursively Sort Sub-arrays
```
Left sub-array: [1] â†’ already sorted
Right sub-array: [5, 4, 7, 6, 8, 3] â†’ apply Quick Sort again
```

## ğŸ“ Pseudocode

```
ALGORITHM QuickSort(array, low, high):
    IF low < high THEN
        pivotIndex = Partition(array, low, high)
        QuickSort(array, low, pivotIndex - 1)     // Sort left sub-array
        QuickSort(array, pivotIndex + 1, high)    // Sort right sub-array

ALGORITHM Partition(array, low, high):
    pivot = array[high]                           // Choose last element as pivot
    i = low - 1                                   // Index for smaller element
    
    FOR j = low TO high - 1 DO
        IF array[j] < pivot THEN
            i = i + 1
            SWAP array[i] with array[j]
        END IF
    END FOR
    
    SWAP array[i + 1] with array[high]            // Place pivot in correct position
    RETURN i + 1                                  // Return pivot position
```

## ğŸ’» Complete C++ Code Implementation

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to swap two elements
void swap(vector<int>& array, int i, int j) {
    if (i != j) {                    // Only swap if indices are different
        int temp = array[i];         // Store value of array[i] in temporary variable
        array[i] = array[j];         // Put value of array[j] into array[i]
        array[j] = temp;             // Put temporary value (original array[i]) into array[j]
    }
}

// Partition function - Lomuto Partition Scheme (Last element as pivot)
int partition(vector<int>& array, int low, int high) {
    // Step 1: Choose pivot (LAST element)
    int pivot = array[high];         // Pivot value is last element
    
    // Step 2: Initialize smaller element index
    int i = low - 1;                 // Index of smaller element (starts before first element)
    
    // Step 3: Traverse through array (excluding pivot)
    for (int j = low; j <= high - 1; j++) {
        // Step 4: Compare current element with pivot
        if (array[j] < pivot) {
            // Step 5: Element is smaller than pivot, move it to left partition
            i++;                     // Increment index of smaller element
            swap(array, i, j);       // Swap current element to left partition
        }
        // If array[j] >= pivot, do nothing (element stays in right partition)
    }
    
    // Step 6: Place pivot in its correct position
    swap(array, i + 1, high);       // Swap pivot with first element of right partition
    
    return (i + 1);                  // Return final position of pivot
}

// Quick Sort function
void quickSort(vector<int>& array, int low, int high) {
    if (low < high) {                // Base case: if start < end
        // Step 1: Partition the array and get pivot position
        int pivotIndex = partition(array, low, high);
        
        // Step 2: Recursively sort left sub-array (elements < pivot)
        quickSort(array, low, pivotIndex - 1);
        
        // Step 3: Recursively sort right sub-array (elements > pivot)
        quickSort(array, pivotIndex + 1, high);
    }
}

// Function to print array
void printArray(const vector<int>& array) {
    cout << "[";
    for (int i = 0; i < array.size(); i++) {
        cout << array[i];
        if (i < array.size() - 1) cout << ", ";
    }
    cout << "]" << endl;
}

// Main function
int main() {
    vector<int> array = {8, 3, 5, 4, 7, 6, 1, 2};
    
    cout << "Original array: ";
    printArray(array);
    
    quickSort(array, 0, array.size() - 1);
    
    cout << "Sorted array: ";
    printArray(array);
    
    return 0;
}
```

## ğŸ“Š Line-by-Line Code Explanation

### Partition Function Detailed Breakdown:

```cpp
int partition(vector<int>& array, int low, int high) {
```
**Line 1**: Function declaration
- `array`: Reference to input vector to partition
- `low`: Starting index of current partition
- `high`: Ending index of current partition (contains pivot)
- **Returns**: Final position of pivot after partitioning

```cpp
int pivot = array[high];
```
**Line 2**: Select pivot element
- Always choose the **last element** as pivot
- `array[high]` = last element in current partition range

```cpp
int i = low - 1;
```
**Line 3**: Initialize smaller element pointer
- `i` tracks the boundary between smaller and larger elements
- Start at `low - 1` (one position before the first element)
- **Purpose**: All elements from `low` to `i` will be < pivot

```cpp
for (int j = low; j <= high - 1; j++) {
```
**Line 4**: Loop through array (excluding pivot)
- `j` traverses from `low` to `high-1`
- Pivot (`array[high]`) is excluded from this loop

```cpp
if (array[j] < pivot) {
```
**Line 5**: Compare current element with pivot
- Check if current element should go to left partition
- Only elements **strictly smaller** than pivot go left

```cpp
i++;
swap(array, i, j);
```
**Line 6-7**: Move element to left partition
- Increment `i` to expand the "smaller elements" region
- Swap current element into the left partition at position `i`

```cpp
swap(array, i + 1, high);
```
**Line 8**: Place pivot in its final sorted position
- `i + 1` is the first position of elements â‰¥ pivot
- Swap pivot from `high` to position `i + 1`

```cpp
return (i + 1);
```
**Line 9**: Return pivot's final position
- `i + 1` is where the pivot now resides
- This position divides the array into left and right sub-arrays

## ğŸ¨ ASCII Visualization with Recursion

### Example Array: [8, 3, 5, 4, 7, 6, 1, 2]

#### **Level 0: Initial Call quickSort(array, 0, 7)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LEVEL 0: quickSort([8,3,5,4,7,6,1,2], 0, 7)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 1: Partition around pivot = 2

Initial state:
Array: [8, 3, 5, 4, 7, 6, 1, 2]
        â†‘                    â†‘
      low=0              high=7 (pivot=2)
      i=-1

Partitioning process:
j=0: 8 < 2? NO  â†’ skip
j=1: 3 < 2? NO  â†’ skip  
j=2: 5 < 2? NO  â†’ skip
j=3: 4 < 2? NO  â†’ skip
j=4: 7 < 2? NO  â†’ skip
j=5: 6 < 2? NO  â†’ skip
j=6: 1 < 2? YES â†’ i++, swap(array[0], array[6])

Array after j=6: [1, 3, 5, 4, 7, 6, 8, 2]
                  â†‘                    â†‘
                i=0                 high=7

Final step: swap(array[i+1], array[high])
           swap(array[1], array[7])

Array after partition: [1, 2, 5, 4, 7, 6, 8, 3]
                        â†‘  â†‘  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’
                     left pivot  right partition
                   pivot_index = 1
```

#### **Level 1: Recursive Calls**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LEVEL 1a: quickSort([1], 0, 0)   â”‚  â”‚ LEVEL 1b: quickSort([5,4,7,6,8,3], 2, 7) â”‚
â”‚ Base case: 0 >= 0 â†’ return       â”‚  â”‚ Continue sorting...               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Right sub-array: [5, 4, 7, 6, 8, 3]
Pivot = 3 (last element)

Partitioning:
j=2: 5 < 3? NO â†’ skip
j=3: 4 < 3? NO â†’ skip  
j=4: 7 < 3? NO â†’ skip
j=5: 6 < 3? NO â†’ skip
j=6: 8 < 3? NO â†’ skip

No swaps needed, pivot goes to position 2:
Array: [1, 2, 3, 4, 7, 6, 8, 5]
              â†‘  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’
           pivot   right
         pivot_index = 2
```

#### **Level 2: Further Recursive Calls**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LEVEL 2a: quickSort([], 2, 1)  â”‚  â”‚ LEVEL 2b: quickSort([4,7,6,8,5], 3, 7) â”‚
â”‚ Base case: 2 > 1 â†’ return      â”‚  â”‚ Continue sorting...             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Continue this process...

Final result: [1, 2, 3, 4, 5, 6, 7, 8]
```

## ğŸ” Why Return `j = i + 1`? Deep Explanation

### Understanding the Pivot Position

After partitioning, the array looks like this:
```
[elements < pivot] [pivot] [elements â‰¥ pivot]
 â†â”€â”€â”€ indices â”€â”€â”€â†’   â†‘    â†â”€â”€â”€ indices â”€â”€â”€â†’
   low to i       i+1      i+2 to high
```

**Why `i + 1` is the correct pivot position:**

1. **`i` tracks the last position of elements < pivot**
   - All elements from `low` to `i` are < pivot
   - Position `i + 1` is the first position where pivot should go

2. **`i + 1` divides the array perfectly:**
   - Left sub-array: `low` to `i` (all elements < pivot)
   - Pivot: at position `i + 1` (in correct sorted position)
   - Right sub-array: `i + 2` to `high` (all elements â‰¥ pivot)

3. **Example with numbers:**
   ```
   After partitioning [8,3,5,4,7,6,1,2]:
   Array: [1, 2, 5, 4, 7, 6, 8, 3]
           â†‘  â†‘  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’
         i=0 i+1=1   elements â‰¥ 2
   
   - Elements at index 0: [1] < 2 âœ“
   - Pivot at index 1: 2 (correct position) âœ“  
   - Elements at indices 2-7: [5,4,7,6,8,3] â‰¥ 2 âœ“
   ```

### Recursion Split Points

Returning `i + 1` allows perfect recursion:
```cpp
quickSort(array, low, pivotIndex - 1);      // Sort [low ... i]
quickSort(array, pivotIndex + 1, high);     // Sort [i+2 ... high]
```

The pivot at position `i + 1` is **never included** in recursive calls because it's already in its final sorted position!

## ğŸ“ˆ Complete Recursion Tree Example

### Array: [8, 3, 5, 4, 7, 6, 1, 2]

```
                    quickSort([8,3,5,4,7,6,1,2], 0, 7)
                              pivot=2, returns index=1
                    Array becomes: [1,2,5,4,7,6,8,3]
                                    /              \
                                   /                \
                    quickSort([1], 0, 0)    quickSort([5,4,7,6,8,3], 2, 7)
                       (base case)                   pivot=3, returns index=2
                                              Array: [1,2,3,4,7,6,8,5]
                                                         /           \
                                                        /             \
                                        quickSort([], 2, 1)    quickSort([4,7,6,8,5], 3, 7)
                                          (base case)                 pivot=5, returns index=4
                                                                Array: [1,2,3,4,5,6,8,7]
                                                                        /           \
                                                                       /             \
                                                        quickSort([4], 3, 3)   quickSort([6,8,7], 5, 7)
                                                          (base case)              pivot=7, returns index=6
                                                                              Array: [1,2,3,4,5,6,7,8]
                                                                                     /           \
                                                                                    /             \
                                                                     quickSort([6], 5, 5)   quickSort([8], 7, 7)
                                                                       (base case)           (base case)

Final Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8]
```

## â±ï¸ Time & Space Complexity

| Case | Time Complexity | Space Complexity | Description |
|------|----------------|------------------|-------------|
| **Best Case** | O(n log n) | O(log n) | Pivot divides array into equal halves |
| **Average Case** | O(n log n) | O(log n) | Random pivot selection |
| **Worst Case** | O(nÂ²) | O(n) | Pivot is always smallest/largest element |

## âœ… Key Points to Remember

1. **Pivot Selection**: **Last element** (`array[high]`) is chosen as pivot
2. **Partitioning Goal**: All elements < pivot go left, â‰¥ pivot go right  
3. **Index `i`**: Tracks boundary of left partition (elements < pivot)
4. **Return Value**: `i + 1` is pivot's final position after partitioning
5. **Recursion**: Left and right sub-arrays sorted independently
6. **Base Case**: When `low â‰¥ high`, sub-array has â‰¤ 1 element (already sorted)

## ğŸ¯ Example Output

```
Original array: [8, 3, 5, 4, 7, 6, 1, 2]
Sorted array: [1, 2, 3, 4, 5, 6, 7, 8]
```

---

*The partition function's return value `i + 1` is crucialâ€”it's the exact position where the pivot belongs in the final sorted array, making it the perfect split point for recursion!*
