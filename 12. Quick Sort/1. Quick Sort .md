# Quick Sort Algorithm - Complete Notes (Last Element as Pivot)

## ❌ Correction: Stability Statement
**Quick Sort is NOT stable, but Merge Sort IS stable**
- **Stable**: Maintains relative order of equal elements
- **Quick Sort**: Unstable (can change relative order of equal elements)
- **Merge Sort**: Stable (preserves relative order of equal elements)

## 🎯 Quick Sort Algorithm Explanation

### How Quick Sort Works - Simple Understanding

Quick Sort follows **"Divide and Conquer"** strategy:
1. **Pick** the last element as pivot
2. **Partition** array so all smaller elements go left, larger go right
3. **Recursively** sort the left and right sub-arrays

### Example Understanding: Array [8, 3, 5, 4, 7, 6, 1, 2]

#### Step 1: Choose Pivot (Last Element)
```
Array: [8, 3, 5, 4, 7, 6, 1, 2]
                              ↑
                            pivot = 2
```

#### Step 2: Partition Around Pivot
```
Goal: Move all elements < 2 to left, elements ≥ 2 to right

Process each element:
- 8 ≥ 2? → stays right
- 3 ≥ 2? → stays right  
- 5 ≥ 2? → stays right
- 4 ≥ 2? → stays right
- 7 ≥ 2? → stays right
- 6 ≥ 2? → stays right
- 1 < 2? → moves left

Result: [1, 3, 5, 4, 7, 6, 8, 2]
        ↑                     ↑
    left partition         pivot
```

#### Step 3: Place Pivot in Correct Position
```
Swap pivot with first element of right partition:
[1, 2, 5, 4, 7, 6, 8, 3]
  ↑  ↑
left pivot (now in correct position)
```

#### Step 4: Recursively Sort Sub-arrays
```
Left sub-array: [1] → already sorted
Right sub-array: [5, 4, 7, 6, 8, 3] → apply Quick Sort again
```

## 📝 Pseudocode

```
ALGORITHM QuickSort(array, low, high):
    IF low < high THEN
        pivotIndex = Partition(array, low, high)
        QuickSort(array, low, pivotIndex - 1)     // Sort left sub-array
        QuickSort(array, pivotIndex + 1, high)    // Sort right sub-array

ALGORITHM Partition(array, low, high):
    pivot = array[high]                           // Choose last element as pivot
    i = low - 1                                   // Index for smaller element
    
    FOR j = low TO high - 1 DO
        IF array[j] < pivot THEN
            i = i + 1
            SWAP array[i] with array[j]
        END IF
    END FOR
    
    SWAP array[i + 1] with array[high]            // Place pivot in correct position
    RETURN i + 1                                  // Return pivot position
```

## 💻 Complete C++ Code Implementation

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to swap two elements
void swap(vector<int>& array, int i, int j) {
    if (i != j) {                    // Only swap if indices are different
        int temp = array[i];         // Store value of array[i] in temporary variable
        array[i] = array[j];         // Put value of array[j] into array[i]
        array[j] = temp;             // Put temporary value (original array[i]) into array[j]
    }
}

// Partition function - Lomuto Partition Scheme (Last element as pivot)
int partition(vector<int>& array, int low, int high) {
    // Step 1: Choose pivot (LAST element)
    int pivot = array[high];         // Pivot value is last element
    
    // Step 2: Initialize smaller element index
    int i = low - 1;                 // Index of smaller element (starts before first element)
    
    // Step 3: Traverse through array (excluding pivot)
    for (int j = low; j <= high - 1; j++) {
        // Step 4: Compare current element with pivot
        if (array[j] < pivot) {
            // Step 5: Element is smaller than pivot, move it to left partition
            i++;                     // Increment index of smaller element
            swap(array, i, j);       // Swap current element to left partition
        }
        // If array[j] >= pivot, do nothing (element stays in right partition)
    }
    
    // Step 6: Place pivot in its correct position
    swap(array, i + 1, high);       // Swap pivot with first element of right partition
    
    return (i + 1);                  // Return final position of pivot
}

// Quick Sort function
void quickSort(vector<int>& array, int low, int high) {
    if (low < high) {                // Base case: if start < end
        // Step 1: Partition the array and get pivot position
        int pivotIndex = partition(array, low, high);
        
        // Step 2: Recursively sort left sub-array (elements < pivot)
        quickSort(array, low, pivotIndex - 1);
        
        // Step 3: Recursively sort right sub-array (elements > pivot)
        quickSort(array, pivotIndex + 1, high);
    }
}

// Function to print array
void printArray(const vector<int>& array) {
    cout << "[";
    for (int i = 0; i < array.size(); i++) {
        cout << array[i];
        if (i < array.size() - 1) cout << ", ";
    }
    cout << "]" << endl;
}

// Main function
int main() {
    vector<int> array = {8, 3, 5, 4, 7, 6, 1, 2};
    
    cout << "Original array: ";
    printArray(array);
    
    quickSort(array, 0, array.size() - 1);
    
    cout << "Sorted array: ";
    printArray(array);
    
    return 0;
}
```

## 📊 Line-by-Line Code Explanation

### Partition Function Detailed Breakdown:

```cpp
int partition(vector<int>& array, int low, int high) {
```
**Line 1**: Function declaration
- `array`: Reference to input vector to partition
- `low`: Starting index of current partition
- `high`: Ending index of current partition (contains pivot)
- **Returns**: Final position of pivot after partitioning

```cpp
int pivot = array[high];
```
**Line 2**: Select pivot element
- Always choose the **last element** as pivot
- `array[high]` = last element in current partition range

```cpp
int i = low - 1;
```
**Line 3**: Initialize smaller element pointer
- `i` tracks the boundary between smaller and larger elements
- Start at `low - 1` (one position before the first element)
- **Purpose**: All elements from `low` to `i` will be < pivot

```cpp
for (int j = low; j <= high - 1; j++) {
```
**Line 4**: Loop through array (excluding pivot)
- `j` traverses from `low` to `high-1`
- Pivot (`array[high]`) is excluded from this loop

```cpp
if (array[j] < pivot) {
```
**Line 5**: Compare current element with pivot
- Check if current element should go to left partition
- Only elements **strictly smaller** than pivot go left

```cpp
i++;
swap(array, i, j);
```
**Line 6-7**: Move element to left partition
- Increment `i` to expand the "smaller elements" region
- Swap current element into the left partition at position `i`

```cpp
swap(array, i + 1, high);
```
**Line 8**: Place pivot in its final sorted position
- `i + 1` is the first position of elements ≥ pivot
- Swap pivot from `high` to position `i + 1`

```cpp
return (i + 1);
```
**Line 9**: Return pivot's final position
- `i + 1` is where the pivot now resides
- This position divides the array into left and right sub-arrays

## 🎨 ASCII Visualization with Recursion

### Example Array: [8, 3, 5, 4, 7, 6, 1, 2]

#### **Level 0: Initial Call quickSort(array, 0, 7)**

```
┌─────────────────────────────────────────────────────┐
│ LEVEL 0: quickSort([8,3,5,4,7,6,1,2], 0, 7)       │
└─────────────────────────────────────────────────────┘

Step 1: Partition around pivot = 2

Initial state:
Array: [8, 3, 5, 4, 7, 6, 1, 2]
        ↑                    ↑
      low=0              high=7 (pivot=2)
      i=-1

Partitioning process:
j=0: 8 < 2? NO  → skip
j=1: 3 < 2? NO  → skip  
j=2: 5 < 2? NO  → skip
j=3: 4 < 2? NO  → skip
j=4: 7 < 2? NO  → skip
j=5: 6 < 2? NO  → skip
j=6: 1 < 2? YES → i++, swap(array[0], array[6])

Array after j=6: [1, 3, 5, 4, 7, 6, 8, 2]
                  ↑                    ↑
                i=0                 high=7

Final step: swap(array[i+1], array[high])
           swap(array[1], array[7])

Array after partition: [1, 2, 5, 4, 7, 6, 8, 3]
                        ↑  ↑  ←─────────────→
                     left pivot  right partition
                   pivot_index = 1
```

#### **Level 1: Recursive Calls**

```
┌───────────────────────────────────┐  ┌───────────────────────────────────┐
│ LEVEL 1a: quickSort([1], 0, 0)   │  │ LEVEL 1b: quickSort([5,4,7,6,8,3], 2, 7) │
│ Base case: 0 >= 0 → return       │  │ Continue sorting...               │
└───────────────────────────────────┘  └───────────────────────────────────┘

Right sub-array: [5, 4, 7, 6, 8, 3]
Pivot = 3 (last element)

Partitioning:
j=2: 5 < 3? NO → skip
j=3: 4 < 3? NO → skip  
j=4: 7 < 3? NO → skip
j=5: 6 < 3? NO → skip
j=6: 8 < 3? NO → skip

No swaps needed, pivot goes to position 2:
Array: [1, 2, 3, 4, 7, 6, 8, 5]
              ↑  ←─────────→
           pivot   right
         pivot_index = 2
```

#### **Level 2: Further Recursive Calls**

```
┌─────────────────────────────────┐  ┌─────────────────────────────────┐
│ LEVEL 2a: quickSort([], 2, 1)  │  │ LEVEL 2b: quickSort([4,7,6,8,5], 3, 7) │
│ Base case: 2 > 1 → return      │  │ Continue sorting...             │
└─────────────────────────────────┘  └─────────────────────────────────┘

Continue this process...

Final result: [1, 2, 3, 4, 5, 6, 7, 8]
```

## 🔍 Why Return `j = i + 1`? Deep Explanation

### Understanding the Pivot Position

After partitioning, the array looks like this:
```
[elements < pivot] [pivot] [elements ≥ pivot]
 ←─── indices ───→   ↑    ←─── indices ───→
   low to i       i+1      i+2 to high
```

**Why `i + 1` is the correct pivot position:**

1. **`i` tracks the last position of elements < pivot**
   - All elements from `low` to `i` are < pivot
   - Position `i + 1` is the first position where pivot should go

2. **`i + 1` divides the array perfectly:**
   - Left sub-array: `low` to `i` (all elements < pivot)
   - Pivot: at position `i + 1` (in correct sorted position)
   - Right sub-array: `i + 2` to `high` (all elements ≥ pivot)

3. **Example with numbers:**
   ```
   After partitioning [8,3,5,4,7,6,1,2]:
   Array: [1, 2, 5, 4, 7, 6, 8, 3]
           ↑  ↑  ←─────────────→
         i=0 i+1=1   elements ≥ 2
   
   - Elements at index 0: [1] < 2 ✓
   - Pivot at index 1: 2 (correct position) ✓  
   - Elements at indices 2-7: [5,4,7,6,8,3] ≥ 2 ✓
   ```

### Recursion Split Points

Returning `i + 1` allows perfect recursion:
```cpp
quickSort(array, low, pivotIndex - 1);      // Sort [low ... i]
quickSort(array, pivotIndex + 1, high);     // Sort [i+2 ... high]
```

The pivot at position `i + 1` is **never included** in recursive calls because it's already in its final sorted position!

## 📈 Complete Recursion Tree Example

### Array: [8, 3, 5, 4, 7, 6, 1, 2]

```
                    quickSort([8,3,5,4,7,6,1,2], 0, 7)
                              pivot=2, returns index=1
                    Array becomes: [1,2,5,4,7,6,8,3]
                                    /              \
                                   /                \
                    quickSort([1], 0, 0)    quickSort([5,4,7,6,8,3], 2, 7)
                       (base case)                   pivot=3, returns index=2
                                              Array: [1,2,3,4,7,6,8,5]
                                                         /           \
                                                        /             \
                                        quickSort([], 2, 1)    quickSort([4,7,6,8,5], 3, 7)
                                          (base case)                 pivot=5, returns index=4
                                                                Array: [1,2,3,4,5,6,8,7]
                                                                        /           \
                                                                       /             \
                                                        quickSort([4], 3, 3)   quickSort([6,8,7], 5, 7)
                                                          (base case)              pivot=7, returns index=6
                                                                              Array: [1,2,3,4,5,6,7,8]
                                                                                     /           \
                                                                                    /             \
                                                                     quickSort([6], 5, 5)   quickSort([8], 7, 7)
                                                                       (base case)           (base case)

Final Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8]
```

## ⏱️ Time & Space Complexity

| Case | Time Complexity | Space Complexity | Description |
|------|----------------|------------------|-------------|
| **Best Case** | O(n log n) | O(log n) | Pivot divides array into equal halves |
| **Average Case** | O(n log n) | O(log n) | Random pivot selection |
| **Worst Case** | O(n²) | O(n) | Pivot is always smallest/largest element |

## ✅ Key Points to Remember

1. **Pivot Selection**: **Last element** (`array[high]`) is chosen as pivot
2. **Partitioning Goal**: All elements < pivot go left, ≥ pivot go right  
3. **Index `i`**: Tracks boundary of left partition (elements < pivot)
4. **Return Value**: `i + 1` is pivot's final position after partitioning
5. **Recursion**: Left and right sub-arrays sorted independently
6. **Base Case**: When `low ≥ high`, sub-array has ≤ 1 element (already sorted)

## 🎯 Example Output

```
Original array: [8, 3, 5, 4, 7, 6, 1, 2]
Sorted array: [1, 2, 3, 4, 5, 6, 7, 8]
```

---

*The partition function's return value `i + 1` is crucial—it's the exact position where the pivot belongs in the final sorted array, making it the perfect split point for recursion!*
