
---

# 📌 QuickSort — Notes (Two Pointer with `i < j`)

arr = `[3,4,2,5,1]`

👉 Consider pivot is the **first element** of the array.
Example: `arr[0] = 3`

👉 Move all elements **smaller** than pivot → left side.
👉 Move all elements **greater** than pivot → right side.

---

## 🔑 Partition Concept

We separate array into **3 parts**:

```
[ (smaller elements) , (pivot) , (bigger elements) ]
= [ left side from pivot , pivot , right side from pivot ]
= [ (1,2) smaller -----> , 3 , <----- bigger (4,5) ]
= [1,2,3,4,5]
```

---

## ⚙️ Core Concept of Partition (Two Pointers)

1. Take pivot = **first element**.

   * `i` starts from **left** (`l`).
   * `j` starts from **right** (`h`).

2. While `(i < j)`:

   * move `i` right until you find element **> pivot**
   * move `j` left until you find element **<= pivot**
   * if `(i < j)` → swap `arr[i] , arr[j]`

3. When loop breaks `(i >= j)`:

   * pivot’s correct position = `j`
   * swap `arr[l] , arr[j]`

4. Return pivot index `j`.

---

## 🔢 Partition Algorithm (Two Pointer, `i < j`)

```cpp
int partition(vector<int>& arr, int l, int h) {
    int pivot = arr[l];    // pivot = first element
    int i = l;             // start from left
    int j = h;             // start from right

    while (i < j) {
        while (arr[i] <= pivot && i < h) i++;   // find element > pivot
        while (arr[j] > pivot && j > l) j--;    // find element <= pivot
        if (i < j) {
            swap(arr[i], arr[j]);
        }
    }

    // pivot goes to its correct place
    swap(arr[l], arr[j]);
    return j;   // pivot index
}
```

---

## 🏗️ Main QuickSort Function

```cpp
void quickSort(vector<int>& arr, int l, int h) {
    if (l < h) {
        int p = partition(arr, l, h);  // pivot index
        quickSort(arr, l, p - 1);      // sort left side
        quickSort(arr, p + 1, h);      // sort right side
    }
}
```

---

## ✅ Full Code Example

```cpp
#include <bits/stdc++.h>
using namespace std;

int partition(vector<int>& arr, int l, int h) {
    int pivot = arr[l];
    int i = l, j = h;

    while (i < j) {
        while (arr[i] <= pivot && i < h) i++;
        while (arr[j] > pivot && j > l) j--;
        if (i < j) {
            swap(arr[i], arr[j]);
        }
    }

    swap(arr[l], arr[j]); // pivot placed correctly
    return j;
}

void quickSort(vector<int>& arr, int l, int h) {
    if (l < h) {
        int p = partition(arr, l, h);
        quickSort(arr, l, p - 1);
        quickSort(arr, p + 1, h);
    }
}

int main() {
    vector<int> arr = {3,4,2,5,1};
    cout << "Before sort: ";
    for (int x : arr) cout << x << " ";
    cout << "\n";

    quickSort(arr, 0, arr.size()-1);

    cout << "After sort:  ";
    for (int x : arr) cout << x << " ";
    cout << "\n";
    return 0;
}
```

---

## 📝 Cheatsheet

* **Pivot = first element**
* `i = l`, `j = h`, loop while `i < j`
* Move `i` → until find `> pivot`
* Move `j` → until find `<= pivot`
* Swap when `(i < j)`
* Finally swap pivot with `arr[j]`
* Complexity → Best/Average: `O(n log n)` ; Worst: `O(n²)`

---
